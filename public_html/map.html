<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ CSS -->
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>{{translate "title"}}</title>

		<!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ CSS Leaflet -->
		<link rel="stylesheet" href="/static/leaflet.css" />

		<style>
/* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ */
body, html {
	margin: 0;
	padding: 0;
	height: 100%;
	overflow: hidden; /* –£–±–∏—Ä–∞–µ–º –ø–æ–ª–æ—Å—ã –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ */
}

				/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–∞—Ä—Ç—ã */
				#map {
					height: 100vh; /* –í—ã—Å–æ—Ç–∞ –∫–∞—Ä—Ç—ã –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω */
					margin: 0;
					overflow: hidden;
				}

				/* –°—Ç–∏–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –ø–æ–¥—Å–∫–∞–∑–∫–∏ (tooltip) */
				.custom-tooltip {
					background-color: white;
					border-radius: 5px;
					padding: 10px;
					color: #333;
					box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
				}

				/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ */
				.upload-btn-container {
					position: absolute;
					top: 20px;
					right: 20px;
					z-index: 1000;
				}

				/* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ */
				.upload-btn {
					background-color: white;
					border: 1px solid #ccc;
					border-radius: 4px;
					padding: 5px 10px;
					cursor: pointer;
					font-size: 14px;
					box-shadow: 0 1px 5px rgba(0,0,0,0.65);
				}

				/* –û–≤–µ—Ä–ª–µ–π –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ */
				#fileOverlay {
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background-color: rgba(0, 0, 0, 0.7);
					z-index: 10000;
					display: flex;
					justify-content: center;
					align-items: center;
				}

				/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ */
				#fileProgressContainer {
					background-color: white;
					padding: 20px;
					border-radius: 10px;
					max-width: 600px;
					width: 100%;
					box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
				}

				/* –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ */
				.file-progress {
					margin-bottom: 15px;
				}

				.file-name {
					font-weight: bold;
					margin-bottom: 5px;
				}

				/* –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä */
				.progress-bar {
					width: 100%;
					height: 10px;
					background-color: #f4f4f4;
					border-radius: 5px;
					overflow: hidden;
				}

				.progress-bar-inner {
					height: 100%;
					background-color: #4caf50;
					width: 0%;
				}

				/* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ */
				.server-processing {
					margin-left: 10px;
					font-size: 14px;
					color: #ff9800;
				}

				/* –≠—Ñ—Ñ–µ–∫—Ç –Ω–∞–≤–µ–¥–µ–Ω–∏—è –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ */
				.upload-btn:hover {
					background-color: #f4f4f4;
				}

				/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ */
				.locate-btn-container {
					position: absolute;
					top: 60px;
					right: 20px;
					z-index: 1000;
				}

				/* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ */
				.locate-btn {
					background-color: white;
					border: 1px solid #ccc;
					border-radius: 4px;
					padding: 5px 10px;
					cursor: pointer;
					font-size: 16px;
					box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
					display: flex;
					align-items: center;
					justify-content: center;
				}

				/* –≠—Ñ—Ñ–µ–∫—Ç –Ω–∞–≤–µ–¥–µ–Ω–∏—è –¥–ª—è –∫–Ω–æ–ø–∫–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ */
				.locate-btn:hover {
					background-color: #f4f4f4;
				}

				/* –°—Ç–∏–ª–∏ –¥–ª—è —Å—Å—ã–ª–∫–∏ –Ω–∞ GitHub */
				.github-link {
					position: absolute;
					bottom: 20px;
					left: 20px;
					z-index: 1000;
				}

				.github-icon {
					width: 40px;
					height: 40px;
					opacity: 0.6;
				}

				.github-icon:hover {
					opacity: 1;
				}

				/* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–≥—Ä–∞–º–º–µ */
				.program-info {
					position: absolute;
					bottom: 20px;
					left: 70px;
					z-index: 1000;
					color: #333;
					font-size: 14px;
					opacity: 0.6;
				}

				.program-info a {
					color: #007bff;
					text-decoration: none;
				}

				.program-info a:hover {
					text-decoration: underline;
				}

				.program-info:hover {
					opacity: 1;
				}

				/* –ö–Ω–æ–ø–∫–∞ "–í–µ—Ä–Ω—É—Ç—å—Å—è –∫–æ –≤—Å–µ–º —Ç—Ä–µ–∫–∞–º" */
				.back-to-all-container {
					position: absolute;
					top: 120px;
					right: 20px;
					z-index: 1000;
					display: none;
				}

				.back-to-all-btn {
					background-color: white;
					border: 1px solid #ccc;
					border-radius: 4px;
					padding: 5px 10px;
					cursor: pointer;
					font-size: 14px;
					box-shadow: 0 1px 5px rgba(0,0,0,0.65);
				}

				.back-to-all-btn:hover {
					background-color: #f4f4f4;
				}
		</style>

		<!-- –°–∫—Ä–∏–ø—Ç –ø–µ—Ä–µ–≤–æ–¥–æ–≤ -->
		<script id="translations-script">
			// –û–±—ä–µ–∫—Ç –ø–µ—Ä–µ–≤–æ–¥–æ–≤, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –∏–∑ Go
			var translations = JSON.parse('{{ .Translations | toJSON }}');
				var currentLang = '{{ .Lang }}'; // –¢–µ–∫—É—â–∏–π —è–∑—ã–∫

				// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ –ø–æ –∫–ª—é—á—É
				function translate(key) {
						if (!translations['en']) {
								console.error('English translations not available!');
								return key;
						}

						if (translations[currentLang] && translations[currentLang][key]) {
								return translations[currentLang][key];
						} else if (translations['en'][key]) {
								return translations['en'][key];
						}
						return key;
				}
		</script>
		<script>
			const defaultCfg = {
				lat:  {{printf "%.6f" .DefaultLat}},
				lon:  {{printf "%.6f" .DefaultLon}},
				zoom: {{.DefaultZoom}},
				layer: {{.DefaultLayer}}
			};
		</script>

	</head>

	<body>
		<!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ -->
		<div class="upload-btn-container leaflet-control">
			<label for="fileInput" class="upload-btn">{{translate "upload_button"}}</label>
			<input type="file" id="fileInput" style="display: none;" multiple onchange="uploadFiles()">
		</div>

		<!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ -->
		<div class="locate-btn-container leaflet-control">
			<button id="locateButton" class="locate-btn" title="{{translate "locate_button_tooltip"}}">
				<img src="/static/images/marker-icon-2x.png" alt="Locate" style="width: 20px;">
			</button>
		</div>

		<!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ "–í–µ—Ä–Ω—É—Ç—å—Å—è –∫–æ –≤—Å–µ–º —Ç—Ä–µ–∫–∞–º" -->
		<div class="back-to-all-container leaflet-control" style="display: none;">
			<button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
		</div>

		<!-- –û–≤–µ—Ä–ª–µ–π –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ -->
		<div id="fileOverlay" style="display: none;">
			<div id="fileProgressContainer">
				<!-- –ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è —Å—é–¥–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
			</div>
		</div>

		<!-- –°—Å—ã–ª–∫–∞ –Ω–∞ GitHub –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–≥—Ä–∞–º–º–µ -->
		<a href="https://github.com/matveynator/chicha-isotope-map" class="github-link" target="_blank">
			<img src="/static/images/GitHub-Mark.png" alt="GitHub" class="github-icon">
		</a>

		<div class="program-info">
			<strong>{{translate "description"}}</strong><br>
			v.<a href="https://github.com/matveynator/chicha-isotope-map/releases/tag/latest" target="_blank">{{ .Version }}</a>
		</div>

		<!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–∞—Ä—Ç—ã -->
		<div id="map"></div>

		<!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ JavaScript –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Leaflet -->
		<script src="/static/leaflet.js"></script>

		<!-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ -->
		<script>
			// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ —Ü–≤–µ—Ç–∞ –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —É—Ä–æ–≤–Ω—è —Ä–∞–¥–∏–∞—Ü–∏–∏
			function getGradientColor(doseRate) {
				if (doseRate <= 0.04) return "#006400"; // –¢—ë–º–Ω–æ-–∑–µ–ª—ë–Ω—ã–π
				else if (doseRate <= 0.08) return interpolateColor([0, 100, 0], [173, 255, 47], (doseRate - 0.04) / (0.08 - 0.04));
				else if (doseRate <= 0.11) return interpolateColor([173, 255, 47], [255, 255, 0], (doseRate - 0.08) / (0.11 - 0.08));
				else if (doseRate <= 0.20) return interpolateColor([255, 255, 0], [255, 165, 0], (doseRate - 0.11) / (0.20 - 0.11));
				else if (doseRate <= 0.30) return interpolateColor([255, 165, 0], [255, 0, 0], (doseRate - 0.20) / (0.30 - 0.20));
				else if (doseRate <= 0.99) return interpolateColor([255, 0, 0], [0, 0, 0], (doseRate - 0.30) / (0.99 - 0.30));
				else return "#000000"; // –ß—ë—Ä–Ω—ã–π –¥–ª—è –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
			}

// –§—É–Ω–∫—Ü–∏—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ –º–µ–∂–¥—É –¥–≤—É–º—è —Ü–≤–µ—Ç–∞–º–∏
function interpolateColor(color1, color2, factor) {
	if (factor < 0) factor = 0;
	if (factor > 1) factor = 1;

	const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
	const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
	const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

	return `rgb(${r}, ${g}, ${b})`;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ —Ä–∞–¥–∏—É—Å–∞ –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —É—Ä–æ–≤–Ω—è –∑—É–º–∞
function getRadius(doseRate, zoomLevel) {
	// —Ä–∞–Ω—å—à–µ: Math.pow(2, (zoomLevel-10)/2)
	const k = 1.8;                               // –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º ~√ó2
	let r   = Math.pow(2, (zoomLevel - 10)/2) * k;
	return Math.max(r, 2);                       // –∑–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –º–µ–ª–∫–∏—Ö
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 */
function shouldDisplayBySpeed(speed) {
	const st = loadSpeedFilterState();
	if (speed >= 70 && speed <= 500) return st.plane;
	if (speed >= 7  && speed <  70)  return st.car;
	/* speed < 7 m/s ‚áí pedestrian */
	return st.ped;
}


// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∑–∞–ª–∏–≤–∫–∏ –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
function getFillOpacity(speed) {
	if (speed <= 5) {
		return 0.6;
	} else if (speed >= 20) {
		return 0.1;
	} else {
		var opacityRange = 0.6 - 0.1;
		var speedRange = 20 - 5;
		var opacityDecreasePerMs = opacityRange / speedRange;
		var speedAboveFive = speed - 5;
		var totalOpacityDecrease = speedAboveFive * opacityDecreasePerMs;
		var currentOpacity = 0.6 - totalOpacityDecrease;
		return currentOpacity;
	}
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≤—Å–ø–ª—ã–≤–∞—é—â–µ–≥–æ –æ–∫–Ω–∞ –º–∞—Ä–∫–µ—Ä–∞
function getTooltipContent(marker) {
	var date = new Date(marker.date * 1000);
	var formattedDate = date.toLocaleString();

	return `
		<div class="custom-tooltip">
		<div class="tooltip-row">
		<strong>${translate('radiation_dose')}:</strong>
		<span>${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)</span>
		</div>
		<div class="tooltip-row">
		<strong>${translate('speed')}:</strong>
		<span>${(marker.speed * 3.6).toFixed(1)} km/h</span>
		</div>
		<div class="tooltip-row">
		<strong>${translate('track_id')}:</strong>
		<span>${marker.trackID}</span>
		</div>
		</div>
		`;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ URL –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–∞—Ä—Ç—ã
function getCurrentUrlParams() {
	var bounds = map.getBounds();
	var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
	var minLat = bounds.getSouthWest().lat.toFixed(5);
	var minLon = bounds.getSouthWest().lng.toFixed(5);
	var maxLat = bounds.getNorthEast().lat.toFixed(5);
	var maxLon = bounds.getNorthEast().lng.toFixed(5);
	var zoom = map.getZoom();

	return `?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;
}
		</script>

		<!-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã –∏ —Ä–∞–±–æ—Ç–∞ —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏ -->
		<script>
			var map;
var circleMarkers = {};
var isTrackView = false;
var osmLayer, googleSatellite;
var trackBounds;
var currentTrackID = null;

/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return default state
 *   ‚úàÔ∏è off, üöó on, üö∂ on  (as requested).
 */
function loadSpeedFilterState() {
	const def = { plane: false, car: true, ped: true };
	try {
		const raw = sessionStorage.getItem('speedFilterState');
		return raw ? JSON.parse(raw) : def;
	} catch (e) {
		return def;
	}
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user‚Äôs choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
	sessionStorage.setItem('speedFilterState', JSON.stringify(state));
}


document.addEventListener('DOMContentLoaded', function () {

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è trackID –ø–æ –ø—É—Ç–∏
	var match = window.location.pathname.match(/^\/trackid\/([a-zA-Z0-9]+)/);
	if (match) {
		currentTrackID = match[1];
		isTrackView = true;
		// <<< –ù–û–í–û–ï: —Å—Ä–∞–∑—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –≤–æ–∑–≤—Ä–∞—Ç–∞ >>>
		var backBox = document.querySelector('.back-to-all-container');
		if (backBox) backBox.style.display = 'block';
	}
	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ—ë–≤ –∫–∞—Ä—Ç—ã
	osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		maxZoom: 18,
		attribution: '&copy; OpenStreetMap contributors'
	});

	googleSatellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
		maxZoom: 20,
		attribution: '&copy; Google'
	});

	// —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è osmLayer –∏ googleSatellite
	const urlParams       = new URLSearchParams(window.location.search);
	const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
	const startLayer      = startLayerName === 'Google Satellite' ? googleSatellite : osmLayer;

	map = L.map('map', {
		center: [defaultCfg.lat, defaultCfg.lon],
		zoom  : defaultCfg.zoom,
		layers: [startLayer],           // —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –±–∞–∑–æ–≤—ã–π —Å–ª–æ–π
	});

	// –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å–ª–æ—ë–≤
	var baseLayers = {
		"OpenStreetMap": osmLayer,
		"Google Satellite": googleSatellite
	};

	L.control.layers(baseLayers, null, {
		position: 'topleft',
		collapsed: false
	}).addTo(map);

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ç—Ä–µ–∫–∞
	var initialMarkers = JSON.parse('{{ .Markers | toJSON }}');
	if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
		isTrackView = true;

		// –ù–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º initialMarkers —Å—Ä–∞–∑—É, –∞ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ —á–∞—Å—Ç—è–º —á–µ—Ä–µ–∑ get_markers
		map.on('load', debounceUpdateMarkers);

		// –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –º–∞—Ä–∫–µ—Ä–æ–≤ –ø—Ä–∏ –∑—É–º–µ
		map.on('zoomend', function() {
			adjustMarkerRadius();
			debounceUpdateMarkers();
		});
		map.on('moveend', debounceUpdateMarkers);
	} else {
		// –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞—Ä–∫–µ—Ä–æ–≤ –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ
		map.on('load', debounceUpdateMarkers);
		map.on('zoomend', function() {
			adjustMarkerRadius();
			debounceUpdateMarkers();
		});
		map.on('moveend', debounceUpdateMarkers);
		debounceUpdateMarkers;
	}

	// –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–∞—Ä—Ç—ã –∏–∑ URL
	loadMapFromUrl();

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ URL –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –Ω–∞ –∫–∞—Ä—Ç–µ
	map.on('baselayerchange', updateUrl);
	map.on('moveend', updateUrl);
	map.on('zoomend', updateUrl);

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
	initializeUIElements();

	/**
	 * Build a Leaflet control with three check-boxes that filter markers
	 * by recorded speed. Labels now show speed in km/h instead of m/s.
	 * Default state: ‚úàÔ∏è off, üöó on, üö∂ on.
	 */
	function createSpeedFilterControls() {
		// load previously saved state (or defaults)
		const state = loadSpeedFilterState();

		// custom Leaflet control
		const SpeedCtrl = L.Control.extend({
			onAdd() {
				const div = L.DomUtil.create('div', 'leaflet-control-layers');
				div.style.padding = '6px 10px';

				// helper that returns one <label> line
				const row = (id, emoji, checked) => `
						<label style="white-space:nowrap;display:block;cursor:pointer;">
						<input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
					${emoji}
						</label>`;

				// order: ‚úàÔ∏è, üöó, üö∂  (top ‚Üí bottom)
				div.innerHTML =
					row('sfPlane', '‚úàÔ∏è',  state.plane) +
					row('sfCar',   'üöó', state.car)   +
					row('sfPed',   'üö∂', state.ped);

				// prevent map drag/zoom while clicking inside the control
				L.DomEvent.disableClickPropagation(div);

				// attach change-handlers
				div.querySelectorAll('input[type=checkbox]').forEach(cb => {
					cb.addEventListener('change', () => {
						state.plane = div.querySelector('#sfPlane').checked;
						state.car   = div.querySelector('#sfCar').checked;
						state.ped   = div.querySelector('#sfPed').checked;
						saveSpeedFilterState(state);   // remember choice
						debounceUpdateMarkers();       // redraw with new filter
					});
				});

				return div;
			}
		});

		new SpeedCtrl({ position: 'topleft' }).addTo(map);
	}






	// Call it
	createSpeedFilterControls();   

});

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π

// ---------- POP-UP —Å–æ —Å—Å—ã–ª–∫–æ–π –Ω–∞ —Ç—Ä–µ–∫ ----------
function getPopupContent(marker) {
	const dateStr = new Date(marker.date * 1000).toLocaleString();
	return `
		<div class="custom-tooltip">
		<div><strong>${translate('radiation_dose')}:</strong>
	${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)
		</div>
		<div><strong>${translate('speed')}:</strong> ${(marker.speed * 3.6).toFixed(1)} km/h</div>
		<div style="margin-top:4px">
		<!-- —â—ë–ª–∫ –ø–æ —Å—Å—ã–ª–∫–µ = –ø–µ—Ä–µ—Ö–æ–¥ –≤ —Ä–µ–∂–∏–º —Ç—Ä–µ–∫–∞ -->
		<a href="javascript:viewTrack('${marker.trackID}')" style="font-weight:bold;">
	${translate('track_id')}: ${marker.trackID}
		</a>
		</div>
		</div>`;
}



/**
 * Fetch markers for the current map view and (optionally) current track.
 * Draw only those that pass the user-selected speed filter.
 * Extra-robust: handles empty/invalid JSON so .forEach() never crashes.
 */
function updateMarkers() {

	const zoomLevel = map.getZoom();
	const bounds    = map.getBounds();

	const params = {
		zoom  : zoomLevel,
		minLat: bounds.getSouthWest().lat,
		minLon: bounds.getSouthWest().lng,
		maxLat: bounds.getNorthEast().lat,
		maxLon: bounds.getNorthEast().lng
	};

	// --- –Ω–æ–≤—ã–π –∫–æ–¥: –∫–∞–∫–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ –æ—Å—Ç–∞–≤–ª—è—Ç—å ---
	const st      = loadSpeedFilterState();          // ‚úàÔ∏è üöó üö∂
	const speeds  = [];
	if (st.plane) speeds.push('plane');
	if (st.car)   speeds.push('car');
	if (st.ped)   speeds.push('ped');
	if (speeds.length && speeds.length !== 3) {      // –≤—Å–µ 3 ‚Äî –Ω–µ –ø–æ—Å—ã–ª–∞–µ–º –≤–æ–≤—Å–µ
		params.speeds = speeds.join(',');
	}

	if (isTrackView && currentTrackID) params.trackID = currentTrackID;

	const url = '/get_markers?' + new URLSearchParams(params);

	fetch(url)
		.then(r => {
			if (!r.ok) throw new Error(`HTTP ${r.status}`);
			return r.json();                       // may be null / object
		})
		.then(json => {
			// --- normalise payload to an array --------------------------
			let data = [];
			if (Array.isArray(json)) {
				data = json;
			} else if (json && Array.isArray(json.markers)) {
				data = json.markers;
			} else if (json !== null) {
				console.warn('Unexpected get_markers payload:', json);
			}
			// -------------------------------------------------------------

			// remove old circles
			for (const key in circleMarkers) map.removeLayer(circleMarkers[key]);
			circleMarkers = {};

			data.forEach(marker => {
				if (!shouldDisplayBySpeed(marker.speed)) return;   // ‚Üê filter

				const markerKey = marker.id || marker.trackID;
				const color     = getGradientColor(marker.doseRate);
				const radius    = getRadius(marker.doseRate, zoomLevel);

				const circleMarker = L.circleMarker([marker.lat, marker.lon], {
					radius      : radius,
					fillColor   : color,
					color       : color,
					weight      : 1,
					opacity     : getFillOpacity(marker.speed) + 0.1,
					fillOpacity : getFillOpacity(marker.speed)
				})
					.addTo(map)
					.bindTooltip(getTooltipContent(marker),
						{ direction: 'top',
							className: 'custom-tooltip',
							offset: [0, -8],
							permanent: false })
					.bindPopup(getPopupContent(marker));

				circleMarker.doseRate      = marker.doseRate; // for zoom scaling
				circleMarkers[markerKey]   = circleMarker;
			});
		})
		.catch(err => console.error('Error fetching markers:', err));
}

let debounceTimeout;

function debounceUpdateMarkers() {
	clearTimeout(debounceTimeout);
	debounceTimeout = setTimeout(updateMarkers, 300);
}

function adjustMarkerRadius() {
	var zoomLevel = map.getZoom();
	for (let key in circleMarkers) {
		let marker = circleMarkers[key];
		let newRadius = getRadius(marker.doseRate, zoomLevel);
		marker.setRadius(newRadius);
	}
}

function viewTrack(trackID) {
	isTrackView = true;
	var bounds = map.getBounds();
	var layer = '';
	var zoom = map.getZoom(); // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∑—É–º

	if (map.hasLayer(googleSatellite)) {
		layer = 'Google Satellite';
	} else {
		layer = 'OpenStreetMap';
	}

	// –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞
	var trackURL = `/trackid/${trackID}?minLat=${bounds.getSouthWest().lat}&minLon=${bounds.getSouthWest().lng}&maxLat=${bounds.getNorthEast().lat}&maxLon=${bounds.getNorthEast().lng}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;

	// –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞
	window.location.href = trackURL;
}

function setBaseLayer(layerName) {
	if (layerName === 'Google Satellite') {
		if (map.hasLayer(osmLayer))            map.removeLayer(osmLayer);
		if (!map.hasLayer(googleSatellite))    googleSatellite.addTo(map);
	} else {
		if (map.hasLayer(googleSatellite))     map.removeLayer(googleSatellite);
		if (!map.hasLayer(osmLayer))           osmLayer.addTo(map);
	}
}

function loadMapFromUrl() {
	const params = new URLSearchParams(window.location.search);

	/* –±–∞–∑–æ–≤—ã–π —Å–ª–æ–π –∏–∑ URL (–∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç) */
	const layer = decodeURIComponent(params.get('layer') || defaultCfg.layer);
	setBaseLayer(layer);

	/* —á–∏—Ç–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã */
	const minLat = parseFloat(params.get('minLat'));
	const minLon = parseFloat(params.get('minLon'));
	const maxLat = parseFloat(params.get('maxLat'));
	const maxLon = parseFloat(params.get('maxLon'));

	if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
		map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
		adjustMarkerRadius();
	} else if (isTrackView && trackBounds) {
		map.fitBounds(trackBounds);
	} else {
		map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
	}
}

function updateUrl() {
	var bounds = map.getBounds();
	var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
	var minLat = bounds.getSouthWest().lat.toFixed(5);
	var minLon = bounds.getSouthWest().lng.toFixed(5);
	var maxLat = bounds.getNorthEast().lat.toFixed(5);
	var maxLon = bounds.getNorthEast().lng.toFixed(5);
	var zoom = map.getZoom();

	var newUrl = `${window.location.pathname}?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;

	window.history.replaceState({}, '', newUrl);
}

function initializeUIElements() {
	var locateButton = document.getElementById('locateButton');
	if (locateButton) {
		locateButton.addEventListener('click', centerMapToLocation);
	}

	var backToAllButton = document.getElementById('backToAllButton');
	if (backToAllButton) {
		backToAllButton.addEventListener('click', function() {
			var params = getCurrentUrlParams();
			window.location.href = '/' + params;
		});
	}
}

function centerMapToLocation() {
	if (navigator.geolocation) {
		navigator.geolocation.getCurrentPosition(
			function(position) {
				var userLat = position.coords.latitude;
				var userLon = position.coords.longitude;

				map.setView([userLat, userLon], 15);

				L.marker([userLat, userLon]).addTo(map)
					.bindPopup(translate("your_location")).openPopup();
			},
			function(error) {
				switch(error.code) {
					case error.PERMISSION_DENIED:
						alert(translate("location_permission_denied"));
						break;
					case error.POSITION_UNAVAILABLE:
						alert(translate("location_unavailable"));
						break;
					case error.TIMEOUT:
						alert(translate("location_timeout"));
						break;
					default:
						alert(translate("location_error"));
						break;
				}
			}
		);
	} else {
		alert(translate("geolocation_not_supported"));
	}
}
		</script>

		<!-- –°–∫—Ä–∏–ø—Ç –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ -->
		<script>
			function uploadFiles() {
				const fileInput  = document.getElementById('fileInput');
				const files      = fileInput.files;
				if (!files.length) {
					alert(translate('select_files'));
					return;
				}

				const fileOverlay          = document.getElementById('fileOverlay');
				const fileProgressContainer = document.getElementById('fileProgressContainer');
				fileProgressContainer.innerHTML = '';
				fileOverlay.style.display  = 'flex';

				/* —Å—á—ë—Ç—á–∏–∫ –∏ —Å—Å—ã–ª–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç—Ä–µ–∫–∞ */
				let completedUploads = 0;
				const totalFiles     = files.length;
				let lastTrackURL     = null;

				/* —Å–æ–∑–¥–∞—ë–º XHR –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞, –Ω–æ redirect –¥–µ–ª–∞–µ–º –û–î–ò–ù —Ä–∞–∑ */
				[...files].forEach(file => {
					/* --- –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (–∫–∞–∫ –±—ã–ª–æ) --- */
					const fileBlock        = document.createElement('div');
					fileBlock.className    = 'file-progress';
					const fileName         = document.createElement('div');
					fileName.className     = 'file-name';
					fileName.innerText     = file.name;
					const progressBar      = document.createElement('div');
					progressBar.className  = 'progress-bar';
					const progressBarInner = document.createElement('div');
					progressBarInner.className = 'progress-bar-inner';
					progressBar.appendChild(progressBarInner);
					const serverProcessing = document.createElement('div');
					serverProcessing.className = 'server-processing';
					serverProcessing.innerText = translate('waiting_for_server');
					fileBlock.append(fileName, progressBar, serverProcessing);
					fileProgressContainer.appendChild(fileBlock);
					/* ------------------------------------------------- */

					const xhr = new XMLHttpRequest();
					xhr.open('POST', '/upload', true);

					/* –ø—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–ª–∏–≤–∫–∏ —Ñ–∞–π–ª–∞ */
					xhr.upload.onprogress = e => {
						if (e.lengthComputable) {
							const percent = (e.loaded / e.total) * 100;
							progressBarInner.style.width = percent + '%';
						}
					};

					/* –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞ */
					xhr.onload = () => {
						if (xhr.status === 200) {
							const response = JSON.parse(xhr.responseText);
							if (response.status === 'success') {
								lastTrackURL             = response.trackURL;   // –∑–∞–ø–æ–º–∏–Ω–∞–µ–º
								serverProcessing.innerText = translate('processing_complete');
								serverProcessing.style.color = 'green';
							} else {
								serverProcessing.innerText = translate('error_processing_files');
								serverProcessing.style.color = 'red';
							}
						} else {
							serverProcessing.innerText = translate('error_during_upload');
							serverProcessing.style.color = 'red';
						}

						/* —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –∏, –µ—Å–ª–∏ –≤—Å—ë –≥–æ—Ç–æ–≤–æ, –ø–µ—Ä–µ—Ö–æ–¥–∏–º */
						completedUploads++;
						if (completedUploads === totalFiles) {
							setTimeout(() => {
								fileOverlay.style.display = 'none';
								/* –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–º–µ–Ω–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π —Ç—Ä–µ–∫ */
								if (lastTrackURL) {
									window.location.href = lastTrackURL;
								} else {
									location.reload();   // –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –≤—Å–µ –∑–∞–≥—Ä—É–∑–∫–∏ —É–ø–∞–ª–∏
								}
							}, 700);
						}
					};

					/* –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª */
					const formData = new FormData();
					formData.append('files[]', file);
					xhr.send(formData);
				});
			}
		</script>

	</body>
</html>

