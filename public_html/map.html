<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set metadata and link CSS -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{translate "title"}}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/static/leaflet.css">
    <link rel="stylesheet" href="/static/nouislider.min.css">


    <style>
/* General styles */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden; /* Hide scrollbars */
  background: var(--modal-bg); /* Apply theme background color */
  color: var(--modal-text); /* Ensure text inherits theme color */
}

        /* Color variables adapt to system theme */
        :root {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 1px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          color-scheme: light; /* Default to light scheme */
        }

        @media (prefers-color-scheme: dark) {
          :root {
            --overlay-bg: rgba(0, 0, 0, 0.7);
            --progress-bg: #2b2b2b;
            --progress-color: #f4f4f4;
            --progress-bar-bg: #555555;
            --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            --upload-btn-bg: #4caf50; /* Standard site green for consistency */
            --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
            --control-bg: rgba(51, 51, 51, 0.25);
            --control-bg-hover: rgba(51, 51, 51, 0.35);
            --legend-border: 0px solid #555;
            --modal-bg: #2b2b2b;
            --modal-text: #eee;
            --modal-border: 1px solid #444;
            --link-color: #90caf9;
            color-scheme: dark; /* Match system dark scheme */
          }
        }

        /* Manual theme overrides */
        :root[data-theme='light'] {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 1px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          color-scheme: light; /* Force light scheme when manually selected */
        }

        :root[data-theme='dark'] {
          --overlay-bg: rgba(0, 0, 0, 0.7);
          --progress-bg: #2b2b2b;
          --progress-color: #f4f4f4;
          --progress-bar-bg: #555555;
          --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(51, 51, 51, 0.25);
          --control-bg-hover: rgba(51, 51, 51, 0.35);
          --legend-border: 0px solid #555;
          --modal-bg: #2b2b2b;
          --modal-text: #eee;
          --modal-border: 1px solid #444;
          --link-color: #90caf9;
          color-scheme: dark; /* Force dark scheme when manually selected */
        }

        /* Theme toggle switch */
        #themeToggle {
          position: absolute;
          bottom: 140px;
          right: 20px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          padding: 4px 6px;
          z-index: 1000;
          font-family: inherit;
          display: flex;
          align-items: center;
          color: var(--modal-text);
        }

        .theme-switch {
          position: relative;
          display: inline-block;
          width: 30px;
          height: 16px;
          margin: 0 4px;
        }

        .theme-switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .theme-slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: 0.2s;
          border-radius: 16px;
        }

        .theme-slider:before {
          position: absolute;
          content: "";
          height: 12px;
          width: 12px;
          left: 2px;
          bottom: 2px;
          background-color: #fff;
          transition: 0.2s;
          border-radius: 50%;
        }

        .theme-switch input:checked + .theme-slider {
          background-color: #2196F3;
        }

        .theme-switch input:checked + .theme-slider:before {
          transform: translateX(14px);
        }

        /* Map container */
        #map {
          height: 100vh; /* Map takes full viewport height */
          margin: 0;
          overflow: hidden;
        }

        /* Custom tooltip styles */
        .custom-tooltip {
          /* Match tooltip with current theme */
          background-color: var(--modal-bg);
          border-radius: 5px;
          padding: 10px;
          color: var(--modal-text);
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
        }

        /* Link inside popups pointing to full legend */
        .risk-link {
          color: var(--link-color);
          text-decoration: underline;
        }

        /* Larger color squares for legend items */
        .legend-square {
          display: inline-block;
          width: 12px;
          height: 12px;
          margin-right: 6px;
          border: var(--legend-border);
          border-radius: 2px;
        }

        /* Container for upload button */
        .upload-btn-container {
          position: absolute;
          top: 20px;
          right: 20px;
          z-index: 1000;
        }

        /* Upload button styling, theme-aware */
        .upload-btn {
          background-color: var(--upload-btn-bg); /* Use site green for familiarity */
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 14px;
          color: #ffffff; /* White text stays readable across themes */
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        /* File upload overlay */
        #fileOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: var(--overlay-bg);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        /* Upload progress container */
        #fileProgressContainer {
          background-color: var(--progress-bg);
          color: var(--progress-color);
          padding: 20px;
          border-radius: 10px;
          max-width: 600px;
          width: 100%;
          box-shadow: var(--progress-shadow);
          max-height: 80vh;
          overflow-y: auto; /* Allow scrolling for many uploads */
        }

        /* Individual file upload progress */
        .file-progress {
          margin-bottom: 15px;
        }

        .file-name {
          font-weight: bold;
          margin-bottom: 5px;
        }

        /* Progress bar */
        .progress-bar {
          width: 100%;
          height: 10px;
          background-color: var(--progress-bar-bg);
          border-radius: 5px;
          overflow: hidden;
        }

        .progress-bar-inner {
          height: 100%;
          background-color: #4caf50;
          width: 0%;
        }

        /* Server processing indicator */
        .server-processing {
          margin-left: 10px;
          font-size: 14px;
          color: #ff9800;
        }

        /* Upload button hover effect */
        .upload-btn:hover {
          background-color: var(--upload-btn-bg-hover); /* Darker shade on hover */
        }

        /* Container for geolocation button */
        .locate-btn-container {
          position: absolute;
          top: 60px;
          right: 20px;
          z-index: 1000;
        }

        /* Geolocation button styling, theme-aware */
        .locate-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 16px;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Geolocation button hover effect */
        .locate-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* GitHub link styling */
        .github-link {
          position: absolute;
          bottom: 20px;
          left: 20px;
          z-index: 1000;
        }

        .github-icon {
          width: 40px;
          height: 40px;
          opacity: 0.6;
        }

        .github-icon:hover {
          opacity: 1;
        }

        /* Program info uses theme text and link colors */
        .program-info {
          position: absolute;
          bottom: 20px;
          left: 70px;
          z-index: 1000;
          color: var(--modal-text);
          font-size: 14px;
          opacity: 0.6;
        }

        .program-info a {
          color: var(--link-color);
          text-decoration: none;
        }

        .program-info a:hover {
          text-decoration: underline;
        }

        .program-info:hover {
          opacity: 1;
        }

        /* "Back to all tracks" button container.
           Positioned below the QR button to prevent overlap. */
        .back-to-all-container {
          position: absolute;
          top: 185px; /* place under geolocation+QR stack */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .back-to-all-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 14px;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        .back-to-all-btn:hover {
          background-color: var(--control-bg-hover);
        }


        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì‚Äì Slider clean-look patch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .date-slider-box {
          padding: 6px;
          width: 50px;
        }

        /* 0) Basic slider container geometry: buffer = 8px
           (half handle size) so handles never exceed the rail */
        #dateSlider{
          width:6px;                 /* rail thickness */
          height:130px;              /* actual track length */
          padding:0px 0;             /* inner top/bottom padding */
          box-sizing:content-box;    /* ensures padding works */
          margin:16px auto 26px;
        }

        /* 1) grey slider rail */
        #dateSlider .noUi-base{
          background:#bfbfbf;
          width:100%;                /* 6px width */
          height:100%;               /* 130px minus padding */
        }

        /* 2) colored section only between handles */
        #dateSlider .noUi-connect{
          background:#1e88e5;        /* pick your brand color */
        }

        /* Slider handles respect theme colors */
        .noUi-vertical .noUi-handle{
          width:32px;
          height:20px;
          left:-18px;              /* center on 6px rail */
          border-radius:3px;
          background: var(--control-bg);      /* follow theme */
          border: var(--legend-border);   /* match theme border */
          box-shadow:0 1px 3px rgba(0,0,0,.25);
          cursor:grab;
        }
        /* 4) remove pseudo-element tails */
        .noUi-handle:before,
        .noUi-handle:after{ display:none; }

        .slider-label{
          margin:2px 0;
          font-size:11px;
          line-height:1.15em;
          white-space:nowrap;
          text-align:center; 
        }

        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Year / Month toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .slider-toggle{
          display:flex; gap:2px; margin:2px 0 4px;
          font-size:11px; line-height:1; user-select:none;
        }
        /* Year/Month toggle buttons adapt to theme */
        .slider-toggle button{
          flex:1 1 0; padding:2px 4px;
          border: var(--legend-border); background: var(--control-bg);
          border-radius:3px; cursor:pointer;
          color: var(--modal-text);
        }
        .slider-toggle button.active{
          background:#1e88e5; color:#fff; border-color:#1e88e5;
        }

        /* ‚îÄ‚îÄ‚îÄ Year mode: slider height matches month slider ‚îÄ‚îÄ‚îÄ */
        #yearSlider{
          /* copied parameters from #dateSlider */
          width:6px;                 /* rail thickness */
          height:130px;              /* track length */
          padding:0;                 /* inner padding */
          margin:16px auto 26px;     /* same margins */
          box-sizing:content-box;
        }
        /* grey rail and blue connect bar */
        #yearSlider .noUi-base      {background:#bfbfbf;width:100%;height:100%;}
        #yearSlider .noUi-connect   {background:#bfbfbf;}


        /* Reset button styled with theme variables */
        .slider-reset-btn{
          display:block;
          width:100%;
          margin-top:4px;
          padding:2px 4px;
          font-size:11px;
          border: var(--legend-border);
          background: var(--control-bg);
          border-radius:3px;
          cursor:pointer;
          color: var(--modal-text);
        }
        .slider-reset-btn:hover{ background: var(--control-bg-hover); }

        .loading-overlay{
          position:absolute;
          top:50%;left:50%;
          transform:translate(-50%,-50%);
          z-index:3000;
          pointer-events:none;
        }
        .spinner{
          width:40px;height:40px;
          border:4px solid rgba(0,0,0,.15);
          border-top:4px solid #1e88e5;
          border-radius:50%;
          animation:spin 1s linear infinite;
        }
        @keyframes spin{ to{ transform:rotate(360deg); } }


        /* Compact QR button follows theme */
        .qr-btn {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          width: 42px; height: 42px;
          padding: 4px;
          display: flex; align-items: center; justify-content: center;
          cursor: pointer;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .qr-btn:hover { background: var(--control-bg-hover); }
        .qr-btn svg { width: 22px; height: 22px; display: block; }

        /* Leaflet controls use theme variables so colors follow the current theme */
        .leaflet-control-layers,
        .leaflet-control-layers-toggle,
        .leaflet-control-layers-list,
        .leaflet-control-layers-expanded,
        .leaflet-bar a {
          background-color: var(--control-bg);
          border: var(--legend-border);
          color: var(--modal-text);
        }

        .leaflet-control-layers-toggle:hover,
        .leaflet-bar a:hover {
          background-color: var(--control-bg-hover);
        }

        /* Ensure layer labels match theme text color */
        .leaflet-control-layers label { color: var(--modal-text); }

        /* ===== Leaflet layer control ===== */
        /* Remove border and shadow around map type selector to blend into map */
        .leaflet-control-layers,
        .leaflet-control-layers-expanded,
        .leaflet-control-layers-list {
          box-shadow: none;
        }

        /* Removed old collapsible legend styles (legend-control, legend-header, legend-title, legend-toggle, legend-body, legend-row, legend-swatch, legend-label)
           to avoid duplicate legends. Only the compact legend + modal remain. */

        /* Live marker icon now combines the heart logo with the dose value. */
        .live-marker {
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 2px;
          text-align: center;
          font-weight: 600;
          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
          color: #000;
          overflow: hidden;
        }

        .live-marker-heart {
          display: block;
          width: 60%;
          height: auto;
          pointer-events: none;
        }

        .live-marker-value {
          line-height: 1;
          font-size: 0.55em;
          letter-spacing: -0.02em;
        }

        .live-tooltip {
          max-width: 260px;
        }

        /* Allow long sensor descriptions to wrap inside Leaflet overlays. */
        .leaflet-tooltip.custom-tooltip {
          white-space: normal;
          max-width: 260px;
          overflow-wrap: anywhere;
        }

        .live-tooltip-header {
          display: flex;
          gap: 10px;
          align-items: center;
          margin-bottom: 6px;
        }

        .live-tooltip-heart {
          width: 28px;
          height: 28px;
        }

        .live-tooltip-title {
          font-weight: 700;
          margin: 0;
        }

        .live-tooltip-desc {
          margin: 0;
          font-size: 12px;
          line-height: 1.4;
        }

        .live-extra-list {
          margin: 4px 0 0 0;
          padding-left: 18px;
        }

        .live-extra-list li {
          margin: 2px 0;
        }

        /* Keep the icons in the speed filter aligned regardless of emoji vs. SVG source. */
        .speed-filter-icon {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 1.5em;
          height: 1.5em;
          margin-left: 6px;
          font-size: 1.2em;
          line-height: 1;
        }

        /* Ensure the SVG heart scales with the surrounding emoji-based icons. */
        .speed-filter-icon img {
          display: block;
          width: 100%;
          height: 100%;
        }

        #liveModal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.6);
          z-index: 2100;
          justify-content: center;
          align-items: center;
        }

        .live-modal-content {
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--modal-border);
          width: min(720px, 92%);
          max-height: 85vh;
          overflow-y: auto;
          padding: 20px;
          border-radius: 12px;
          box-shadow: 0 0 12px rgba(0, 0, 0, 0.45);
          font-family: inherit;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-modal-header {
          display: flex;
          align-items: center;
          gap: 14px;
        }

        .live-modal-heart {
          width: 40px;
          height: 40px;
        }

        .live-modal-title {
          margin: 0;
          font-size: 20px;
        }

        .live-modal-description {
          margin: 4px 0 0 0;
          line-height: 1.6;
        }

        .live-modal-meta {
          display: grid;
          gap: 6px;
          font-size: 14px;
        }

        .live-chart-stack {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-chart-block {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 10px;
          padding: 12px;
        }

        .live-chart-title {
          margin: 0 0 8px 0;
          display: flex;
          flex-wrap: wrap;
          gap: 4px 12px;
          align-items: baseline;
        }

        .live-chart-label {
          font-size: 14px;
          font-weight: 600;
          flex: 1 1 auto;
        }

        .live-chart-unit {
          font-size: 12px;
          color: var(--modal-text);
          opacity: 0.8;
        }

        .live-chart-window {
          font-size: 11px;
          color: var(--modal-text);
          opacity: 0.7;
        }

        .live-chart-canvas {
          display: block;
          width: 100%;
          height: 180px;
          border-radius: 6px;
          background: rgba(0,0,0,0.05);
        }

        .live-chart-empty {
          margin: 0;
          font-size: 12px;
          color: var(--modal-text);
        }

        .live-modal-close {
          align-self: flex-end;
          padding: 6px 14px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 6px;
          cursor: pointer;
          font-family: inherit;
          color: var(--modal-text);
        }

    </style>

    <!-- Translation script -->
    <script id="translations-script">
      // Translation object passed from Go
      var translations = JSON.parse('{{ .Translations | toJSON }}');
        var currentLang = '{{ .Lang }}'; // Current language

        // Get translation by key
        function translate(key) {
            if (!translations['en']) {
                console.error('English translations not available!');
                return key;
            }

            if (translations[currentLang] && translations[currentLang][key]) {
                return translations[currentLang][key];
            } else if (translations['en'][key]) {
                return translations['en'][key];
            }
            return key;
        }
    </script>
    <script>
      const defaultCfg = {
        lat:  {{printf "%.6f" .DefaultLat}},
        lon:  {{printf "%.6f" .DefaultLon}},
        zoom: {{.DefaultZoom}},
        layer: {{ .DefaultLayer | toJSON }}
      };
    </script>
    <script>
      // Expose the realtime flag so the UI can hide controls when the backend keeps the feature off.
      window.safecastRealtimeEnabled = {{if .RealtimeAvailable}}true{{else}}false{{end}};
    </script>

  </head>

  <body>

    <!-- Container for upload button -->
    <div class="upload-btn-container leaflet-control">
      <!--
        title/aria-label ‚Üí short hint on hover/focus about formats
        and what happens after upload.
      -->
      <label
        for="fileInput"
        class="upload-btn"
        title="{{translate "upload_button_tooltip"}}"
        aria-label="{{translate "upload_button_tooltip"}}">
        {{translate "upload_button"}}
      </label>

      <input
        type="file"
        id="fileInput"
        style="display: none;"
        multiple
        accept=""
        onchange="uploadFiles()">
    </div>

    <!-- Container for geolocation button -->
    <div class="locate-btn-container leaflet-control">
      <button id="locateButton" class="locate-btn" title="{{translate "locate_button_tooltip"}}">
        <img src="/static/images/marker-icon-2x.png" alt="Locate" style="width:20px;">
      </button>
      <br>
      <!-- Small QR button under geolocate -->
      <button id="qrButton" class="qr-btn" title="{{translate "qr_button_tooltip"}}" aria-label="QR code">
        <svg viewBox="0 0 100 100" role="img" aria-hidden="true">
          <rect x="0" y="0" width="100" height="100" fill="#fff"/>
          <rect x="8" y="8" width="28" height="28" fill="#000"/>
          <rect x="12" y="12" width="20" height="20" fill="#fff"/>
          <rect x="16" y="16" width="12" height="12" fill="#000"/>
          <rect x="64" y="8" width="28" height="28" fill="#000"/>
          <rect x="68" y="12" width="20" height="20" fill="#fff"/>
          <rect x="72" y="16" width="12" height="12" fill="#000"/>
          <rect x="8" y="64" width="28" height="28" fill="#000"/>
          <rect x="12" y="68" width="20" height="20" fill="#fff"/>
          <rect x="16" y="72" width="12" height="12" fill="#000"/>
          <rect x="48" y="12" width="8" height="8" fill="#000"/>
          <rect x="40" y="28" width="8" height="8" fill="#000"/>
          <rect x="56" y="28" width="8" height="8" fill="#000"/>
          <rect x="44" y="44" width="8" height="8" fill="#000"/>
          <rect x="60" y="44" width="8" height="8" fill="#000"/>
          <rect x="44" y="60" width="8" height="8" fill="#000"/>
          <rect x="60" y="60" width="8" height="8" fill="#000"/>
          <rect x="76" y="60" width="8" height="8" fill="#000"/>
          <rect x="28" y="44" width="8" height="8" fill="#000"/>
        </svg>
      </button>
    </div>

    <!-- Container for "Back to all tracks" button -->
    <div class="back-to-all-container leaflet-control" style="display: none;">
      <button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
    </div>

    <!-- File upload overlay -->
    <div id="fileOverlay" style="display: none;">
      <div id="fileProgressContainer">
        <!-- Upload progress entries inserted here dynamically -->
      </div>
    </div>

    <!-- GitHub link and program info -->
    <a href="https://github.com/matveynator/chicha-isotope-map" class="github-link" target="_blank">
      <img src="/static/images/GitHub-Mark.png" alt="GitHub" class="github-icon">
    </a>

    <div class="program-info">
      <a href="https://github.com/matveynator/chicha-isotope-map/releases/tag/latest" target="_blank"><strong>{{translate "description"}}</strong> (version: {{ .Version }})</a>
    </div>

    <!-- Map container -->
    <div id="map"></div>

    <div id="loadingOverlay" class="loading-overlay" style="display:none;">
      <div class="spinner"></div>
    </div>

    <!-- Theme toggle -->
    <div id="themeToggle">
      <span style="font-size:14px;">‚òÄÔ∏è</span>
      <label class="theme-switch">
        <input type="checkbox" id="themeSwitch">
        <span class="theme-slider"></span>
      </label>
      <span style="font-size:14px;">üåô</span>
    </div>

<!-- Compact Legend (clickable) -->
<div id="legend" style="
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: var(--control-bg);
  border: var(--legend-border);
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
  padding: 10px 10px 10px 0;
  font-size: 12px;
  line-height: 1.4em;
  cursor: pointer;
  z-index: 1000;
  font-family: inherit;
  display: flex;
  overflow: hidden;">
    <div style="width:16px; margin-left:6px; margin-right:6px; border-radius:4px 4px 4px 4px; overflow:hidden; background:linear-gradient(to top,#008000,#FFD700,#FF8C00,#FF4500,#000); position:relative;">
    <span style="position:absolute; bottom:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size:8px;">{{translate "legend_safe"}}</span>
    <span style="position:absolute; top:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size:8px;">{{translate "legend_danger"}}</span>
  </div>
  <div>
    <strong>{{translate "legend_title"}}</strong><br>
    <div><span style="color:#000000;">‚ñ†</span> >100 ¬µR/h</div>
    <div><span style="color:#FF4500;">‚ñ†</span> 30‚Äì100 ¬µR/h</div>
  <div><span style="color:#FFD700;">‚ñ†</span> 11‚Äì30 ¬µR/h</div>
   <div><span style="color:#008000;">‚ñ†</span> 0‚Äì11 ¬µR/h</div>
  </div>
</div>
<div id="legendTooltip" class="custom-tooltip" style="display:none; position:fixed; max-width:400px; padding:10px; font-size:8px; line-height:1.4em; z-index:1001;"></div>
<!--
  Compact 4-bin legend (¬µR/h) with vertical gradient bar (green‚Üíyellow‚Üíorange‚Üíred‚Üíblack).
  White labels mark safe at the bottom and danger at the top.
  Clicking the legend opens a modal with full, human-friendly guidance.
-->
<!-- Legend Modal -->
<div id="legendModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size:14px;
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: inherit;">
    <h3 style="margin-top:0;">{{translate "legend_title"}}</h3>
    <!-- We inject the localized full text below -->
    <div id="legendText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('legendModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>
<!--
  Modal that displays the full, localized legend text.
  `white-space:pre-wrap` preserves paragraphs and bullets from translations.json.
  Box scrolls when content is long.
-->

<!-- Generic Info Modal for legal notes, data sources, and license -->
<div id="infoModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size:14px;
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: inherit;">
    <h3 id="infoTitle" style="margin-top:0;"></h3>
    <div id="infoText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('infoModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Modal with Grafana-style stacked charts for Safecast realtime sensors -->
<div id="liveModal">
  <div class="live-modal-content">
    <div class="live-modal-header">
      <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime sensor" class="live-modal-heart">
      <div>
        <h3 id="liveModalTitle" class="live-modal-title"></h3>
        <p id="liveModalDescription" class="live-modal-description"></p>
      </div>
    </div>
    <div id="liveModalMeta" class="live-modal-meta"></div>
    <div id="liveModalExtra" class="live-modal-meta"></div>
    <div class="live-chart-stack">
      <div class="live-chart-block" data-range="day">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleDay"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="day"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="day"></canvas>
        <p class="live-chart-empty" data-range="day"></p>
      </div>
      <div class="live-chart-block" data-range="month">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleMonth"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="month"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="month"></canvas>
        <p class="live-chart-empty" data-range="month"></p>
      </div>
      <div class="live-chart-block" data-range="all">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleAll"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="all"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="all"></canvas>
        <p class="live-chart-empty" data-range="all"></p>
      </div>
    </div>
    <button type="button" class="live-modal-close" id="liveModalClose"></button>
  </div>
</div>

    <!-- Load Leaflet JavaScript library -->
    <script src="/static/leaflet.js"></script>

    <!-- Slider -->
    <script src="/static/nouislider.min.js"></script>
    <script src="/static/wNumb.min.js"></script>



    <!-- Helper functions -->
    <script>
      // Compute marker color from radiation level
      function getGradientColor(doseRate) {
        if (doseRate <= 0.04) return "#006400"; // Dark green
        else if (doseRate <= 0.08) return interpolateColor([0, 100, 0], [173, 255, 47], (doseRate - 0.04) / (0.08 - 0.04));
        else if (doseRate <= 0.11) return interpolateColor([173, 255, 47], [255, 255, 0], (doseRate - 0.08) / (0.11 - 0.08));
        else if (doseRate <= 0.20) return interpolateColor([255, 255, 0], [255, 165, 0], (doseRate - 0.11) / (0.20 - 0.11));
        else if (doseRate <= 0.30) return interpolateColor([255, 165, 0], [255, 0, 0], (doseRate - 0.20) / (0.30 - 0.20));
        else if (doseRate <= 0.99) return interpolateColor([255, 0, 0], [0, 0, 0], (doseRate - 0.30) / (0.99 - 0.30));
        else return "#000000"; // Black for very high values
      }

// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
  if (factor < 0) factor = 0;
  if (factor > 1) factor = 1;

  const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
  const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
  const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

// Calculate marker radius based on zoom level
function getRadius(doseRate, zoomLevel) {
  // previous formula: Math.pow(2, (zoomLevel-10)/2)
  const k = 1;                               // scale by ~2
  let r   = Math.pow(2, (zoomLevel - 10)/2.5) * k;
  return Math.max(r, 2);                       // prevent tiny circles
}

// Thresholds for realtime freshness expressed in seconds so both the
// rendering loop and periodic refresh share the same rules.
const LIVE_ACTIVE_WINDOW = 5 * 60;         // 5 minutes keeps "working" sensors bright
const LIVE_RECENT_WINDOW = 24 * 60 * 60;   // 24 hours before removal

// parseColor extracts RGB components from either hex (#rrggbb) or rgb(r,g,b)
// strings.  Keeping this helper local avoids pulling external libraries while
// letting us reuse the logic for alpha blending and contrast checks.
function parseColor(color) {
  if (!color) return null;
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
      };
    }
    if (hex.length === 3) {
      return {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16),
      };
    }
  }
  if (color.startsWith('rgb')) {
    const parts = color.match(/\d+/g);
    if (parts && parts.length >= 3) {
      return {
        r: parseInt(parts[0], 10),
        g: parseInt(parts[1], 10),
        b: parseInt(parts[2], 10),
      };
    }
  }
  return null;
}

// colorWithAlpha returns an rgba() string using the provided alpha.  We reuse
// parseColor so realtime markers can reuse the same gradient palette while
// dimming stale sensors without affecting the text opacity.
function colorWithAlpha(color, alpha) {
  const rgb = parseColor(color);
  if (!rgb) return color;
  const a = Math.min(Math.max(alpha, 0), 1);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
}

// isDarkColor estimates perceived brightness to choose a contrasting text
// color.  A simple luminance formula keeps the implementation lightweight.
function isDarkColor(color) {
  const rgb = parseColor(color);
  if (!rgb) return false;
  const luminance = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
  return luminance < 140;
}

// formatMicroRoentgen converts ¬µSv/h into ¬µR/h text while avoiding excessive
// decimals.  Smaller values keep two decimals; larger ones are rounded to the
// nearest whole number for quick scanning on the map.
function formatMicroRoentgen(doseRate) {
  const micro = doseRate * 100;
  if (micro >= 100) return micro.toFixed(0);
  if (micro >= 10) return micro.toFixed(1);
  if (micro >= 1) return micro.toFixed(2);
  return micro.toFixed(3);
}

// formatMicroRoentgenValue keeps axis labels tidy when the charts already work
// with ¬µR/h values.  Sharing the logic here avoids sprinkling the rounding
// heuristics through the drawing code.
function formatMicroRoentgenValue(value) {
  const abs = Math.abs(value);
  if (abs >= 100) return value.toFixed(0);
  if (abs >= 10) return value.toFixed(1);
  if (abs >= 1) return value.toFixed(2);
  return value.toFixed(3);
}

// escapeHtml protects popups against user-supplied strings like device names.
function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value).replace(/[&<>"']/g, function(ch) {
    switch (ch) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return ch;
    }
  });
}

const regionNameCache = {};

function formatDateTime(ts) {
  if (!ts) return '‚Äî';
  const date = new Date(ts * 1000);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  return date.toLocaleString(lang, { hour12: false });
}

function approximateLocalTime(lat, lon) {
  if (typeof lon !== 'number' || !isFinite(lon)) return null;
  const offsetHours = Math.round(lon / 15);
  const offsetMs = offsetHours * 60 * 60 * 1000;
  const remote = new Date(Date.now() + offsetMs);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const label = offsetHours === 0 ? 'UTC' : (offsetHours > 0 ? `UTC+${offsetHours}` : `UTC${offsetHours}`);
  return { text: remote.toLocaleString(lang, { hour12: false }), zone: label };
}

function transportLabel(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_transport_car');
  if (key.includes('bike')) return translate('live_marker_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_transport_air');
  return translate('live_marker_transport_unknown');
}

function transportSentence(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_desc_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_desc_transport_car');
  if (key.includes('bike')) return translate('live_marker_desc_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_desc_transport_air');
  return translate('live_marker_desc_transport_unknown');
}

function localizeCountry(code) {
  if (!code) return '';
  const normalized = String(code).toUpperCase();
  if (normalized === '??') return normalized;
  const langRaw = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  let locale = langRaw === 'ua' ? 'uk' : langRaw;
  locale = locale.replace('_', '-');
  try {
    if (!regionNameCache[locale]) {
      regionNameCache[locale] = new Intl.DisplayNames([locale], { type: 'region' });
    }
    const label = regionNameCache[locale].of(normalized);
    if (label) return label;
  } catch (err) {
    // Older browsers may not support Intl.DisplayNames; fall back to the code below.
  }
  return normalized;
}

function describeLiveSensor(marker) {
  // We use bracket placeholders (e.g. [[name]]) so the Go template parser leaves
  // them untouched while still allowing readable replacement in the browser.
  const subject = marker.deviceName
    ? translate('live_marker_desc_named').replace('[[name]]', escapeHtml(marker.deviceName))
    : translate('live_marker_desc_generic');
  const placeName = marker.country ? localizeCountry(marker.country) : '';
  const place = placeName
    ? translate('live_marker_desc_location').replace('[[place]]', escapeHtml(placeName))
    : translate('live_marker_desc_location_unknown');
  const transport = transportSentence(marker.transport);
  const sensorName = marker.tube || marker.deviceName || '';
  const tube = sensorName
    ? translate('live_marker_desc_tube').replace('[[tube]]', escapeHtml(sensorName))
    : translate('live_marker_desc_no_tube');
  return [subject, place, transport, tube].join(' ');
}

function labelForExtraKey(key) {
  switch (key) {
    case 'temperature_c':
      return translate('live_marker_temperature');
    case 'temperature_f':
      return translate('live_marker_temperature_f');
    case 'humidity_percent':
      return translate('live_marker_humidity');
    default:
      return key.replace(/_/g, ' ').replace(/\b\w/g, function(m){ return m.toUpperCase(); });
  }
}

function formatExtraValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return null;
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1) + (key.endsWith('_f') ? ' ¬∞F' : ' ¬∞C');
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0) + ' %';
  }
  return value.toFixed(2);
}

const EXTRA_SERIES_ORDER = ['temperature_c', 'temperature_f', 'humidity_percent'];

function extraUnitSuffix(key) {
  if (key === 'temperature_c') return '¬∞C';
  if (key === 'temperature_f') return '¬∞F';
  if (key === 'humidity_percent') return '%';
  return '';
}

function formatExtraAxisValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return '';
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1);
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0);
  }
  return value.toFixed(2);
}

function colorForExtraKey(key) {
  if (key === 'temperature_c' || key === 'temperature_f') return '#ff7043';
  if (key === 'humidity_percent') return '#26a69a';
  return '#ab47bc';
}

function sortExtraKeys(keys) {
  return keys.sort(function(a, b) {
    const ai = EXTRA_SERIES_ORDER.indexOf(a);
    const bi = EXTRA_SERIES_ORDER.indexOf(b);
    const av = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
    const bv = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
    if (av === bv) return a.localeCompare(b);
    return av - bv;
  });
}

function hasExtraSeries(series) {
  if (!series || typeof series !== 'object') return false;
  return Object.keys(series).some(function(key){
    return Array.isArray(series[key]) && series[key].length;
  });
}

function renderLiveExtras(extra) {
  if (!extra || typeof extra !== 'object') return '';
  const items = [];
  Object.keys(extra).sort().forEach(function(key){
    const label = labelForExtraKey(key);
    const val = formatExtraValue(key, extra[key]);
    if (!label || !val) return;
    items.push('<li>' + label + ': ' + val + '</li>');
  });
  if (!items.length) return '';
  return '<div><strong>' + translate('live_marker_extra_intro') + ':</strong><ul class="live-extra-list">' + items.join('') + '</ul></div>';
}

function buildDeviceMeta(marker) {
  const rows = [];
  if (marker.deviceName) {
    rows.push('<div><strong>' + translate('live_marker_device_label') + ':</strong> ' + escapeHtml(marker.deviceName) + '</div>');
  }
  if (marker.deviceID) {
    rows.push('<div><strong>' + translate('live_marker_device_id') + ':</strong> ' + escapeHtml(marker.deviceID) + '</div>');
  }
  if (marker.transport) {
    rows.push('<div><strong>' + translate('live_marker_transport') + ':</strong> ' + transportLabel(marker.transport) + '</div>');
  }
  if (marker.tube) {
    rows.push('<div><strong>' + translate('live_marker_detector') + ':</strong> ' + escapeHtml(marker.tube) + '</div>');
  }
  if (marker.country) {
    const localized = localizeCountry(marker.country);
    const display = localized || marker.country;
    rows.push('<div><strong>' + translate('live_marker_country') + ':</strong> ' + escapeHtml(display) + '</div>');
  }
  return rows.join('');
}

// buildRealtimeIcon returns the HTML markup and sizing data for a realtime
// marker.  It handles the three freshness buckets: active (white ring, opaque),
// recent (grey ring, half opacity), and stale (>24h, hidden).
function buildRealtimeIcon(marker, zoomLevel, nowSec) {
  const lastSeen = marker.date || 0;
  if (!lastSeen) return null;

  const ageSec = nowSec - lastSeen;
  if (ageSec > LIVE_RECENT_WINDOW) {
    return null; // drop sensors that have been silent longer than a day
  }

  const active = ageSec <= LIVE_ACTIVE_WINDOW;
  const baseColor = getGradientColor(marker.doseRate);
  const fill = active ? baseColor : colorWithAlpha(baseColor, 0.5);
  const border = active ? '#ffffff' : '#888888';
  const textColor = isDarkColor(active ? baseColor : fill) ? '#ffffff' : '#000000';

  const radius = getRadius(marker.doseRate, zoomLevel) * 3;
  const size = radius * 2;
  const value = formatMicroRoentgen(marker.doseRate);
  const fontSize = Math.max(Math.round(size * 0.32), 11);
  const heartSize = Math.max(Math.round(size * 0.5), 14);

  const html = `
    <div class="live-marker" style="background:${fill};border:2px solid ${border};color:${textColor};width:${size}px;height:${size}px;font-size:${fontSize}px;">
      <img class="live-marker-heart" src="/static/images/safecast-heart-logo.png" alt="Safecast" style="width:${heartSize}px;"/>
      <div class="live-marker-value">${value}</div>
    </div>`;

  return { html, size, radius };
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 * In single-track view there is no filtering ‚Äî show everything.
 */
function shouldDisplayBySpeed(speed) {
  /* Key line */
  if (isTrackView) return true;        // filter disabled in track view

  const st = loadSpeedFilterState();   // global mode
  if (speed < 0) {                     // Safecast heart markers use negative speed to signal realtime data
    if (!window.safecastRealtimeEnabled) {
      // Safety net: when realtime is disabled we never show synthetic negative speeds.
      return false;
    }
    return st.live;
  }
  if (speed >= 70 && speed <= 500) return st.plane;  // ‚úàÔ∏è
  if (speed >= 7  && speed <  70)  return st.car;    // üöó
  /* speed < 7 m/s  ‚Üí pedestrian */
  return st.ped;                                      // üö∂
}


// Compute marker fill opacity based on speed
function getFillOpacity(speed) {
  if (speed <= 5) {
    return 0.6;
  } else if (speed >= 20) {
    return 0.1;
  } else {
    var opacityRange = 0.6 - 0.1;
    var speedRange = 20 - 5;
    var opacityDecreasePerMs = opacityRange / speedRange;
    var speedAboveFive = speed - 5;
    var totalOpacityDecrease = speedAboveFive * opacityDecreasePerMs;
    var currentOpacity = 0.6 - totalOpacityDecrease;
    return currentOpacity;
  }
}

// Decide a translation key for safety based on dose rate (¬µSv/h).
// Using legend thresholds keeps UI consistent and avoids extra strings.
function doseCategory(doseRate) {
  // Map dose rate to safety words using legend thresholds
  if (doseRate <= 0.11) return 'legend_safe';
  if (doseRate <= 0.30) return 'legend_attention';
  return 'legend_danger';
}



// Get current URL params from map state
function getCurrentUrlParams() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  return `?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;
}
    </script>

    <!-- Map initialization and markers -->
    <script>
      var map;
var circleMarkers = {};
var isTrackView = false;
var osmLayer, googleSatellite;
var trackBounds;
var currentTrackID = null;

// New controller to cancel previous request
var markerStreamSource = null;

var liveHistoryCache = new Map();


/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return defaults that reflect backend capabilities.
 *   Realtime on:  Safecast heart on, ‚úàÔ∏è off, üöó on, üö∂ on  (as requested).
 *   Realtime off: ‚úàÔ∏è off, üöó on, üö∂ on  (heart absent).
 */
function loadSpeedFilterState() {
  // We derive defaults from the realtime flag so the UI matches backend capabilities.
  const base = { plane: false, car: true, ped: true };
  if (window.safecastRealtimeEnabled) {
    base.live = true;
  }
  try {
    const raw = sessionStorage.getItem('speedFilterState');
    const st = raw ? JSON.parse(raw) : {};
    const merged = Object.assign({}, base, st);
    if (!window.safecastRealtimeEnabled) {
      delete merged.live;
    }
    return merged;
  } catch (e) {
    return base;
  }
}

// ---------- helpers for time-range state ------------------------
function loadDateRangeState() {
  try { return JSON.parse(sessionStorage.getItem('dateRangeState')) || null; }
  catch(e){ return null; }
}
function saveDateRangeState(st) {
  sessionStorage.setItem('dateRangeState', JSON.stringify(st));
}

/**
 * Return a "Month YYYY" string in the browser locale.
 * Chrome/Firefox often display "Aug 2025",
 * Safari shows "Aug 2025", etc.
 */
function tsToNiceStr(ts){
  return new Date(ts * 1000)
    .toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}


// absolute month difference between two unix timestamps
function monthsApart(ts0, ts1){
  const d0 = new Date(ts0 * 1000);
  const d1 = new Date(ts1 * 1000);
  return Math.abs((d1.getFullYear() - d0.getFullYear()) * 12 +
    (d1.getMonth()     - d0.getMonth()));
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user‚Äôs choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
  // Persist only supported options so stale realtime toggles do not leak between sessions.
  const toSave = Object.assign({}, state);
  if (!window.safecastRealtimeEnabled) {
    delete toSave.live;
  }
  sessionStorage.setItem('speedFilterState', JSON.stringify(toSave));
}


document.addEventListener('DOMContentLoaded', function () {

  // Initialize trackID from path
  var match = window.location.pathname.match(/^\/trackid\/([a-zA-Z0-9]+)/);
  if (match) {
    currentTrackID = match[1];
    isTrackView = true;
    // NEW: show back button immediately
    var backBox = document.querySelector('.back-to-all-container');
    if (backBox) backBox.style.display = 'block';
  }
  // Initialize layers and auto theme switch
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const osmLight = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const osmDark  = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  window.osmLight = osmLight; // expose for theme toggle
  window.osmDark  = osmDark;  // expose for theme toggle
  // Google tiles always use satellite imagery for consistent look
  const googleSat   = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';

  osmLayer = L.tileLayer(media.matches ? osmDark : osmLight, {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap contributors'
  });

  // Use the same satellite layer regardless of theme
  googleSatellite = L.tileLayer(googleSat, {
    maxZoom: 20,
    attribution: '&copy; Google'
  });

  // right after creating osmLayer and googleSatellite
  const urlParams       = new URLSearchParams(window.location.search);
  const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
  const startLayer      = startLayerName === 'Google Satellite' ? googleSatellite : osmLayer;

  map = L.map('map', {
    center: [defaultCfg.lat, defaultCfg.lon],
    zoom  : defaultCfg.zoom,
    layers: [startLayer],           // only one base layer
  });

  // Layer control
  var baseLayers = {
    "OpenStreetMap": osmLayer,
    "Google Satellite": googleSatellite
  };

  L.control.layers(baseLayers, null, {
    position: 'topleft',
    collapsed: false
  }).addTo(map);

  // Add custom attribution links that open informative popups
  map.attributionControl.addAttribution(
    '<a href="#" class="attr-link" data-info="legal">' + translate('attr_legal') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="sources">' + translate('attr_sources') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="license">' + translate('attr_license') + '</a>'
  );

  // Track view initialization
  var initialMarkers = JSON.parse('{{ .Markers | toJSON }}');
  if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
    isTrackView = true;

    // Don't show initialMarkers immediately; load them in parts via get_markers
    map.on('load', debounceUpdateMarkers);

    // Adjust marker size on zoom
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
  } else {
    // Dynamic marker updates in global mode
    map.on('load', debounceUpdateMarkers);
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
    debounceUpdateMarkers;
  }

  // Load map state from URL
  loadMapFromUrl();

  // Update URL on map changes
  map.on('baselayerchange', updateUrl);
  map.on('moveend', updateUrl);
  map.on('zoomend', updateUrl);

  // Initialize UI elements
  initializeUIElements();

  // Periodically refresh realtime styling so markers fade without map motion.
  setInterval(adjustMarkerRadius, 60 * 1000);

  /**
   * Build a Leaflet control with three check-boxes that filter markers
   * by recorded speed. Labels now show speed in km/h instead of m/s.
   * Default state (when realtime exists): Safecast heart on, ‚úàÔ∏è off, üöó on, üö∂ on.
   */
  function createSpeedFilterControls() {

    if (isTrackView) return;   // hidden in track view

    // load previously saved state (or defaults)
    const state = loadSpeedFilterState();

    // custom Leaflet control
    const SpeedCtrl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-control-layers');
        div.style.padding = '6px 10px';

        // helper that returns one <label> line
        const row = (id, iconMarkup, checked) => `
            <label style="white-space:nowrap;display:block;cursor:pointer;">
            <input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
            <span class="speed-filter-icon">${iconMarkup}</span>
            </label>`;

        // Build rows dynamically so the realtime checkbox only appears when supported server-side.
        const pieces = [];
        if (window.safecastRealtimeEnabled) {
          // Use the Safecast heart artwork so the live toggle reflects the new branding.
          const liveIconMarkup = '<img src="/static/images/safecast-heart-logo.png" alt="Realtime measurements from safecast.org" style="width:1em; height:1em; vertical-align:middle;"/>';
          pieces.push(row('sfLive', liveIconMarkup, state.live));
          pieces.push('<div class="leaflet-control-layers-separator"></div>');
        }
        pieces.push(
          row('sfPlane', '‚úàÔ∏è', state.plane),
          row('sfCar',   'üöó', state.car),
          row('sfPed',   'üö∂', state.ped)
        );
        div.innerHTML = pieces.join('');

        // prevent map drag/zoom while clicking inside the control
        L.DomEvent.disableClickPropagation(div);

        // attach change-handlers
        div.querySelectorAll('input[type=checkbox]').forEach(cb => {
          cb.addEventListener('change', () => {
            if (window.safecastRealtimeEnabled) {
              state.live = div.querySelector('#sfLive').checked;
            } else {
              delete state.live;
            }
            state.plane = div.querySelector('#sfPlane').checked;
            state.car   = div.querySelector('#sfCar').checked;
            state.ped   = div.querySelector('#sfPed').checked;
            saveSpeedFilterState(state);   // remember choice
            debounceUpdateMarkers();       // redraw with new filter
          });
        });

        return div;
      }
    });

    new SpeedCtrl({ position: 'topleft' }).addTo(map);
  }



  // Call it
  createSpeedFilterControls();   
  createDateRangeSlider();



});


/**
 * Date-range control with two modes:
 *  - YEAR (single handle): labels show full [minYear..maxYear] when NO user filter is active,
 *    otherwise they show the chosen year.
 *  - MONTH (double handle): classic [from..to] range.
 *
 * Key ideas:
 *  ‚Ä¢ We expose window.__setDateSliderVisibility(show)
 *  ‚Ä¢ We expose window.__initSliderOnce(minTs,maxTs) for first build
 *  ‚Ä¢ We expose window.__syncDateSliders(minTs,maxTs) to keep ranges/labels
 *    in sync with the current map viewport on every pan/zoom IF no custom
 *    time filter is set by the user.
 *
 * No globals except 3 window.* hooks; no vendor APIs beyond noUiSlider.
 */
function createDateRangeSlider(){

  if (isTrackView) return;   // no date control in single-track mode

  let sliderBox, yearSlider, monthSlider;
  let mode  = 'year';                // 'year' | 'month'
  let initY = false, initM = false;  // lazy init flags

  // We store the "full range" of current viewport to detect
  // whether a saved filter is actually "show all".
  let fullRange = null; // [minTs,maxTs]

  const DateCtrl = L.Control.extend({
    onAdd(){
      sliderBox = L.DomUtil.create('div','leaflet-control-layers date-slider-box');
      sliderBox.style.display = 'none'; // hidden until needed
      sliderBox.innerHTML = `
        <div class="slider-toggle">
          <button id="btnYear"  class="active">Y</button>
          <button id="btnMonth">M</button>
        </div>
        <div id="lblMax" class="slider-label"></div>
        <div id="yearSlider"></div>
        <div id="dateSlider"></div>
        <div id="lblMin" class="slider-label"></div>
        <button id="btnReset" class="slider-reset-btn" title="Reset"> ‚ü≤ </button>
      `;
      return sliderBox;
    }
  });
  new DateCtrl({ position:'topleft' }).addTo(map);

  const btnY = sliderBox.querySelector('#btnYear');
  const btnM = sliderBox.querySelector('#btnMonth');
  const btnReset = sliderBox.querySelector('#btnReset');
  const lblMin = () => sliderBox.querySelector('#lblMin');
  const lblMax = () => sliderBox.querySelector('#lblMax');

  btnY.onclick = () => switchMode('year');
  btnM.onclick = () => switchMode('month');

  // Show/hide the whole control (called from updateMarkers())
  window.__setDateSliderVisibility = (show)=>{
    sliderBox.style.display = show ? 'block' : 'none';
    if(!show) sessionStorage.removeItem('dateRangeState');
  };

  // One-time creation of both sliders using initial bounds
  window.__initSliderOnce = (minTs,maxTs)=>{
    if (initY && initM) return;
    fullRange = [minTs,maxTs]; // remember initial "full range"

    // YEAR slider (single handle)
    if(!initY){
      yearSlider = sliderBox.querySelector('#yearSlider');
      const minYear = new Date(minTs*1000).getUTCFullYear();
      const maxYear = new Date(maxTs*1000).getUTCFullYear();

      noUiSlider.create(yearSlider,{
        start      : minYear,                // the handle can sit anywhere; labels decide what to show
        connect    : [true,false],
        orientation: 'vertical',
        direction  : 'rtl',
        step       : 1,
        range      : { min:minYear, max:maxYear },
        format     : wNumb({ decimals:0 })
      });

      // Update labels:
      //  - If NO user filter or filter equals fullRange ‚Üí show full year bounds.
      //  - Else ‚Üí show the chosen year.
      yearSlider.noUiSlider.on('update', ([y])=>{
        if (mode !== 'year') return;
        const saved = loadDateRangeState();
        const fr = fullRange || [minTs,maxTs];
        const isFull = !saved || (saved[0] === fr[0] && saved[1] === fr[1]);
        if (isFull){
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = r.min;
          lblMax().textContent = r.max;
        } else {
          lblMin().textContent = y;
          lblMax().textContent = y;
        }
      });
      yearSlider.noUiSlider.on('change', updateDateFilter);
      initY = true;
    }

    // MONTH slider (double handle)
    if(!initM){
      monthSlider = sliderBox.querySelector('#dateSlider');
      noUiSlider.create(monthSlider,{
        start       : [minTs,maxTs],
        connect     : true,
        orientation : 'vertical',
        direction   : 'rtl',
        step        : 3600, // 1 hour
        range       : { min:minTs, max:maxTs },
        format      : wNumb({ decimals:0 })
      });
      monthSlider.noUiSlider.on('update', ()=>{
        if (mode !== 'month') return;
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      });
      monthSlider.noUiSlider.on('change', updateDateFilter);
      monthSlider.style.display = 'none';
      initM = true;
    }

    // Initial labels = full bounds
    if (mode === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      lblMin().textContent = r.min;
      lblMax().textContent = r.max;
    } else {
      lblMin().textContent = tsToNiceStr(minTs);
      lblMax().textContent = tsToNiceStr(maxTs);
    }
  };

  // Sync ranges and labels to the *current* viewport on every pan/zoom,
  // but ONLY when user has not applied a custom time filter.
  window.__syncDateSliders = (minTs,maxTs)=>{
    if (!initY || !initM) return; // not built yet

    // Detect whether user has a custom time filter (not full range).
    const saved = loadDateRangeState();
    const prevFull = fullRange;
    fullRange = [minTs,maxTs]; // update "full" range to the new viewport

    const hasCustom =
      !!saved && !(saved[0] === prevFull?.[0] && saved[1] === prevFull?.[1]) &&
      !(saved[0] === fullRange[0] && saved[1] === fullRange[1]);

    // Update YEAR slider bounds
    const minYear = new Date(minTs*1000).getUTCFullYear();
    const maxYear = new Date(maxTs*1000).getUTCFullYear();
    yearSlider.noUiSlider.updateOptions({
      range: { min:minYear, max:maxYear }
    }, false);

    // Update MONTH slider bounds
    monthSlider.noUiSlider.updateOptions({
      range: { min:minTs, max:maxTs }
    }, false);

    // If no custom filter ‚Üí force labels to show full bounds and make month slider span all
    if (!hasCustom){
      if (mode === 'year'){
        const r = yearSlider.noUiSlider.options.range;
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        monthSlider.noUiSlider.set([minTs,maxTs]);
        lblMin().textContent = tsToNiceStr(minTs);
        lblMax().textContent = tsToNiceStr(maxTs);
      }
      // persist that "no filter" means full range
      saveDateRangeState([minTs,maxTs]);
    }
  };

  // Reset button ‚Üí drop custom filter and show full bounds of the *current* viewport
  btnReset.onclick = ()=>{
    sessionStorage.removeItem('dateRangeState');
    if (initY && initM){
      const rY = yearSlider.noUiSlider.options.range;
      const rM = monthSlider.noUiSlider.options.range;
      yearSlider.noUiSlider.set(rY.min);      // handle position is cosmetic
      monthSlider.noUiSlider.set([rM.min, rM.max]);

      lblMin().textContent = (mode==='year') ? rY.min : tsToNiceStr(rM.min);
      lblMax().textContent = (mode==='year') ? rY.max : tsToNiceStr(rM.max);

      // remember "no filter" == full range of the viewport
      saveDateRangeState([rM.min, rM.max]);
      debounceUpdateMarkers();
    }
  };

  function switchMode(next){
    if (mode === next) return;

    mode = next;
    btnY.classList.toggle('active', next==='year');
    btnM.classList.toggle('active', next==='month');
    yearSlider.style.display  = next==='year'  ? 'block' : 'none';
    monthSlider.style.display = next==='month' ? 'block' : 'none';

    // Refresh labels on mode switch respecting full/custom state
    const saved = loadDateRangeState();
    const fr = fullRange;
    const isFull = !saved || (fr && saved[0]===fr[0] && saved[1]===fr[1]);

    if (next === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      if (isFull){
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        const y = +yearSlider.noUiSlider.get();
        lblMin().textContent = y;
        lblMax().textContent = y;
      }
    } else {
      const r = monthSlider.noUiSlider.options.range;
      if (isFull){
        monthSlider.noUiSlider.set([r.min, r.max]);
        lblMin().textContent = tsToNiceStr(r.min);
        lblMax().textContent = tsToNiceStr(r.max);
      } else {
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      }
    }

    // Do not change filter on mode flip; user intent remains the same
  }

  function updateDateFilter(){
    // YEAR mode ‚Üí make a full [year..year] month span
    if (mode==='year'){
      const y = +yearSlider.noUiSlider.get();
      const from = Date.UTC(y,0,1)/1000;
      const to   = Date.UTC(y+1,0,1)/1000 - 1;
      saveDateRangeState([from,to]);
    } else {
      saveDateRangeState(monthSlider.noUiSlider.get().map(Number));
    }
    debounceUpdateMarkers();
  }
}



// Function definitions

// ---------- Marker popups and tooltips ----------
// Build HTML once so popups and tooltips share identical content.
  function buildLiveMarkerPopup(marker) {
    const doseRate = marker.doseRate || 0;
    const doseLine = `${(doseRate * 100).toFixed(2)} ¬µR/h (${doseRate.toFixed(3)} ¬µSv/h)`;
    const lastSeen = formatDateTime(marker.date);
    const local = approximateLocalTime(marker.lat, marker.lon);
    const localBlock = local ? `<div><strong>${translate('live_marker_local_time')}:</strong> ${escapeHtml(local.text)} (${escapeHtml(local.zone)})</div>` : '';
    const metaHtml = buildDeviceMeta(marker);
    const metaBlock = metaHtml ? `<div>${metaHtml}</div>` : '';
    const extrasBlock = renderLiveExtras(marker.liveExtra);
    const deviceID = marker.deviceID || (marker.trackID ? marker.trackID.replace(/^live:/, '') : '');
    const attrs = [];
    if (deviceID) attrs.push(`data-device="${escapeHtml(deviceID)}"`);
    if (marker.deviceName) attrs.push(`data-name="${escapeHtml(marker.deviceName)}"`);
    if (marker.transport) attrs.push(`data-transport="${escapeHtml(marker.transport)}"`);
    if (marker.tube) attrs.push(`data-tube="${escapeHtml(marker.tube)}"`);
    if (marker.country) attrs.push(`data-country="${escapeHtml(marker.country)}"`);
    if (typeof marker.lat === 'number') attrs.push(`data-lat="${marker.lat}"`);
    if (typeof marker.lon === 'number') attrs.push(`data-lon="${marker.lon}"`);
    const chartLink = deviceID ? `<div style="margin-top:6px;"><a href="#" class="live-chart-link" ${attrs.join(' ')}>${translate('live_marker_chart_link')}</a></div>` : '';

    return `
      <div class="custom-tooltip live-tooltip">
        <div class="live-tooltip-header">
          <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime" class="live-tooltip-heart">
          <div>
            <div class="live-tooltip-title">${translate('live_marker_title')}</div>
            <p class="live-tooltip-desc">${describeLiveSensor(marker)}</p>
          </div>
        </div>
        <div><strong>${translate('radiation_dose')}:</strong><br>
          ${doseLine}
          (<a href="#" class="risk-link">${translate(doseCategory(doseRate))}</a>)
        </div>
        <div><strong>${translate('live_marker_last_seen')}:</strong> ${escapeHtml(lastSeen)}</div>
        ${localBlock}
        ${metaBlock}
        ${extrasBlock}
        ${chartLink}
      </div>`;
  }

  function buildMarkerContent(marker) {
    if (marker.speed < 0) {
      return buildLiveMarkerPopup(marker);
    }

    const speedText = (typeof marker.speed === 'number' && isFinite(marker.speed))
      ? `${(marker.speed * 3.6).toFixed(1)} km/h`
      : '‚Äî';

    return `
      <div class="custom-tooltip">
        <div><strong>${translate('radiation_dose')}:</strong><br>
          ${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)
          (<a href="#" class="risk-link">
            ${translate(doseCategory(marker.doseRate))}
          </a>)
        </div>
        <div><strong>${translate('speed')}:</strong> ${speedText}</div>
        <div style="margin-top:4px">
          <!-- clicking the link switches to track mode -->
          <a href="#" class="track-link" data-track="${marker.trackID}" style="font-weight:bold;">
            ${translate('track_id')}: ${marker.trackID}
          </a>
        </div>
      </div>`;
  }

// Popup reuses shared builder to stay in sync with tooltips.
function getPopupContent(marker) {
  return buildMarkerContent(marker);
}

// Tooltip uses the same builder for hover previews.
function getTooltipContent(marker) {
  return buildMarkerContent(marker);
}


/* Request markers for current bounds/zoom, render them,
 * and keep the date sliders in sync with the viewport.
 */
function updateMarkers(){
  const loadingEl = document.getElementById('loadingOverlay');
  if (loadingEl) loadingEl.style.display='block';

  if (markerStreamSource) markerStreamSource.close();

  const zoom   = map.getZoom();
  const bounds = map.getBounds();

  const params = {
    zoom  : zoom,
    minLat: bounds.getSouthWest().lat,
    minLon: bounds.getSouthWest().lng,
    maxLat: bounds.getNorthEast().lat,
    maxLon: bounds.getNorthEast().lng
  };
  if (currentTrackID) params.trackID = currentTrackID; // focus on a single track when set

  const savedRange = loadDateRangeState();

  for (const key in circleMarkers) map.removeLayer(circleMarkers[key]);
  circleMarkers = {};

  const tracks = new Set();
  let minTs = Infinity, maxTs = -Infinity;

  const es = new EventSource('/stream_markers?' + new URLSearchParams(params));
  markerStreamSource = es;

  es.onmessage = e => {
    let m; try { m = JSON.parse(e.data); } catch { return; }
    const isLive = m.speed < 0; // negative speed denotes realtime marker
    if (!isLive && m.trackID) tracks.add(m.trackID);
    minTs = Math.min(minTs, m.date);
    maxTs = Math.max(maxTs, m.date);
    if (savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) return;
    if (!shouldDisplayBySpeed(m.speed)) return;

    let marker;
    if (isLive) { // realtime marker with value inside the circle
      const nowSec = Date.now() / 1000;
      const icon = buildRealtimeIcon(m, zoom, nowSec);
      if (!icon) return; // device is older than 24 hours
      marker = L.marker([m.lat, m.lon], {
        icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
      })
      .addTo(map)
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    } else {
      marker = L.circleMarker([m.lat, m.lon], {
        radius      : getRadius(m.doseRate, zoom),
        fillColor   : getGradientColor(m.doseRate),
        color       : getGradientColor(m.doseRate),
        weight      : 1,
        opacity     : getFillOpacity(m.speed) + 0.1,
        fillOpacity : getFillOpacity(m.speed)
      })
      .addTo(map)
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    }

    // Store dose rate and timestamp on marker for later size updates
    marker.doseRate  = m.doseRate;
    marker.date      = m.date;
    marker.isRealtime = isLive;
    circleMarkers[m.id || m.trackID] = marker;
  };

  es.addEventListener('done', () => {
    const dateSpanMonths = (isFinite(minTs) && isFinite(maxTs))
                            ? monthsApart(minTs, maxTs) : 0;
    const needSlider = !isTrackView && tracks.size > 1 && dateSpanMonths > 1;
    if (window.__setDateSliderVisibility){
      window.__setDateSliderVisibility(needSlider);
    }
    if (needSlider && window.__initSliderOnce && isFinite(minTs) && isFinite(maxTs)){
      window.__initSliderOnce(minTs, maxTs);
      window.__initSliderOnce = null;
    }
    if (needSlider && window.__syncDateSliders && isFinite(minTs) && isFinite(maxTs)){
      window.__syncDateSliders(minTs, maxTs);
    }
    if (loadingEl) loadingEl.style.display='none';
    es.close();
  });

  es.onerror = () => {
    if (loadingEl) loadingEl.style.display='none';
    es.close();
  };
}

async function fetchLiveHistory(deviceID) {
  if (!deviceID) throw new Error('device');
  if (liveHistoryCache.has(deviceID)) {
    return liveHistoryCache.get(deviceID);
  }
  const resp = await fetch('/realtime_history?device=' + encodeURIComponent(deviceID));
  if (!resp.ok) {
    throw new Error('history');
  }
  const data = await resp.json();
  liveHistoryCache.set(deviceID, data);
  return data;
}

function chartColors() {
  const theme = document.documentElement.dataset.theme;
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const dark = theme === 'dark' || (!theme && prefersDark);
  if (dark) {
    return { grid: 'rgba(255,255,255,0.2)', line: '#90caf9', text: '#e0e0e0', background: 'rgba(255,255,255,0.08)' };
  }
  return { grid: 'rgba(0,0,0,0.2)', line: '#1e88e5', text: '#333333', background: 'rgba(0,0,0,0.05)' };
}

function radiationLineColor(valueMicroRoentgen) {
  return getGradientColor(valueMicroRoentgen / 100);
}

function niceNumber(range, round) {
  if (!isFinite(range) || range === 0) return 0;
  const exponent = Math.floor(Math.log10(Math.abs(range)));
  const fraction = range / Math.pow(10, exponent);
  let niceFraction;
  if (round) {
    if (fraction < 1.5) niceFraction = 1;
    else if (fraction < 3) niceFraction = 2;
    else if (fraction < 7) niceFraction = 5;
    else niceFraction = 10;
  } else {
    if (fraction <= 1) niceFraction = 1;
    else if (fraction <= 2) niceFraction = 2;
    else if (fraction <= 5) niceFraction = 5;
    else niceFraction = 10;
  }
  return niceFraction * Math.pow(10, exponent);
}

function niceTicks(min, max, count) {
  if (!isFinite(min) || !isFinite(max) || count <= 0) return [];
  if (min === max) return [min];
  const range = niceNumber(max - min, false);
  if (range === 0) return [];
  const spacing = niceNumber(range / (count - 1), true);
  if (!isFinite(spacing) || spacing === 0) return [];
  const niceMin = Math.floor(min / spacing) * spacing;
  const niceMax = Math.ceil(max / spacing) * spacing;
  const ticks = [];
  for (let v = niceMin; v <= niceMax + spacing / 2; v += spacing) {
    ticks.push(v);
  }
  return ticks;
}

const TIME_TICK_STEPS = [
  60,
  120,
  300,
  600,
  900,
  1800,
  3600,
  7200,
  14400,
  21600,
  43200,
  86400,
  172800,
  604800,
  1209600,
  2592000,
  7776000,
  15552000,
  31536000,
];

function selectTimeStep(spanSeconds, bucketSeconds) {
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return bucketSeconds || 60;
  }
  let minStep = spanSeconds / 6;
  if (bucketSeconds && bucketSeconds > minStep) {
    minStep = bucketSeconds;
  } else if (bucketSeconds) {
    minStep = Math.max(bucketSeconds, minStep / 2);
  }
  for (let i = 0; i < TIME_TICK_STEPS.length; i++) {
    if (TIME_TICK_STEPS[i] >= minStep) {
      return TIME_TICK_STEPS[i];
    }
  }
  return Math.max(bucketSeconds || TIME_TICK_STEPS[TIME_TICK_STEPS.length - 1], Math.round(minStep));
}

function buildTimeTicks(start, end, bucketSeconds) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  const span = end - start;
  const step = selectTimeStep(span, bucketSeconds);
  if (!isFinite(step) || step <= 0) return [];
  const ticks = [];
  const first = Math.ceil(start / step) * step;
  for (let ts = first; ts <= end; ts += step) {
    ticks.push(ts);
  }
  return ticks;
}

function formatTimeTickLabel(ts, spanSeconds, lang) {
  if (!isFinite(ts)) return '';
  const date = new Date(ts * 1000);
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 48 * 3600) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 90 * 86400) {
    return date.toLocaleString(lang, { month: 'short', day: 'numeric', hour: '2-digit' });
  }
  if (spanSeconds <= 400 * 86400) {
    return date.toLocaleDateString(lang, { month: 'short', day: 'numeric' });
  }
  if (spanSeconds <= 5 * 365 * 86400) {
    return date.toLocaleDateString(lang, { year: 'numeric', month: 'short' });
  }
  return date.toLocaleDateString(lang, { year: 'numeric' });
}

function formatAveragingWindow(seconds) {
  if (!seconds || !isFinite(seconds)) return '';
  const abs = Math.abs(seconds);
  const units = [
    { limit: 3600, key: 'duration_minutes', divisor: 60 },
    { limit: 48 * 3600, key: 'duration_hours', divisor: 3600 },
    { limit: 14 * 86400, key: 'duration_days', divisor: 86400 },
    { limit: 90 * 86400, key: 'duration_weeks', divisor: 604800 },
    { limit: Infinity, key: 'duration_months', divisor: 2592000 },
  ];
  let chosen = units[units.length - 1];
  for (let i = 0; i < units.length; i++) {
    if (abs < units[i].limit) {
      chosen = units[i];
      break;
    }
  }
  const template = translate(chosen.key);
  if (!template) return '';
  const count = Math.max(1, Math.round(abs / chosen.divisor));
  return template.replace('[[count]]', count);
}

function describeRangeLabel(range) {
  if (!range || typeof range.start !== 'number' || typeof range.end !== 'number') return '';
  if (range.end <= range.start) return '';
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const span = range.end - range.start;
  let startOpts;
  let endOpts;
  if (span <= 48 * 3600) {
    startOpts = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    endOpts = startOpts;
  } else if (span <= 120 * 86400) {
    startOpts = { month: 'short', day: 'numeric' };
    endOpts = { month: 'short', day: 'numeric' };
  } else if (span <= 720 * 86400) {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  } else {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  }
  const startText = new Date(range.start * 1000).toLocaleString(lang, startOpts);
  const endText = new Date(range.end * 1000).toLocaleString(lang, endOpts);
  if (!startText || !endText) return '';
  return startText + ' ‚Üí ' + endText;
}

function drawLiveChart(canvas, radiationPoints, extrasByKey, options) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (width === 0 || height === 0) return;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const colors = chartColors();
  canvas.style.background = colors.background;

  const extras = {};
  if (extrasByKey && typeof extrasByKey === 'object') {
    Object.keys(extrasByKey).forEach(function(key) {
      const series = extrasByKey[key];
      if (Array.isArray(series) && series.length) {
        extras[key] = series;
      }
    });
  }
  const extraKeys = sortExtraKeys(Object.keys(extras));
  const hasRadiation = Array.isArray(radiationPoints) && radiationPoints.length > 0;
  if (!hasRadiation && extraKeys.length === 0) {
    return;
  }

  const baseSeries = hasRadiation ? radiationPoints : extras[extraKeys[0]];
  if (!baseSeries || !baseSeries.length) {
    return;
  }

  const opts = options || {};
  let minX = baseSeries[0].timestamp;
  let maxX = baseSeries[baseSeries.length - 1].timestamp || (minX + 1);
  if (typeof opts.start === 'number' && typeof opts.end === 'number' && opts.end > opts.start) {
    minX = opts.start;
    maxX = opts.end;
  }
  if (!(maxX > minX)) {
    maxX = minX + 1;
  }
  const bucketSeconds = typeof opts.bucketSeconds === 'number' ? opts.bucketSeconds : 0;

  let minY;
  let maxY;
  if (hasRadiation) {
    minY = radiationPoints[0].value;
    maxY = radiationPoints[0].value;
    radiationPoints.forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  } else {
    const key = extraKeys[0];
    minY = extras[key][0].value;
    maxY = extras[key][0].value;
    extras[key].forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  }
  if (minY === maxY) {
    const delta = minY === 0 ? 0.5 : Math.abs(minY) * 0.2;
    minY -= delta;
    maxY += delta;
  }

  const extraRanges = {};
  extraKeys.forEach(function(key) {
    const series = extras[key];
    let minVal = series[0].value;
    let maxVal = series[0].value;
    series.forEach(function(point) {
      if (point.value < minVal) minVal = point.value;
      if (point.value > maxVal) maxVal = point.value;
    });
    if (minVal === maxVal) {
      const delta = minVal === 0 ? 0.5 : Math.abs(minVal) * 0.2;
      minVal -= delta;
      maxVal += delta;
    }
    extraRanges[key] = { min: minVal, max: maxVal };
  });

  const extraColumnWidth = 72;
  const rightPad = extraKeys.length ? extraColumnWidth * extraKeys.length + 20 : 20;
  const leftPad = hasRadiation ? 70 : 50;
  const topPad = 64;
  const bottomPad = 44;

  const plotLeft = leftPad;
  const plotRight = width - rightPad;
  const plotTop = topPad;
  const plotBottom = height - bottomPad;
  const plotW = Math.max(plotRight - plotLeft, 10);
  const plotH = Math.max(plotBottom - plotTop, 10);

  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const spanSeconds = maxX - minX;

  const rangeX = (maxX - minX) || 1;
  const rangeY = hasRadiation ? ((maxY - minY) || 1) : 1;

  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotLeft, plotTop);
  ctx.lineTo(plotLeft, plotBottom);
  ctx.lineTo(plotRight, plotBottom);
  if (extraKeys.length) {
    ctx.moveTo(plotRight, plotTop);
    ctx.lineTo(plotRight, plotBottom);
  }
  ctx.stroke();

  const ticksY = niceTicks(minY, maxY, 5);
  ctx.font = '11px sans-serif';
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ticksY.forEach(function(value) {
    if (!isFinite(value)) return;
    const y = plotBottom - ((value - minY) / rangeY) * plotH;
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.5);
    ctx.beginPath();
    ctx.moveTo(plotLeft, y);
    ctx.lineTo(plotRight, y);
    ctx.stroke();
    const label = formatMicroRoentgenValue(value);
    ctx.fillStyle = colors.text;
    ctx.fillText(label, plotLeft - 8, y);
  });

  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  const ticksX = buildTimeTicks(minX, maxX, bucketSeconds);
  ctx.strokeStyle = colorWithAlpha(colors.grid, 0.35);
  ticksX.forEach(function(ts) {
    if (!isFinite(ts)) return;
    const x = plotLeft + ((ts - minX) / rangeX) * plotW;
    ctx.beginPath();
    ctx.moveTo(x, plotTop);
    ctx.lineTo(x, plotBottom);
    ctx.stroke();
    const label = formatTimeTickLabel(ts, spanSeconds, lang);
    if (!label) return;
    ctx.fillStyle = colors.text;
    ctx.fillText(label, x, height - 10);
  });

  const showStart = !ticksX.some(function(ts) { return Math.abs(ts - minX) < Math.max(60, bucketSeconds || 0); });
  const showEnd = !ticksX.some(function(ts) { return Math.abs(ts - maxX) < Math.max(60, bucketSeconds || 0); });
  ctx.textAlign = 'left';
  ctx.fillStyle = colors.text;
  const startLabel = formatTimeTickLabel(minX, spanSeconds, lang);
  if (showStart && startLabel) {
    ctx.fillText(startLabel, plotLeft, height - 10);
  }
  ctx.textAlign = 'right';
  const endLabel = formatTimeTickLabel(maxX, spanSeconds, lang);
  if (showEnd && endLabel) {
    ctx.fillText(endLabel, plotRight, height - 10);
  }

  if (hasRadiation) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    for (let i = 1; i < radiationPoints.length; i++) {
      const prev = radiationPoints[i - 1];
      const curr = radiationPoints[i];
      const x1 = plotLeft + ((prev.timestamp - minX) / rangeX) * plotW;
      const y1 = plotBottom - ((prev.value - minY) / rangeY) * plotH;
      const x2 = plotLeft + ((curr.timestamp - minX) / rangeX) * plotW;
      const y2 = plotBottom - ((curr.value - minY) / rangeY) * plotH;
      // Applying a per-segment gradient keeps falling values flowing back to green
      // and rising values blending toward the warmer colors.
      const startColor = radiationLineColor(prev.value);
      const endColor = radiationLineColor(curr.value);
      const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
      gradient.addColorStop(0, startColor);
      gradient.addColorStop(1, endColor);
      ctx.strokeStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    if (radiationPoints.length === 1) {
      const lone = radiationPoints[0];
      const x = plotLeft + ((lone.timestamp - minX) / rangeX) * plotW;
      const y = plotBottom - ((lone.value - minY) / rangeY) * plotH;
      ctx.fillStyle = radiationLineColor(lone.value);
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  extraKeys.forEach(function(key, idx) {
    const series = extras[key];
    const range = extraRanges[key];
    const denom = (range.max - range.min) || 1;
    const color = colorForExtraKey(key);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    series.forEach(function(point, i) {
      const x = plotLeft + ((point.timestamp - minX) / rangeX) * plotW;
      const y = plotBottom - ((point.value - range.min) / denom) * plotH;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);

    const xBase = plotRight + 8 + idx * extraColumnWidth;
    const suffix = extraUnitSuffix(key);
    const maxLabel = formatExtraAxisValue(key, range.max);
    const minLabel = formatExtraAxisValue(key, range.min);
    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    if (maxLabel) {
      ctx.fillText(maxLabel + (suffix ? ' ' + suffix : ''), xBase, plotTop + 12);
    }
    if (minLabel) {
      ctx.fillText(minLabel + (suffix ? ' ' + suffix : ''), xBase, plotBottom - 4);
    }
  });

  ctx.font = '11px sans-serif';
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'left';
  const legendY = topPad - 20;
  let legendX = plotLeft;
  const legendEntries = [];
  if (hasRadiation) {
    // The legend reuses a gradient so the key matches the multi-hued line.
    const legendGradient = ctx.createLinearGradient(legendX, legendY, legendX + 18, legendY);
    legendGradient.addColorStop(0, radiationLineColor(minY));
    legendGradient.addColorStop(1, radiationLineColor(maxY));
    legendEntries.push({ label: translate('radiation_dose') + ' (¬µR/h)', color: legendGradient, solid: true });
  }
  extraKeys.forEach(function(key) {
    const suffix = extraUnitSuffix(key);
    const label = labelForExtraKey(key) + (suffix ? ' (' + suffix + ')' : '');
    legendEntries.push({ label: label, color: colorForExtraKey(key), solid: false });
  });
  legendEntries.forEach(function(entry) {
    ctx.strokeStyle = entry.color;
    ctx.lineWidth = entry.solid ? 3 : 1.5;
    ctx.setLineDash(entry.solid ? [] : [5, 3]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 18, legendY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = colors.text;
    ctx.fillText(entry.label, legendX + 24, legendY + 4);
    legendX += ctx.measureText(entry.label).width + 64;
  });
}

function updateChartHeading(element, key, ranges) {
  if (!element) return;
  const base = translate('live_chart_' + key);
  const range = ranges && ranges[key];
  const desc = describeRangeLabel(range);
  element.textContent = desc ? base + ' ¬∑ ' + desc : base;
}

function updateChartWindowLabel(rangeKey, ranges) {
  const el = document.querySelector(`.live-chart-window[data-range="${rangeKey}"]`);
  if (!el) return;
  const range = ranges && ranges[rangeKey];
  if (!range || !range.bucketSeconds) {
    el.textContent = '';
    return;
  }
  const windowText = formatAveragingWindow(range.bucketSeconds);
  if (!windowText) {
    el.textContent = '';
    return;
  }
  const template = translate('live_chart_averaged');
  el.textContent = template ? template.replace('[[window]]', windowText) : windowText;
}

function hideLiveModal() {
  const modal = document.getElementById('liveModal');
  if (modal) modal.style.display = 'none';
}

async function openLiveModal(deviceID, fallback) {
  const modal = document.getElementById('liveModal');
  if (!modal) return;
  modal.style.display = 'flex';

  const titleEl = document.getElementById('liveModalTitle');
  const descEl = document.getElementById('liveModalDescription');
  const metaEl = document.getElementById('liveModalMeta');
  const extraEl = document.getElementById('liveModalExtra');

  const dayTitle = document.getElementById('liveChartTitleDay');
  const monthTitle = document.getElementById('liveChartTitleMonth');
  const allTitle = document.getElementById('liveChartTitleAll');
  updateChartHeading(dayTitle, 'day');
  updateChartHeading(monthTitle, 'month');
  updateChartHeading(allTitle, 'all');

  const closeBtn = document.getElementById('liveModalClose');
  if (closeBtn) closeBtn.textContent = translate('live_chart_close');

  const fallbackMarker = {
    deviceID: fallback && fallback.device ? String(fallback.device) : (fallback && fallback.id ? String(fallback.id) : ''),
    deviceName: fallback && fallback.name ? fallback.name : '',
    transport: fallback && fallback.transport ? fallback.transport : '',
    country: fallback && fallback.country ? fallback.country : '',
    tube: fallback && fallback.tube ? fallback.tube : '',
  };

  if (titleEl) {
    titleEl.textContent = fallbackMarker.deviceName || translate('live_marker_title');
  }
  if (descEl) {
    descEl.textContent = describeLiveSensor(fallbackMarker);
  }
  if (metaEl) {
    metaEl.innerHTML = buildDeviceMeta(fallbackMarker);
  }
  if (extraEl) {
    extraEl.innerHTML = '';
  }

  ['day','month','all'].forEach(function(range){
    const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
    if (empty) { empty.textContent = ''; empty.style.display = 'none'; }
    const canvas = document.querySelector(`.live-chart-canvas[data-range="${range}"]`);
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    updateChartWindowLabel(range);
  });

  try {
    const data = await fetchLiveHistory(deviceID);
    const merged = {
      deviceID: data.deviceID || fallbackMarker.deviceID,
      deviceName: data.deviceName || fallbackMarker.deviceName,
      transport: data.transport || fallbackMarker.transport,
      tube: data.tube || fallbackMarker.tube,
      country: data.country || fallbackMarker.country,
      lat: fallback && fallback.lat ? parseFloat(fallback.lat) : undefined,
      lon: fallback && fallback.lon ? parseFloat(fallback.lon) : undefined,
      liveExtra: data.extra || null,
    };

    if (titleEl) {
      titleEl.textContent = merged.deviceName || translate('live_marker_title');
    }
    if (descEl) {
      descEl.textContent = describeLiveSensor(merged);
    }
    if (metaEl) {
      const metaParts = [];
      const metaBlock = buildDeviceMeta(merged);
      if (metaBlock) metaParts.push(metaBlock);
      const local = approximateLocalTime(merged.lat, merged.lon);
      if (local) {
        metaParts.push('<div><strong>' + translate('live_marker_local_time') + ':</strong> ' + escapeHtml(local.text) + ' (' + escapeHtml(local.zone) + ')</div>');
      }
      metaEl.innerHTML = metaParts.join('');
    }
    if (extraEl) {
      extraEl.innerHTML = renderLiveExtras(merged.liveExtra);
    }

    const ranges = (data && data.ranges && typeof data.ranges === 'object') ? data.ranges : {};
    // Range metadata keeps headings and averaging labels aligned with backend aggregation.

    updateChartHeading(dayTitle, 'day', ranges);
    updateChartHeading(monthTitle, 'month', ranges);
    updateChartHeading(allTitle, 'all', ranges);
    updateChartWindowLabel('day', ranges);
    updateChartWindowLabel('month', ranges);
    updateChartWindowLabel('all', ranges);

    ['day','month','all'].forEach(function(range){
      const canvas = document.querySelector(`.live-chart-canvas[data-range="${range}"]`);
      const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
      const series = data.series && data.series[range] ? data.series[range] : [];
      const extras = data.extraSeries && data.extraSeries[range] ? data.extraSeries[range] : null;
      const hasSeries = (series && series.length) || hasExtraSeries(extras);
      const rangeInfo = ranges && ranges[range] ? ranges[range] : null;
      const options = {};
      // Passing explicit bounds avoids axes jumping when resampled data omits raw endpoints.
      if (rangeInfo && typeof rangeInfo.start === 'number' && typeof rangeInfo.end === 'number') {
        options.start = rangeInfo.start;
        options.end = rangeInfo.end;
      }
      if (rangeInfo && typeof rangeInfo.bucketSeconds === 'number') {
        options.bucketSeconds = rangeInfo.bucketSeconds;
      }
      if (canvas && hasSeries) {
        if (empty) empty.style.display = 'none';
        drawLiveChart(canvas, series, extras, options);
      } else if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
    });
  } catch (err) {
    if (descEl) {
      descEl.textContent = translate('live_marker_history_error');
    }
    ['day','month','all'].forEach(function(range){
      const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
      if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
      updateChartWindowLabel(range);
    });
  }
}




let debounceTimeout;

function debounceUpdateMarkers() {
  clearTimeout(debounceTimeout);
  debounceTimeout = setTimeout(updateMarkers, 300);
}

function adjustMarkerRadius() {
  var zoomLevel = map.getZoom();
  const nowSec = Date.now() / 1000;
  for (let key in circleMarkers) {
    let marker = circleMarkers[key];
    if (marker.isRealtime) {
      // Recompute icon style so stale sensors fade without user interaction.
      const icon = buildRealtimeIcon(marker, zoomLevel, nowSec);
      if (!icon) {
        map.removeLayer(marker);
        delete circleMarkers[key];
        continue;
      }
      marker.setIcon(L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]}));
    } else if (typeof marker.setRadius === 'function') {
      // Circle markers scale by adjusting radius directly
      let newRadius = getRadius(marker.doseRate, zoomLevel);
      marker.setRadius(newRadius);
    }
  }
}

/* -----------------------------------------------------------------
 *  viewTrack() ‚Äî switch to single-track mode.
 *  Set currentTrackID = trackID before changing window.location.
 * -----------------------------------------------------------------*/
function viewTrack(trackID) {
  currentTrackID = trackID;   // new
  isTrackView    = true;

  const bounds = map.getBounds();
  const layer  = map.hasLayer(googleSatellite) ? 'Google Satellite'
    : 'OpenStreetMap';
  const zoom   = map.getZoom();

  const trackURL =
    `/trackid/${trackID}` +
    `?minLat=${bounds.getSouthWest().lat}` +
    `&minLon=${bounds.getSouthWest().lng}` +
    `&maxLat=${bounds.getNorthEast().lat}` +
    `&maxLon=${bounds.getNorthEast().lng}` +
    `&zoom=${zoom}` +
    `&layer=${encodeURIComponent(layer)}`;

  window.location.href = trackURL;
}


function setBaseLayer(layerName) {
  if (layerName === 'Google Satellite') {
    if (map.hasLayer(osmLayer))            map.removeLayer(osmLayer);
    if (!map.hasLayer(googleSatellite))    googleSatellite.addTo(map);
  } else {
    if (map.hasLayer(googleSatellite))     map.removeLayer(googleSatellite);
    if (!map.hasLayer(osmLayer))           osmLayer.addTo(map);
  }
}

function loadMapFromUrl() {
  const params = new URLSearchParams(window.location.search);

  /* base layer from URL or default */
  const layer = decodeURIComponent(params.get('layer') || defaultCfg.layer);
  setBaseLayer(layer);

  /* read remaining params */
  const minLat = parseFloat(params.get('minLat'));
  const minLon = parseFloat(params.get('minLon'));
  const maxLat = parseFloat(params.get('maxLat'));
  const maxLon = parseFloat(params.get('maxLon'));

  if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
    adjustMarkerRadius();
  } else if (isTrackView && trackBounds) {
    map.fitBounds(trackBounds);
  } else {
    map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
  }
}

function updateUrl() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  var newUrl = `${window.location.pathname}?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;

  window.history.replaceState({}, '', newUrl);
}

function openServerPoster() {
  if (typeof updateUrl === 'function') { try { updateUrl(); } catch(_){} }
  var full = window.location.href;
  var dst  = '/qrpng?u=' + encodeURIComponent(full);
  window.open(dst, '_blank', 'noopener,noreferrer');
}

function initializeUIElements() {
  var locateButton = document.getElementById('locateButton');
  if (locateButton) {
    locateButton.addEventListener('click', centerMapToLocation);
  }
  var qrButton = document.getElementById('qrButton');
  if (qrButton) {
    qrButton.addEventListener('click', openServerPoster);
  }
  var backToAllButton = document.getElementById('backToAllButton');
  if (backToAllButton) {
    backToAllButton.addEventListener('click', function () {
      var params = (typeof getCurrentUrlParams === 'function') ? getCurrentUrlParams() : '';
      window.location.href = '/' + params;
    });
  }
}

function centerMapToLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function(position) {
        var userLat = position.coords.latitude;
        var userLon = position.coords.longitude;

        map.setView([userLat, userLon], 15);

        L.marker([userLat, userLon]).addTo(map)
          .bindPopup(translate("your_location")).openPopup();
      },
      function(error) {
        switch(error.code) {
          case error.PERMISSION_DENIED:
            alert(translate("location_permission_denied"));
            break;
          case error.POSITION_UNAVAILABLE:
            alert(translate("location_unavailable"));
            break;
          case error.TIMEOUT:
            alert(translate("location_timeout"));
            break;
          default:
            alert(translate("location_error"));
            break;
        }
      }
    );
  } else {
    alert(translate("geolocation_not_supported"));
  }
}
    </script>

    <!-- File upload script -->
    <script>
      function uploadFiles() {
        const fileInput  = document.getElementById('fileInput');
        const files      = fileInput.files;
        if (!files.length) {
          alert(translate('select_files'));
          return;
        }

        const fileOverlay          = document.getElementById('fileOverlay');
        const fileProgressContainer = document.getElementById('fileProgressContainer');
        fileProgressContainer.innerHTML = '';
        fileOverlay.style.display  = 'flex';

        /* counter and URL of last track */
        let completedUploads = 0;
        const totalFiles     = files.length;
        let lastTrackURL     = null;

        /* Create an XHR for each file but redirect only once */
        [...files].forEach(file => {
          /* --- visual progress elements --- */
          const fileBlock        = document.createElement('div');
          fileBlock.className    = 'file-progress';
          const fileName         = document.createElement('div');
          fileName.className     = 'file-name';
          fileName.innerText     = file.name;
          const progressBar      = document.createElement('div');
          progressBar.className  = 'progress-bar';
          const progressBarInner = document.createElement('div');
          progressBarInner.className = 'progress-bar-inner';
          progressBar.appendChild(progressBarInner);
          const serverProcessing = document.createElement('div');
          serverProcessing.className = 'server-processing';
          serverProcessing.innerText = translate('waiting_for_server');
          fileBlock.append(fileName, progressBar, serverProcessing);
          fileProgressContainer.appendChild(fileBlock);
          /* ------------------------------------------------- */

          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload', true);

          /* file upload progress */
          xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
              const percent = (e.loaded / e.total) * 100;
              progressBarInner.style.width = percent + '%';
            }
          };

          /* handle server response */
          xhr.onload = () => {
            if (xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              if (response.status === 'success') {
                lastTrackURL             = response.trackURL;   // remember
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
              } else {
                serverProcessing.innerText = translate('error_processing_files');
                serverProcessing.style.color = 'red';
              }
            } else {
              serverProcessing.innerText = translate('error_during_upload');
              serverProcessing.style.color = 'red';
            }

            /* increment counter and redirect when done */
              completedUploads++;
            if (completedUploads === totalFiles) {
              setTimeout(() => {
                fileOverlay.style.display = 'none';
                /* redirect to last successfully processed track */
                  if (lastTrackURL) {
                    window.location.href = lastTrackURL;
                  } else {
                    location.reload();   // if all uploads failed
                  }
              }, 700);
            }
          };

          /* send file */
            const formData = new FormData();
          formData.append('files[]', file);
          xhr.send(formData);
        });
      }
    </script>


    <!-- Theme toggle script -->
    <script>
      // Synchronize UI theme with map tiles and remember the choice for the session.
      document.addEventListener('DOMContentLoaded', function () {
        var sw = document.getElementById('themeSwitch');
        if (!sw) return;
        var media = window.matchMedia('(prefers-color-scheme: dark)');

        function applyTheme(theme) {
          document.documentElement.dataset.theme = theme; // switch CSS variables
          if (window.osmLayer) {
            window.osmLayer.setUrl(theme === 'dark' ? window.osmDark : window.osmLight);
          }
          sw.checked = theme === 'dark';
        }

        var storedTheme = sessionStorage.getItem('themePreference');
        var initialTheme = storedTheme ? storedTheme : (media.matches ? 'dark' : 'light');
        applyTheme(initialTheme); // set initial state

        sw.addEventListener('change', function () {
          var newTheme = this.checked ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });

        media.addEventListener('change', function (e) {
          var newTheme = e.matches ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });
      });
    </script>


<!--
  When the legend is clicked:
    ‚Ä¢ Fetch language-specific full text.
    ‚Ä¢ Split into paragraphs and decorate range lines with color squares.
    ‚Ä¢ Show modal; close on backdrop click for convenience.
-->
<script>
  // Build legend HTML with color squares for tooltip and modal.
  function buildLegendHTML(lang) {
    var key = 'legend_full_' + lang;
    var txt = translate(key);
    var parts = txt.split('\n\n');
    function stripBullet(line) {
      return line.replace(/^‚ñ†\s*/, '');
    }
    function square(color) {
      return '<span class="legend-square" style="background:' + color + ';"></span>';
    }
    return parts.map(function(p){
      var lines = p.split('\n').map(function(line){
        if (line.includes('0‚Äì11')) return square('#008000') + stripBullet(line);
        if (line.includes('11‚Äì30')) return square('#FFD700') + stripBullet(line);
        if (line.includes('30‚Äì100')) return square('#FF4500') + stripBullet(line);
        if (line.includes('>100')) return square('#000000') + stripBullet(line);
        return line;
      }).join('<br>');
      return '<p style="margin:0 0 1em 0;">' + lines + '</p>';
    }).join('');
  }

  // Display the full legend text in current language.
  // Exposed so marker popups reuse the same modal.
  function openLegendModal() {
    hideLegendTooltip(); // avoid overlap
    var lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
    var html = buildLegendHTML(lang);
    var box = document.getElementById('legendText');
    if (box) box.innerHTML = html;
    var modal = document.getElementById('legendModal');
    if (modal) modal.style.display = 'flex';
  }

  // Show legend explanation on hover using same HTML as modal
  function showLegendTooltip() {
    var lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
    var tip = document.getElementById('legendTooltip');
    if (!tip) return;
    tip.innerHTML = buildLegendHTML(lang);
    tip.style.display = 'block';
    var leg = document.getElementById('legend');
    if (leg) {
      var rect = leg.getBoundingClientRect();
      tip.style.left = rect.left + 'px';
      tip.style.top = (rect.top - tip.offsetHeight - 8) + 'px';
    }
  }

  // Hide the hover tooltip
  function hideLegendTooltip() {
    var tip = document.getElementById('legendTooltip');
    if (tip) tip.style.display = 'none';
  }

  // Build HTML for info modal from translation text
  function buildInfoHTML(txt) {
    return txt.split('\n\n').map(function(p){
      return '<p style="margin:0 0 1em 0;">' + p.split('\n').join('<br>') + '</p>';
    }).join('');
  }

  // Open modal with legal, source or license text
  function openInfoModal(topic) {
    hideLegendTooltip(); // avoid overlap with legend tooltip
    var box = document.getElementById('infoText');
    if (box) box.innerHTML = buildInfoHTML(translate(topic + '_full'));
    var head = document.getElementById('infoTitle');
    if (head) head.textContent = translate(topic + '_title');
    var modal = document.getElementById('infoModal');
    if (modal) modal.style.display = 'flex';
  }

  // Use event delegation because popups are created dynamically.
  document.addEventListener('click', function(ev) {
    // open legend modal when risk link clicked
    if (ev.target.classList.contains('risk-link')) {
      ev.preventDefault();
      openLegendModal();
    }
    if (ev.target.classList.contains('live-chart-link')) {
      ev.preventDefault();
      const dataset = ev.target.dataset;
      if (!dataset.device) return;
      const fallback = {
        device: dataset.device,
        name: dataset.name || '',
        transport: dataset.transport || '',
        tube: dataset.tube || '',
        country: dataset.country || '',
        lat: dataset.lat || '',
        lon: dataset.lon || '',
      };
      openLiveModal(dataset.device, fallback);
    }
    // switch to track view when track link clicked
    if (ev.target.classList.contains('track-link')) {
      ev.preventDefault();
      viewTrack(ev.target.dataset.track);
    }
    // open info modal for attribution links
    if (ev.target.classList.contains('attr-link')) {
      ev.preventDefault();
      openInfoModal(ev.target.dataset.info);
    }
  });

  (function(){
    var el = document.getElementById('legend');
    if (el) {
      el.addEventListener('click', openLegendModal);
      el.addEventListener('mouseenter', showLegendTooltip);
      el.addEventListener('mouseleave', hideLegendTooltip);
    }
    // Close on backdrop click (UX nicety)
    var modal = document.getElementById('legendModal');
    if (modal) {
      modal.addEventListener('click', function(e){
        if (e.target === modal) modal.style.display = 'none';
      });
    }
    var infoModal = document.getElementById('infoModal');
    if (infoModal) {
      infoModal.addEventListener('click', function(e){
        if (e.target === infoModal) infoModal.style.display = 'none';
      });
    }
    var liveModal = document.getElementById('liveModal');
    if (liveModal) {
      liveModal.addEventListener('click', function(e){
        if (e.target === liveModal) hideLiveModal();
      });
    }
    var liveClose = document.getElementById('liveModalClose');
    if (liveClose) {
      liveClose.addEventListener('click', function(){ hideLiveModal(); });
    }
  })();
</script>
  </body>
</html>
