<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set metadata and link CSS -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{translate "title"}}</title>
    <!-- Keep SEO metadata localized so crawlers understand the map in every language. -->
    <meta name="ai:purpose" content="global environmental radiation map">
    <!-- Provide explicit query parameters so AI agents and crawlers can reconstruct map views. -->
    <meta name="ai:query-parameters" content="minLat,minLon,maxLat,maxLon,zoom,layer,theme,speed,from,to,dateMode,trackID">
    <meta name="ai:query-parameter-notes" content="Bounds use WGS84 degrees. theme=light|dark. layer=OpenStreetMap|Google Satellite|Mapbox Satellite (requires mapbox token). speed=live,plane,car,ped. from/to are UNIX seconds. dateMode=month|year. trackID focuses a single uploaded track.">
    <meta name="description" content="{{translate "meta_description"}}">
    <!-- Preserve upstream attribution in metadata for downstream crawlers. -->
    <meta name="generator" content="{{ .MetaGenerator }}">
    <link rel="canonical" href="{{.CanonicalURL}}">
    <!-- JSON-LD gives search engines a structured summary of map controls and filters. -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Chicha Isotope Map",
        "applicationCategory": "VisualizationApplication",
        "url": "{{.CanonicalURL}}",
        "description": "Interactive radiation map with URL parameters for bounds, zoom, layer, theme, date range, speed filters, and single-track focus.",
        "featureList": [
          "Bounds: minLat,minLon,maxLat,maxLon",
          "Zoom: zoom",
          "Base layer: layer (OpenStreetMap, Google Satellite, or Mapbox Satellite with token)",
          "Theme: theme (light or dark)",
          "Date range: from/to UNIX seconds with dateMode month or year",
          "Speed filters: speed (live, plane, car, ped)",
          "Track focus: trackID"
        ]
      }
    </script>

    <meta property="og:type" content="website">
    <meta property="og:url" content="{{.CurrentURL}}">
    <meta property="og:title" content="{{translate "og_title"}}">
    <meta property="og:description" content="{{translate "og_description"}}">
    <meta property="og:image" content="{{.DefaultSocialImage}}">
    <meta property="og:site_name" content="Pelora">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/static/leaflet.css">
    <link rel="stylesheet" href="/static/nouislider.min.css">

		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="180x180" href="/static/images/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/images/favicon-16x16.png">
		<link rel="manifest" href="/static/images/site.webmanifest">


    <style>
/* General styles */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden; /* Hide scrollbars */
  background: var(--modal-bg); /* Apply theme background color */
  color: var(--modal-text); /* Ensure text inherits theme color */
  font-family: var(--font-family-base); /* Keep text styling consistent across the UI */
  font-size: var(--font-size-base); /* Align base size so similar widgets match */
  line-height: 1.5; /* Provide comfortable reading in both themes */
}

        /* Color and typography variables adapt to system theme */
        :root {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          color-scheme: light; /* Default to light scheme */
          --font-family-base: "Segoe UI", "Noto Sans", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; /* Shared font stack keeps every control aligned */
          --font-size-base: 12px; /* Main text size for buttons, menus, and labels */
          --font-size-sm: 10px; /* Secondary text such as helper descriptions */
					--font-size-xxs: 6px;
          --font-size-xs: 8px; /* Compact labels and metadata */
          --font-size-lg: 14px; /* Slightly larger controls where extra emphasis helps */
          --font-size-xl: 20px; /* Section headings */
          --font-size-display: 28px; /* Prominent readings inside tooltips */
        }

        @media (prefers-color-scheme: dark) {
          :root {
            --overlay-bg: rgba(0, 0, 0, 0.7);
            --progress-bg: #2b2b2b;
            --progress-color: #f4f4f4;
            --progress-bar-bg: #555555;
            --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            --upload-btn-bg: #4caf50; /* Standard site green for consistency */
            --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
            --control-bg: rgba(51, 51, 51, 0.25);
            --control-bg-hover: rgba(51, 51, 51, 0.35);
            --legend-border: 0px solid #555;
            --modal-bg: #2b2b2b;
            --modal-text: #eee;
            --modal-border: 1px solid #444;
            --link-color: #90caf9;
            --info-card-bg: rgba(43, 43, 43, 0.9);
            --info-card-border: 1px solid rgba(255, 255, 255, 0.08);
            --api-method-bg: rgba(144, 202, 249, 0.2);
            --api-method-text: #90caf9;
            color-scheme: dark; /* Match system dark scheme */
          }
        }

        /* Reuse the same typography across controls so menus, buttons, and overlays match */
        body, html, button, input, select, textarea {
          font-family: var(--font-family-base);
        }

        button,
        .upload-btn,
        .locate-btn,
        .back-to-all-btn,
        .slider-reset-btn,
        .slider-toggle button,
        .qr-btn,
        .live-modal-close {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

        /* Align shared UI chrome sizes while letting specialized components override when needed */
        .slider-label,
        .slider-toggle button,
        .live-popup-meta,
        .live-popup-small-link {
          font-size: var(--font-size-xs);
        }

        .live-tooltip-desc,
        .live-popup-dose-secondary,
        .live-popup-dose-status,
        .live-chart-unit {
          font-size: var(--font-size-sm);
        }

        .leaflet-container,
				.leaflet-container .leaflet-control,
        .leaflet-container .leaflet-popup,
        .leaflet-container .leaflet-tooltip {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

				/* Base style ‚Äì applies to all phones (old and new) */
				.leaflet-container .leaflet-control-attribution {
					font-family: var(--font-family-base);
					font-size: var(--font-size-xxs);
				}

				/* Increase font size only on screens wider than 768px (tablets, laptops, desktops) */
				@media (min-width: 768px) {
					.leaflet-container .leaflet-control-attribution {
						font-size: var(--font-size-xs);
					}
				}

        /* Manual theme overrides */
        :root[data-theme='light'] {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          color-scheme: light; /* Force light scheme when manually selected */
        }

        /* Reduce satellite imagery contrast in light mode so markers remain easier to spot. */
        :root[data-theme='light'] .google-satellite-layer img {
          filter: contrast(0.80);
        }

        /* Match the lighter contrast in dark mode, with a touch of extra darkening for legibility. */
        :root[data-theme='dark'] .google-satellite-layer img {
          filter: contrast(0.80) brightness(0.8);
        }

        :root[data-theme='dark'] {
          --overlay-bg: rgba(0, 0, 0, 0.7);
          --progress-bg: #2b2b2b;
          --progress-color: #f4f4f4;
          --progress-bar-bg: #555555;
          --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(51, 51, 51, 0.25);
          --control-bg-hover: rgba(51, 51, 51, 0.35);
          --legend-border: 0px solid #555;
          --modal-bg: #2b2b2b;
          --modal-text: #eee;
          --modal-border: 1px solid #444;
          --link-color: #90caf9;
          --info-card-bg: rgba(43, 43, 43, 0.9);
          --info-card-border: 1px solid rgba(255, 255, 255, 0.08);
          --api-method-bg: rgba(144, 202, 249, 0.2);
          --api-method-text: #90caf9;
          color-scheme: dark; /* Force dark scheme when manually selected */
        }

        /* Theme toggle switch */
        #themeToggle {
          position: absolute;
          bottom: 140px;
          right: 20px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          padding: 4px 6px;
          z-index: 1000;
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
          display: flex;
          align-items: center;
          gap: 6px;
          color: var(--modal-text);
        }

        /* World radiation logo keeps the map identity visible for SEO and users. */
        #mapLogo {
          position: absolute;
          top: 12px;
          left: 50%;
          transform: translateX(-50%);
          display: flex;
          align-items: center;
          gap: 6px;
          background: var(--overlay-bg);
          border: var(--legend-border);
          border-radius: 999px;
          padding: 6px 12px;
          z-index: 1200;
          font-size: var(--font-size-sm);
          color: var(--modal-text);
          margin: 0;
          text-transform: none;
        }

        #mapLogo .map-logo-icon {
          font-size: var(--font-size-lg);
          line-height: 1;
        }

        /* Small centered pill that surfaces the shareable short link under the logo */
        #shortLinkDisplay {
          position: absolute;
          top: 56px;
          left: 50%;
          transform: translateX(-50%);
          background: var(--overlay-bg);
          border: var(--legend-border);
          border-radius: 999px;
          padding: 4px 10px;
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.75;
          z-index: 1200;
          cursor: pointer;
          display: none;
          user-select: none;
          transition: opacity 0.2s ease;
        }

        #shortLinkDisplay:hover,
        #shortLinkDisplay:focus,
        #shortLinkDisplay.copied {
          opacity: 1;
          outline: none;
        }

        #shortLinkDisplay.copied {
          background: var(--control-bg-hover);
        }

        /* API quickstart cards inside the info modal stay theme aware through shared variables. */
        #infoModal .api-heading {
          font-size: var(--font-size-xl);
          margin: 0 0 0.5em;
        }

        #infoModal .api-intro {
          margin: 0 0 0.75em;
        }

        #infoModal .api-note {
          margin: 0 0 1.25em;
          font-size: var(--font-size-sm);
          opacity: 0.75;
        }

        #infoModal .api-grid {
          display: grid;
          gap: 12px;
        }

        @media (min-width: 640px) {
          #infoModal .api-grid {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
          }
        }

        #infoModal .api-card {
          background: var(--info-card-bg);
          border: var(--info-card-border);
          border-radius: 10px;
          padding: 12px 14px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #infoModal .api-card-head {
          display: flex;
          align-items: baseline;
          gap: 8px;
          margin-bottom: 8px;
        }

        #infoModal .api-method {
          display: inline-flex;
          align-items: center;
          padding: 2px 8px;
          border-radius: 999px;
          background: var(--api-method-bg);
          color: var(--api-method-text);
          font-size: var(--font-size-xs);
          font-weight: 700;
          letter-spacing: 0.06em;
        }

        #infoModal .api-path {
          font-family: var(--font-family-base);
          font-size: var(--font-size-sm);
          opacity: 0.8;
        }

        #infoModal .api-card-title {
          margin: 0 0 6px;
          font-size: var(--font-size-lg);
        }

        #infoModal .api-card-desc {
          margin: 0 0 10px;
          font-size: var(--font-size-sm);
        }

        #infoModal .api-card-link {
          display: inline-block;
          margin-bottom: 6px;
          color: var(--link-color);
          font-weight: 600;
          text-decoration: none;
        }

        #infoModal .api-card-link:hover,
        #infoModal .api-card-link:focus {
          text-decoration: underline;
        }

        #infoModal .api-card-note {
          margin: 0;
          font-size: var(--font-size-xs);
          opacity: 0.75;
        }

        #infoModal .api-more {
          margin-top: 16px;
          font-size: var(--font-size-sm);
        }

        .theme-icon {
          font-size: var(--font-size-base);
          line-height: 1;
        }

        .theme-switch {
          position: relative;
          display: inline-block;
          width: 30px;
          height: 16px;
          margin: 0 4px;
        }

        .theme-switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .theme-slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: 0.2s;
          border-radius: 16px;
        }

        .theme-slider:before {
          position: absolute;
          content: "";
          height: 12px;
          width: 12px;
          left: 2px;
          bottom: 2px;
          background-color: #fff;
          transition: 0.2s;
          border-radius: 50%;
        }

        .theme-switch input:checked + .theme-slider {
          background-color: #2196F3;
        }

        .theme-switch input:checked + .theme-slider:before {
          transform: translateX(14px);
        }

        /* Map container */
        #map {
          height: 100vh; /* Map takes full viewport height */
          margin: 0;
          overflow: hidden;
        }

        /* Custom tooltip styles */
        .custom-tooltip {
          /* Match tooltip with current theme */
          background-color: var(--modal-bg);
          border-radius: 5px;
          padding: 10px;
          color: var(--modal-text);
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
        }

        /* Consistent hover/focus hints for interactive controls */
        .control-tooltip {
          position: fixed;
          z-index: 1400;
          pointer-events: none;
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--legend-border);
          border-radius: 8px;
          padding: 10px 12px;
          box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
          font-size: var(--font-size-sm);
          line-height: 1.4;
          max-width: 280px;
          opacity: 0;
          transform: scale(0.96);
          transform-origin: center;
          transition: opacity 120ms ease, transform 120ms ease;
          text-align: left;
        }

        .control-tooltip--visible {
          opacity: 1;
          transform: scale(1);
        }

        .control-tooltip__title {
          font-weight: 600;
          margin-bottom: 4px;
          font-size: var(--font-size-base);
        }

        .control-tooltip__meta {
          font-size: var(--font-size-xs);
          opacity: 0.75;
          margin-top: 6px;
        }

        /* Lightweight list styling keeps multi-line tooltip content readable without extra markup. */
        .control-tooltip__list {
          margin: 6px 0 0;
          padding-left: 16px;
        }

        .control-tooltip__list li {
          margin-bottom: 4px;
        }

        .control-tooltip__list li:last-child {
          margin-bottom: 0;
        }

        /* Link inside popups pointing to full legend */
        .risk-link {
          color: var(--link-color);
          text-decoration: underline;
        }

        /* Larger color squares for legend items */
        .legend-square {
          display: inline-block;
          width: 12px;
          height: 12px;
          margin-right: 6px;
          border: var(--legend-border);
          border-radius: 2px;
        }

        /* Container for upload button */
        .upload-btn-container {
          position: absolute;
          top: 20px;
          right: 20px;
          z-index: 1000;
        }

        /* Upload button styling, theme-aware */
        .upload-btn {
          background-color: var(--upload-btn-bg); /* Use site green for familiarity */
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: #ffffff; /* White text stays readable across themes */
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        /* File upload overlay */
        #fileOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: var(--overlay-bg);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        /* Upload progress container */
        #fileProgressContainer {
          background-color: var(--progress-bg);
          color: var(--progress-color);
          padding: 20px;
          border-radius: 10px;
          max-width: 600px;
          width: 100%;
          box-shadow: var(--progress-shadow);
          max-height: 80vh;
          overflow-y: auto; /* Allow scrolling for many uploads */
        }

        /* Individual file upload progress */
        .file-progress {
          margin-bottom: 15px;
        }

        .file-name {
          font-weight: bold;
          margin-bottom: 5px;
        }

        /* Progress bar */
        .progress-bar {
          width: 100%;
          height: 10px;
          background-color: var(--progress-bar-bg);
          border-radius: 5px;
          overflow: hidden;
        }

        .progress-bar-inner {
          height: 100%;
          background-color: #4caf50;
          width: 0%;
        }

        /* Server processing indicator */
        .server-processing {
          margin-left: 10px;
          font-size: var(--font-size-base);
          color: #ff9800;
        }

        /* Upload button hover effect */
        .upload-btn:hover {
          background-color: var(--upload-btn-bg-hover); /* Darker shade on hover */
        }

        /* Container for geolocation button */
        .locate-btn-container {
          position: absolute;
          top: 60px;
          right: 20px;
          z-index: 1000;
        }

        /* Geolocation button styling, theme-aware */
        .locate-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Geolocation button hover effect */
        .locate-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* GitHub link styling */
        .github-link {
          position: absolute;
          bottom: 20px;
          left: 20px;
          z-index: 1000;
        }

        /* Ensure the logo renders at its intrinsic size without stretching. */
        .github-link img {
          display: block;
          width: auto;
          height: auto;
          max-width: none;
          max-height: none;
        }

        .github-icon {
          width: 60px;
          height: 60px;
          opacity: 0.7;
        }

        .github-icon:hover {
          opacity: 1;
        }

        /* Program info uses theme text and link colors */
        .program-info {
          position: absolute;
          bottom: 20px;
          left: 70px;
          z-index: 1000;
          color: var(--modal-text);
          font-size: var(--font-size-base);
          opacity: 0.6;
        }

        .program-info a {
          color: var(--link-color);
          text-decoration: none;
        }

        .program-info a:hover {
          text-decoration: underline;
        }

        .program-info:hover {
          opacity: 1;
        }

        /* "Back to all tracks" button container.
           Positioned below the QR button to prevent overlap. */
        .back-to-all-container {
          position: absolute;
          top: 185px; /* place under geolocation+QR stack */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .back-to-all-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        .back-to-all-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* Dedicated download container lives under the back button so
           track view controls remain grouped for quick access. */
        .download-track-container {
          position: absolute;
          top: 225px; /* keep consistent spacing below the back button */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .download-track-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          text-decoration: none;
          display: inline-block;
        }

        .download-track-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* Track playback button uses the slider play styling so it stays familiar. */
        .track-playback-control {
          padding: 6px;
          width: 50px;
        }


        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì‚Äì Slider clean-look patch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .date-slider-box {
          padding: 6px;
          width: 50px;
        }

        /* 0) Basic slider container geometry: buffer = 8px
           (half handle size) so handles never exceed the rail */
        #dateSlider{
          width:6px;                 /* rail thickness */
          height:130px;              /* actual track length */
          padding:0px 0;             /* inner top/bottom padding */
          box-sizing:content-box;    /* ensures padding works */
          margin:16px auto 26px;
        }

        /* 1) grey slider rail */
        #dateSlider .noUi-base{
          background:#bfbfbf;
          width:100%;                /* 6px width */
          height:100%;               /* 130px minus padding */
        }

        /* 2) colored section only between handles */
        #dateSlider .noUi-connect{
          background:#1e88e5;        /* pick your brand color */
        }

        /* Slider handles respect theme colors */
        .noUi-vertical .noUi-handle{
          width:32px;
          height:20px;
          left:-18px;              /* center on 6px rail */
          border-radius:3px;
          background: var(--control-bg);      /* follow theme */
          border: var(--legend-border);   /* match theme border */
          box-shadow:0 1px 3px rgba(0,0,0,.25);
          cursor:grab;
        }
        /* 4) remove pseudo-element tails */
        .noUi-handle:before,
        .noUi-handle:after{ display:none; }

        .slider-label{
          margin:2px 0;
          font-size: var(--font-size-xs);
          line-height:1.15em;
          white-space:nowrap;
          text-align:center;
        }

        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Year / Month toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .slider-toggle{
          display:flex; gap:2px; margin:2px 0 4px;
          font-size: var(--font-size-xs); line-height:1; user-select:none;
        }
        /* Year/Month toggle buttons adapt to theme */
        .slider-toggle button{
          flex:1 1 0; padding:2px 4px;
          border: var(--legend-border); background: var(--control-bg);
          border-radius:3px; cursor:pointer;
          color: var(--modal-text);
        }
        .slider-toggle button.active{
          background:#1e88e5; color:#fff; border-color:#1e88e5;
        }

        /* ‚îÄ‚îÄ‚îÄ Year mode: slider height matches month slider ‚îÄ‚îÄ‚îÄ */
        #yearSlider{
          /* copied parameters from #dateSlider */
          width:6px;                 /* rail thickness */
          height:130px;              /* track length */
          padding:0;                 /* inner padding */
          margin:16px auto 26px;     /* same margins */
          box-sizing:content-box;
        }
        /* grey rail and blue connect bar */
        #yearSlider .noUi-base      {background:#bfbfbf;width:100%;height:100%;}
        #yearSlider .noUi-connect   {background:#bfbfbf;}


        .slider-actions{
          display:flex;
          gap:4px;
          margin-top:4px;
        }

        /* Reset/Play buttons styled with theme variables */
        .slider-reset-btn,
        .slider-play-btn{
          display:block;
          width:100%;
          padding:2px 4px;
          font-size: var(--font-size-xl);
          border: var(--legend-border);
          background: var(--control-bg);
          border-radius:3px;
          cursor:pointer;
          color: var(--modal-text);
        }
        .slider-reset-btn:hover,
        .slider-play-btn:hover{ background: var(--control-bg-hover); }

        .slider-play-btn.is-playing{
          background:#1e88e5;
          color:#fff;
          border-color:#1e88e5;
        }

        /* Track view reset sits under play so both buttons remain aligned. */
        .track-reset-btn{
          margin-top:4px;
        }

        .loading-overlay{
          position:absolute;
          top:50%;left:50%;
          transform:translate(-50%,-50%);
          z-index:3000;
          pointer-events:none;
        }
        .spinner{
          width:40px;height:40px;
          border:4px solid rgba(0,0,0,.15);
          border-top:4px solid #1e88e5;
          border-radius:50%;
          animation:spin 1s linear infinite;
        }
        @keyframes spin{ to{ transform:rotate(360deg); } }


        /* Compact QR button follows theme */
        .qr-btn {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          width: 42px; height: 42px;
          padding: 4px;
          display: flex; align-items: center; justify-content: center;
          cursor: pointer;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .qr-btn:hover { background: var(--control-bg-hover); }
        .qr-btn svg { width: 22px; height: 22px; display: block; }

        /* Leaflet controls use theme variables so colors follow the current theme */
        .leaflet-control-layers,
        .leaflet-control-layers-toggle,
        .leaflet-control-layers-list,
        .leaflet-control-layers-expanded,
        .leaflet-bar a {
          background-color: var(--control-bg);
          border: var(--legend-border);
          color: var(--modal-text);
        }

        .leaflet-control-layers-toggle:hover,
        .leaflet-bar a:hover {
          background-color: var(--control-bg-hover);
        }

        /* Ensure layer labels match theme text color */
        .leaflet-control-layers label { color: var(--modal-text); }

        /* ===== Leaflet layer control ===== */
        /* Remove border and shadow around map type selector to blend into map */
        .leaflet-control-layers,
        .leaflet-control-layers-expanded,
        .leaflet-control-layers-list {
          box-shadow: none;
        }

        /* Removed old collapsible legend styles (legend-control, legend-header, legend-title, legend-toggle, legend-body, legend-row, legend-swatch, legend-label)
           to avoid duplicate legends. Only the compact legend + modal remain. */

        /* Live marker icon now combines the heart logo with the dose value. */
        .live-marker {
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 2px;
          text-align: center;
          font-weight: 600;
          font-family: var(--font-family-base);
          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
          color: #000;
          overflow: hidden;
        }

        .live-marker-heart {
          display: block;
          width: 60%;
          height: auto;
          pointer-events: none;
        }

        .live-marker-value {
          line-height: 1;
          font-size: 0.55em;
          letter-spacing: -0.02em;
        }



				/* ---- Unified tooltip/popup sizing & wrapping ----
					 Keep tooltip (hover) and popup (click) the same width.
					 Leaflet's default popup maxWidth is ~300px, so we reuse that.
					 Adjust --tooltip-max if you want it wider/narrower in one place. */
				:root {
					--tooltip-max: 300px;   /* single source of truth for both tooltip & popup widths */
					--tooltip-min: 220px;   /* prevents collapsing into a thin vertical strip */
				}

				/* Wrapper used inside both tooltip and popup content */
				.live-tooltip {
					max-width: var(--tooltip-max);  /* wider than old 260px */
				}

				/* Leaflet tooltip content (hover). Make it match popup width and wrap nicely. */
				.leaflet-tooltip.custom-tooltip {
					white-space: normal;            /* allow line wrapping */
					max-width: var(--tooltip-max);  /* match popup max width */
					min-inline-size: var(--tooltip-min); /* avoid skinny column */
					overflow-wrap: break-word;      /* break long words/URLs only when needed */
					word-break: break-word;         /* compatibility for older browsers */
					hyphens: auto;                  /* nicer hyphenation when available */
				}

				/* Leaflet popup content (click). Enforce the same max width to match tooltip. */
				.leaflet-popup-content {
					max-width: var(--tooltip-max);  /* unify with tooltip width */
				}

				/* Flex header: allow text to shrink in flex so it doesn't overflow. */
				.live-tooltip-header {
					display: flex;
					gap: 10px;
					align-items: center;
					margin-bottom: 6px;
					min-width: 0;                   /* critical for proper flex text shrinking */
				}

				/* Fixed-size heart icon so it doesn't affect layout */
				.live-tooltip-heart {
					width: 28px;
					height: 28px;
					flex: 0 0 28px;
				}

				/* Title and description: let text wrap and shrink inside flex */
				.live-tooltip-title,
				.live-tooltip-desc {
					margin: 0;
					min-width: 0;                   /* allow shrinking in flex */
					flex: 1 1 auto;                 /* take available space without overflowing */
				}

        .live-tooltip-desc {
          font-size: var(--font-size-sm);
          line-height: 1.4;
        }

        /* Highlight realtime dose with large numerals while keeping context compact. */
        .live-popup-dose {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
          margin: 6px 0;
        }

        .live-popup-dose-primary {
          font-size: var(--font-size-display);
          font-weight: 700;
          line-height: 1;
          letter-spacing: -0.01em;
        }

        .live-popup-dose-unit {
          margin-left: 6px;
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-dose-secondary {
          font-size: var(--font-size-sm);
          opacity: 0.85;
        }

        .live-popup-dose-status {
          padding: 4px 10px;
          border-radius: 6px;
          font-size: var(--font-size-sm);
          font-weight: 600;
        }

        .live-popup-climate {
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-meta {
          font-size: var(--font-size-xs);
          line-height: 1.4;
          opacity: 0.85;
          display: grid;
          gap: 4px;
          margin-top: 6px;
        }

        .live-popup-meta strong {
          font-weight: 600;
        }

        .live-popup-small-link {
          font-size: var(--font-size-xs);
          display: inline-block;
          margin-top: 4px;
        }



        .live-extra-list {
          margin: 4px 0 0 0;
          padding-left: 18px;
        }

        .live-extra-list li {
          margin: 2px 0;
        }

        /* Keep the icons in the speed filter aligned regardless of emoji vs. SVG source. */
        .speed-filter-icon {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 1.5em;
          height: 1.5em;
          margin-left: 6px;
          font-size: 1.2em;
          line-height: 1;
        }

        /* Ensure the SVG heart scales with the surrounding emoji-based icons. */
        .speed-filter-icon img {
          display: block;
          width: 100%;
          height: 100%;
        }

        /* Apply grayscale filter so emoji icons render in monochrome without altering other assets. */
        .speed-filter-icon--mono {
          filter: grayscale(1) brightness(1) contrast(1);
        }

        #liveModal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.6);
          z-index: 2100;
          justify-content: center;
          align-items: center;
        }

        .live-modal-content {
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--modal-border);
          width: min(720px, 92%);
          max-height: 85vh;
          overflow-y: auto;
          padding: 20px;
          border-radius: 12px;
          box-shadow: 0 0 12px rgba(0, 0, 0, 0.45);
          font-family: inherit;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-modal-header {
          display: flex;
          align-items: center;
          gap: 14px;
        }

        .live-modal-heart {
          width: 40px;
          height: 40px;
        }

        .live-modal-title {
          margin: 0;
          font-size: var(--font-size-xl);
        }

        .live-modal-description {
          margin: 4px 0 0 0;
          line-height: 1.6;
        }

        .live-modal-meta {
          display: grid;
          gap: 6px;
          font-size: var(--font-size-base);
        }

        .live-chart-stack {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-chart-controls {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
        }

        .live-range-button {
          padding: 6px 12px;
          border-radius: 999px;
          border: 1px solid rgba(255, 255, 255, 0.12);
          background: rgba(255, 255, 255, 0.06);
          color: var(--modal-text);
          font-size: var(--font-size-sm);
          font-family: inherit;
          cursor: pointer;
          transition: background 0.2s ease, border 0.2s ease, transform 0.2s ease;
        }

        .live-range-button.is-active {
          background: rgba(250, 204, 21, 0.2);
          border-color: rgba(250, 204, 21, 0.7);
          color: var(--modal-text);
          transform: translateY(-1px);
        }

        .live-range-button:focus-visible {
          outline: 2px solid rgba(250, 204, 21, 0.6);
          outline-offset: 2px;
        }

        .live-chart-block {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 10px;
          padding: 12px;
          display: none;
        }

        .live-chart-block.is-active {
          display: block;
        }

        .live-chart-title {
          margin: 0 0 8px 0;
          display: flex;
          flex-wrap: wrap;
          gap: 4px 12px;
          align-items: baseline;
        }

        .live-chart-label {
          font-size: var(--font-size-base);
          font-weight: 600;
          flex: 1 1 auto;
        }

        .live-chart-unit {
          font-size: var(--font-size-sm);
          color: var(--modal-text);
          opacity: 0.8;
        }

        .live-chart-window {
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.7;
        }

        .live-chart-canvas {
          display: block;
          width: 100%;
          height: 180px;
          border-radius: 6px;
          background: rgba(0,0,0,0.05);
        }

        .live-chart-empty {
          margin: 0;
          font-size: var(--font-size-sm);
          color: var(--modal-text);
        }

        .live-modal-close {
          align-self: flex-end;
          padding: 6px 14px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 6px;
          cursor: pointer;
          font-family: inherit;
          color: var(--modal-text);
        }

        .live-chart-button {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          padding: 6px 12px;
          border-radius: 8px;
          border: 1px solid var(--live-chart-border, rgba(255, 255, 255, 0.15));
          background: var(--live-chart-bg, rgba(255, 255, 255, 0.08));
          color: var(--live-chart-text, var(--modal-text));
          font-size: var(--font-size-sm);
          font-weight: 600;
          font-family: inherit;
          cursor: pointer;
          text-decoration: none;
          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.16), 0 0 0 2px var(--live-chart-glow, transparent);
          transition: background 0.2s ease, border 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }

        .live-chart-button:hover {
          background: var(--live-chart-hover, rgba(255, 255, 255, 0.14));
          border-color: var(--live-chart-border, rgba(255, 255, 255, 0.3));
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18), 0 0 0 3px var(--live-chart-glow, transparent);
          transform: translateY(-1px);
        }

        .live-chart-button:focus-visible {
          outline: 2px solid var(--live-chart-focus, rgba(250, 204, 21, 0.6));
          outline-offset: 2px;
        }

        .live-chart-icon {
          font-size: 14px;
          line-height: 1;
        }

    </style>

    <!-- Translation script -->
    <script id="translations-script">
      // Translation object passed from Go
      // We emit ready-made JS literals to keep html/template from misdetecting
      // the surrounding string context when translations contain quotes.
      var translations = {{ .TranslationsJSON }};
        var currentLang = '{{ .Lang }}'; // Current language

        // Get translation by key
        function translate(key) {
            if (!translations['en']) {
                console.error('English translations not available!');
                return key;
            }

            if (translations[currentLang] && translations[currentLang][key]) {
                return translations[currentLang][key];
            } else if (translations['en'][key]) {
                return translations['en'][key];
            }
            return key;
        }
    </script>
    <script>
      const defaultCfg = {
        lat:  {{printf "%.6f" .DefaultLat}},
        lon:  {{printf "%.6f" .DefaultLon}},
        zoom: {{.DefaultZoom}},
        layer: {{ printf "%q" .DefaultLayer }},
        autoLocate: {{if .AutoLocateDefault}}true{{else}}false{{end}}
      };
    </script>
    <script>
      // Surface the configured support e-mail so the legal dialog can show a contact when available.
      window.supportEmail = {{if .SupportEmail}}{{printf "%q" .SupportEmail}}{{else}}""{{end}};
    </script>
    <script>
      // Mapbox layers stay optional so deployments can omit the access token entirely.
      window.mapboxToken = {{if .MapboxToken}}{{printf "%q" .MapboxToken}}{{else}}""{{end}};
    </script>
    <script>
      // Expose upstream attribution ingredients so sources remain localized.
      window.chichaVersion = {{ printf "%q" .Version }};
      window.chichaGitHubURL = {{ printf "%q" .ChichaGitHubURL }};
      // Only show the GitHub tooltip when the logo still points to GitHub.
      window.showGithubLinkTooltip = {{if .ShowGithubTooltip}}true{{else}}false{{end}};
    </script>
    <script>
      // Expose the realtime flag so the UI can hide controls when the backend keeps the feature off.
      window.realtimeEnabled = {{if .RealtimeAvailable}}true{{else}}false{{end}};
      // Keep the default toggle server-driven so operators can require explicit opt-in.
      window.realtimeDefault = {{if .RealtimeDefault}}true{{else}}false{{end}};
    </script>

  </head>

  <body>

    <!-- Container for upload button -->
    <div class="upload-btn-container leaflet-control">
      <!--
        title/aria-label ‚Üí short hint on hover/focus about formats
        and what happens after upload.
      -->
      <label
        for="fileInput"
        class="upload-btn"
        aria-label="{{translate "upload_button_tooltip"}}">
        {{translate "upload_button"}}
      </label>

      <input
        type="file"
        id="fileInput"
        style="display: none;"
        multiple
        accept=""
        onchange="uploadFiles()">
    </div>

    <!-- Container for geolocation button -->
    <div class="locate-btn-container leaflet-control">
      <button id="locateButton" class="locate-btn" aria-label="{{translate "locate_button_tooltip"}}">
        <img src="/static/images/marker-icon-2x.png" alt="Locate" style="width:20px;">
      </button>
      <br>
      <!-- Small QR button under geolocate -->
      <button id="qrButton" class="qr-btn" aria-label="{{translate "qr_button_tooltip"}}">
        <svg viewBox="0 0 100 100" role="img" aria-hidden="true">
          <rect x="0" y="0" width="100" height="100" fill="#fff"/>
          <rect x="8" y="8" width="28" height="28" fill="#000"/>
          <rect x="12" y="12" width="20" height="20" fill="#fff"/>
          <rect x="16" y="16" width="12" height="12" fill="#000"/>
          <rect x="64" y="8" width="28" height="28" fill="#000"/>
          <rect x="68" y="12" width="20" height="20" fill="#fff"/>
          <rect x="72" y="16" width="12" height="12" fill="#000"/>
          <rect x="8" y="64" width="28" height="28" fill="#000"/>
          <rect x="12" y="68" width="20" height="20" fill="#fff"/>
          <rect x="16" y="72" width="12" height="12" fill="#000"/>
          <rect x="48" y="12" width="8" height="8" fill="#000"/>
          <rect x="40" y="28" width="8" height="8" fill="#000"/>
          <rect x="56" y="28" width="8" height="8" fill="#000"/>
          <rect x="44" y="44" width="8" height="8" fill="#000"/>
          <rect x="60" y="44" width="8" height="8" fill="#000"/>
          <rect x="44" y="60" width="8" height="8" fill="#000"/>
          <rect x="60" y="60" width="8" height="8" fill="#000"/>
          <rect x="76" y="60" width="8" height="8" fill="#000"/>
          <rect x="28" y="44" width="8" height="8" fill="#000"/>
        </svg>
      </button>
    </div>

    <!-- Container for "Back to all tracks" button -->
    <div class="back-to-all-container leaflet-control" style="display: none;">
      <button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
    </div>

    <!-- Track download button appears only in track view so users can retrieve the original JSON quickly. -->
    <div class="download-track-container leaflet-control" style="display: none;">
      <a id="downloadTrackLink" class="download-track-btn" href="#">{{ translate "download_track_cim" }}</a>
    </div>

    <!-- File upload overlay -->
    <div id="fileOverlay" style="display: none;">
      <div id="fileProgressContainer">
        <!-- Upload progress entries inserted here dynamically -->
      </div>
    </div>

    <!-- GitHub link and program info -->
    <a href="{{ .LogoLink }}" class="github-link" target="_blank" rel="noopener noreferrer" aria-label="{{if .ShowGithubTooltip}}{{translate "github_link_tooltip_desc"}}{{else}}{{translate "logo_title"}}{{end}}">
      <img src="{{ .LogoImageURL }}" alt="{{translate "description"}} (version: {{ .Version }})" >
    </a>

    <!-- World radiation logo announces the map identity for every language. -->
    <h1 id="mapLogo" aria-label="{{translate "logo_title"}}">
      <span class="map-logo-text">{{translate "logo_title"}}</span>
    </h1>

    <!-- Short link pill shows the shareable URL and copies it on click -->
    <div
      id="shortLinkDisplay"
      role="button"
      tabindex="0"
      aria-live="polite"
      aria-label="{{translate "short_link_tooltip"}}"></div>

    <!-- Map container -->
    <div id="map"></div>

    <div id="loadingOverlay" class="loading-overlay" style="display:none;">
      <div class="spinner"></div>
    </div>

    <!-- Theme toggle -->
    <div id="themeToggle" role="button" tabindex="0" aria-label="{{translate "theme_toggle_tooltip"}}">
      <span class="theme-icon">‚òÄÔ∏è</span>
      <label class="theme-switch">
        <input type="checkbox" id="themeSwitch">
        <span class="theme-slider"></span>
      </label>
      <span class="theme-icon">üåô</span>
    </div>

<!-- Compact Legend (clickable) -->
<div id="legend" role="button" tabindex="0" aria-label="{{translate "legend_button_tooltip"}}" style="
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: var(--control-bg);
  border: var(--legend-border);
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
  padding: 10px 10px 10px 0;
  font-size: var(--font-size-sm);
  line-height: 1.4em;
  cursor: pointer;
  z-index: 1000;
  font-family: var(--font-family-base);
  display: flex;
  overflow: hidden;">
    <div style="width:16px; margin-left:6px; margin-right:6px; border-radius:4px 4px 4px 4px; overflow:hidden; background:linear-gradient(to top,#008000,#FFD700,#FF8C00,#FF4500,#000); position:relative;">
    <span style="position:absolute; bottom:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size: var(--font-size-xxs);">{{translate "legend_safe"}}</span>
    <span style="position:absolute; top:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size: var(--font-size-xxs);">{{translate "legend_danger"}}</span>
</div>
  <div>
    <strong>{{translate "legend_title"}}</strong><br>
    <div><span style="color:#000000;">‚ñ†</span> >100 ¬µR/h</div>
    <div><span style="color:#FF4500;">‚ñ†</span> 30‚Äì100 ¬µR/h</div>
  <div><span style="color:#FFD700;">‚ñ†</span> 11‚Äì30 ¬µR/h</div>
   <div><span style="color:#008000;">‚ñ†</span> 0‚Äì11 ¬µR/h</div>
  </div>
</div>
<!--
  Compact 4-bin legend (¬µR/h) with vertical gradient bar (green‚Üíyellow‚Üíorange‚Üíred‚Üíblack).
  White labels mark safe at the bottom and danger at the top.
  Clicking the legend opens a modal with full, human-friendly guidance.
-->
<!-- Legend Modal -->
  <div id="legendModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">{{translate "legend_title"}}</h3>
    <!-- We inject the localized full text below -->
    <div id="legendText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('legendModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!--
  Modal that displays the full, localized legend text.
  `white-space:pre-wrap` preserves paragraphs and bullets from translations.json.
  Box scrolls when content is long.
-->

<!-- Generic Info Modal for legal notes, data sources, and license -->
<div id="infoModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 id="infoTitle" style="margin-top:0;"></h3>
    <div id="infoText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('infoModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full MIT License directly on the map. -->
<div class="license-modal" data-license="mit" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">MIT License</h3>
    <pre class="license-modal-body" data-license-url="/licenses/mit" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading‚Ä¶</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="mit" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full CC0 1.0 Universal text. -->
<div class="license-modal" data-license="cc0" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">CC0 1.0 Universal</h3>
    <pre class="license-modal-body" data-license-url="/licenses/cc0" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading‚Ä¶</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="cc0" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>

</div>


<!-- Modal with Grafana-style stacked charts for realtime sensors -->

<div id="liveModal">
  <div class="live-modal-content">
    <div class="live-modal-header">
      <img src="/static/images/safecast-heart-logo.png" alt="Realtime sensor" class="live-modal-heart">
      <div>
        <h3 id="liveModalTitle" class="live-modal-title"></h3>
        <p id="liveModalDescription" class="live-modal-description"></p>
      </div>
    </div>
    <div id="liveModalMeta" class="live-modal-meta"></div>
    <div id="liveModalExtra" class="live-modal-meta"></div>
    <div class="live-chart-controls" id="liveChartControls">
      <button type="button" class="live-range-button" data-range="day"></button>
      <button type="button" class="live-range-button" data-range="week"></button>
      <button type="button" class="live-range-button" data-range="month"></button>
      <button type="button" class="live-range-button" data-range="all"></button>
    </div>
    <div class="live-chart-stack">
      <div class="live-chart-block" data-range="day">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleDay"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="day"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="day"></canvas>
        <p class="live-chart-empty" data-range="day"></p>
      </div>
      <div class="live-chart-block" data-range="week">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleWeek"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="week"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="week"></canvas>
        <p class="live-chart-empty" data-range="week"></p>
      </div>
      <div class="live-chart-block" data-range="month">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleMonth"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="month"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="month"></canvas>
        <p class="live-chart-empty" data-range="month"></p>
      </div>
      <div class="live-chart-block" data-range="all">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleAll"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" data-range="all"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="all"></canvas>
        <p class="live-chart-empty" data-range="all"></p>
      </div>
    </div>
    <button type="button" class="live-modal-close" id="liveModalClose"></button>
  </div>
</div>

    <!-- Load Leaflet JavaScript library -->
    <script src="/static/leaflet.js"></script>

    <!-- Slider -->
    <script src="/static/nouislider.min.js"></script>
    <script src="/static/wNumb.min.js"></script>



    <!-- Helper functions -->
    <script>
      // Cache typography tokens so dynamic canvases reuse the same styling as CSS.
      let cachedFontTokens;
      function resolveFontTokens() {
        if (cachedFontTokens) return cachedFontTokens;
        const root = document.documentElement;
        const styles = window.getComputedStyle(root);
        const fallbackFamily = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        const familyRaw = (styles.getPropertyValue('--font-family-base') || '').trim();
        const family = familyRaw || fallbackFamily;

        function pickSize(varName, defaultSize) {
          const value = (styles.getPropertyValue(varName) || '').trim();
          return value || defaultSize;
        }

        cachedFontTokens = {
          family: family,
          xs: pickSize('--font-size-xs', '6px'),
          sm: pickSize('--font-size-sm', '10px'),
          base: pickSize('--font-size-base', '12px'),
          lg: pickSize('--font-size-lg', '14px'),
          xl: pickSize('--font-size-xl', '20px'),
          display: pickSize('--font-size-display', '28px'),
        };
        return cachedFontTokens;
      }

      // Compute marker color from radiation level
      function getGradientColor(doseRate) {
        if (doseRate <= 0.04) return '#006400'; // Dark green
        else if (doseRate <= 0.08) return interpolateColor([0, 100, 0], [173, 255, 47], (doseRate - 0.04) / (0.08 - 0.04));
        else if (doseRate <= 0.11) return interpolateColor([173, 255, 47], [255, 255, 0], (doseRate - 0.08) / (0.11 - 0.08));
        else if (doseRate <= 0.20) return interpolateColor([255, 255, 0], [255, 165, 0], (doseRate - 0.11) / (0.20 - 0.11));
        else if (doseRate <= 0.30) return interpolateColor([255, 165, 0], [255, 0, 0], (doseRate - 0.20) / (0.30 - 0.20));
        else if (doseRate <= 0.99) return interpolateColor([255, 0, 0], [0, 0, 0], (doseRate - 0.30) / (0.99 - 0.30));
        else return '#000000'; // Black for very high values
      }

// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
  if (factor < 0) factor = 0;
  if (factor > 1) factor = 1;

  const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
  const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
  const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

// Calculate marker radius based on zoom level
function getRadius(doseRate, zoomLevel) {
  // previous formula: Math.pow(2, (zoomLevel-10)/2)
  const k = 1;                               // scale by ~2
  let r   = Math.pow(2, (zoomLevel - 10)/2.5) * k;
  return Math.max(r, 2);                       // prevent tiny circles
}

// Live markers need decluttering at low zoom so they never stack and look like
// a single dot. We enforce a spacing that caps overlap at ~20% between equal
// circles (‚âà1.374 * radius in screen space).
const LIVE_MAX_OVERLAP_RATIO = 0.2;
const LIVE_MIN_SPACING_FACTOR = 1.374; // derived from equal-circle overlap math

// liveMinSpacingPx returns the minimum center-to-center distance that keeps
// two circles from overlapping more than LIVE_MAX_OVERLAP_RATIO.
function liveMinSpacingPx(radiusPx) {
  return Math.max(1, radiusPx * LIVE_MIN_SPACING_FACTOR);
}

// createLivePlacementGrid keeps realtime markers separated in pixel space.
// We use a lightweight grid + spiral search to stay deterministic and fast
// across browsers without external libraries.
function createLivePlacementGrid(mapRef, zoomLevel) {
  const baseRadius = getRadius(0, zoomLevel) * 3;
  const baseSpacing = liveMinSpacingPx(baseRadius);
  const cellSize = Math.max(baseSpacing, 1);
  const grid = new Map();

  function cellKey(point) {
    const cx = Math.floor(point.x / cellSize);
    const cy = Math.floor(point.y / cellSize);
    return `${cx}:${cy}`;
  }

  function nearbyPoints(point) {
    const cx = Math.floor(point.x / cellSize);
    const cy = Math.floor(point.y / cellSize);
    const out = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cx + dx}:${cy + dy}`;
        const bucket = grid.get(key);
        if (bucket) {
          out.push.apply(out, bucket);
        }
      }
    }
    return out;
  }

  function canPlace(point, spacing) {
    const peers = nearbyPoints(point);
    for (let i = 0; i < peers.length; i++) {
      const dx = point.x - peers[i].x;
      const dy = point.y - peers[i].y;
      if (Math.hypot(dx, dy) < spacing) {
        return false;
      }
    }
    return true;
  }

  function remember(point) {
    const key = cellKey(point);
    const bucket = grid.get(key) || [];
    bucket.push(point);
    grid.set(key, bucket);
  }

  function spiralCandidate(origin, index, spacing) {
    if (index === 0) return origin;
    const ring = Math.ceil(index / 6);
    const angle = index * 2.399963229728653; // golden angle in radians
    const radius = ring * spacing;
    return L.point(origin.x + Math.cos(angle) * radius, origin.y + Math.sin(angle) * radius);
  }

  return {
    place: function(latlng, radiusPx) {
      const spacing = Math.max(baseSpacing, liveMinSpacingPx(radiusPx));
      const origin = mapRef.latLngToLayerPoint(latlng);
      const maxAttempts = 48; // enough for dense clusters without heavy loops
      for (let i = 0; i < maxAttempts; i++) {
        const candidate = spiralCandidate(origin, i, spacing);
        if (canPlace(candidate, spacing)) {
          remember(candidate);
          return mapRef.layerPointToLatLng(candidate);
        }
      }
      // Fall back to the original point if we ran out of slots.
      remember(origin);
      return latlng;
    }
  };
}

// Thresholds for realtime freshness expressed in seconds so both the
// rendering loop and periodic refresh share the same rules.
const LIVE_ACTIVE_WINDOW = 5 * 60;         // 5 minutes keeps "working" sensors bright
const LIVE_RECENT_WINDOW = 24 * 60 * 60;   // 24 hours before removal

// parseColor extracts RGB components from either hex (#rrggbb) or rgb(r,g,b)
// strings.  Keeping this helper local avoids pulling external libraries while
// letting us reuse the logic for alpha blending and contrast checks.
function parseColor(color) {
  if (!color) return null;
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
      };
    }
    if (hex.length === 3) {
      return {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16),
      };
    }
  }
  if (color.startsWith('rgb')) {
    const parts = color.match(/\d+/g);
    if (parts && parts.length >= 3) {
      return {
        r: parseInt(parts[0], 10),
        g: parseInt(parts[1], 10),
        b: parseInt(parts[2], 10),
      };
    }
  }
  return null;
}

// colorWithAlpha returns an rgba() string using the provided alpha.  We reuse
// parseColor so realtime markers can reuse the same gradient palette while
// dimming stale sensors without affecting the text opacity.
function colorWithAlpha(color, alpha) {
  const rgb = parseColor(color);
  if (!rgb) return color;
  const a = Math.min(Math.max(alpha, 0), 1);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
}

// isDarkColor estimates perceived brightness to choose a contrasting text
// color.  A simple luminance formula keeps the implementation lightweight.
function isDarkColor(color) {
  const rgb = parseColor(color);
  if (!rgb) return false;
  const luminance = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
  return luminance < 140;
}

// formatMicroRoentgen converts ¬µSv/h into ¬µR/h text while avoiding excessive
// decimals.  Smaller values keep two decimals; larger ones are rounded to the
// nearest whole number for quick scanning on the map.
function formatMicroRoentgen(doseRate) {
  const micro = doseRate * 100;
  if (micro >= 100) return micro.toFixed(0);
  if (micro >= 10) return micro.toFixed(1);
  if (micro >= 1) return micro.toFixed(2);
  return micro.toFixed(3);
}

// formatMicroRoentgenValue keeps axis labels tidy when the charts already work
// with ¬µR/h values.  Sharing the logic here avoids sprinkling the rounding
// heuristics through the drawing code.
function formatMicroRoentgenValue(value) {
  const abs = Math.abs(value);
  if (abs >= 100) return value.toFixed(0);
  if (abs >= 10) return value.toFixed(1);
  if (abs >= 1) return value.toFixed(2);
  return value.toFixed(3);
}

// escapeHtml protects popups against user-supplied strings like device names.
// We rely on explicit lookup tables instead of quoting " inside the regex so
// Go's html/template parser keeps the surrounding <script> in a neutral state.
const ESCAPE_HTML_RE = /[&<>\u0022\u0027]/g;
const ESCAPE_HTML_LOOKUP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
};
ESCAPE_HTML_LOOKUP['\u0022'] = '&quot;';
ESCAPE_HTML_LOOKUP['\u0027'] = '&#39;';
function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value).replace(ESCAPE_HTML_RE, function(ch) {
    return ESCAPE_HTML_LOOKUP[ch] || ch;
  });
}

const regionNameCache = {};

function formatDateTime(ts) {
  if (!ts) return '‚Äî';
  const date = new Date(ts * 1000);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  return date.toLocaleString(lang, { hour12: false });
}

function approximateLocalTime(lat, lon) {
  if (typeof lon !== 'number' || !isFinite(lon)) return null;
  const offsetHours = Math.round(lon / 15);
  const offsetMs = offsetHours * 60 * 60 * 1000;
  const remote = new Date(Date.now() + offsetMs);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const label = offsetHours === 0 ? 'UTC' : (offsetHours > 0 ? `UTC+${offsetHours}` : `UTC${offsetHours}`);
  return { text: remote.toLocaleString(lang, { hour12: false }), zone: label };
}

function transportLabel(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_transport_car');
  if (key.includes('bike')) return translate('live_marker_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_transport_air');
  return translate('live_marker_transport_unknown');
}

function transportSentence(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_desc_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_desc_transport_car');
  if (key.includes('bike')) return translate('live_marker_desc_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_desc_transport_air');
  return translate('live_marker_desc_transport_unknown');
}

function localizeCountry(code) {
  if (!code) return '';
  const normalized = String(code).toUpperCase();
  if (normalized === '??') return normalized;
  const langRaw = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  let locale = langRaw === 'ua' ? 'uk' : langRaw;
  locale = locale.replace('_', '-');
  try {
    if (!regionNameCache[locale]) {
      regionNameCache[locale] = new Intl.DisplayNames([locale], { type: 'region' });
    }
    const label = regionNameCache[locale].of(normalized);
    if (label) return label;
  } catch (err) {
    // Older browsers may not support Intl.DisplayNames; fall back to the code below.
  }
  return normalized;
}

function describeLiveSensor(marker) {
  // We use bracket placeholders (e.g. [[name]]) so the Go template parser leaves
  // them untouched while still allowing readable replacement in the browser.
  const subject = marker.deviceName
    ? translate('live_marker_desc_named').replace('[[name]]', escapeHtml(marker.deviceName))
    : translate('live_marker_desc_generic');
  const placeName = marker.country ? localizeCountry(marker.country) : '';
  const place = placeName
    ? translate('live_marker_desc_location').replace('[[place]]', escapeHtml(placeName))
    : translate('live_marker_desc_location_unknown');
  const transport = transportSentence(marker.transport);
  const sensorName = marker.tube || marker.deviceName || '';
  const tube = sensorName
    ? translate('live_marker_desc_tube').replace('[[tube]]', escapeHtml(sensorName))
    : translate('live_marker_desc_no_tube');
  return [subject, place, transport, tube].join(' ');
}

function labelForExtraKey(key) {
  switch (key) {
    case 'temperature_c':
      return translate('live_marker_temperature');
    case 'temperature_f':
      return translate('live_marker_temperature_f');
    case 'humidity_percent':
      return translate('live_marker_humidity');
    case 'pressure_hpa':
      // Safecast Airnote units expose pressure alongside humidity; handling it
      // here keeps the legend consistent with the live charts.
      return translate('live_marker_pressure');
    default:
      return key.replace(/_/g, ' ').replace(/\b\w/g, function(m){ return m.toUpperCase(); });
  }
}

function formatExtraValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return null;
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1) + (key.endsWith('_f') ? ' ¬∞F' : ' ¬∞C');
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0) + ' %';
  }
  if (key === 'pressure_hpa') {
    // Pressure varies slowly, so one decimal keeps the tooltip readable.
    return value.toFixed(1) + ' hPa';
  }
  return value.toFixed(2);
}

// Adding pressure keeps environmental series grouped together for clarity.
const EXTRA_SERIES_ORDER = ['temperature_c', 'temperature_f', 'humidity_percent', 'pressure_hpa'];

function extraUnitSuffix(key) {
  if (key === 'temperature_c') return '¬∞C';
  if (key === 'temperature_f') return '¬∞F';
  if (key === 'humidity_percent') return '%';
  if (key === 'pressure_hpa') return 'hPa';
  return '';
}

function formatExtraAxisValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return '';
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1);
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0);
  }
  if (key === 'pressure_hpa') {
    return value.toFixed(1);
  }
  return value.toFixed(2);
}

function colorForExtraKey(key) {
  // Keep temperature purple and humidity blue to match the requested styling.
  if (key === 'temperature_c' || key === 'temperature_f') return '#8b5cf6';
  if (key === 'humidity_percent') return '#38bdf8';
  if (key === 'pressure_hpa') {
    // Pressure gets a calming blue to distinguish it from humidity's green.
    return '#5c6bc0';
  }
  return '#ab47bc';
}

function sortExtraKeys(keys) {
  return keys.sort(function(a, b) {
    const ai = EXTRA_SERIES_ORDER.indexOf(a);
    const bi = EXTRA_SERIES_ORDER.indexOf(b);
    const av = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
    const bv = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
    if (av === bv) return a.localeCompare(b);
    return av - bv;
  });
}

function hasExtraSeries(series) {
  if (!series || typeof series !== 'object') return false;
  return Object.keys(series).some(function(key){
    return Array.isArray(series[key]) && series[key].length;
  });
}

function renderLiveExtras(extra) {
  if (!extra || typeof extra !== 'object') return '';
  const items = [];
  Object.keys(extra).sort().forEach(function(key){
    const label = labelForExtraKey(key);
    const val = formatExtraValue(key, extra[key]);
    if (!label || !val) return;
    items.push('<li>' + label + ': ' + val + '</li>');
  });
  if (!items.length) return '';
  return '<div><strong>' + translate('live_marker_extra_intro') + ':</strong><ul class="live-extra-list">' + items.join('') + '</ul></div>';
}

function buildDeviceMeta(marker) {
  const rows = [];
  if (marker.deviceName) {
    rows.push('<div><strong>' + translate('live_marker_device_label') + ':</strong> ' + escapeHtml(marker.deviceName) + '</div>');
  }
  if (marker.deviceID) {
    rows.push('<div><strong>' + translate('live_marker_device_id') + ':</strong> ' + escapeHtml(marker.deviceID) + '</div>');
  }
  if (marker.transport) {
    rows.push('<div><strong>' + translate('live_marker_transport') + ':</strong> ' + transportLabel(marker.transport) + '</div>');
  }
  if (marker.tube) {
    rows.push('<div><strong>' + translate('live_marker_detector') + ':</strong> ' + escapeHtml(marker.tube) + '</div>');
  }
  if (marker.country) {
    const localized = localizeCountry(marker.country);
    const display = localized || marker.country;
    rows.push('<div><strong>' + translate('live_marker_country') + ':</strong> ' + escapeHtml(display) + '</div>');
  }
  return rows.join('');
}

// buildRealtimeIcon returns the HTML markup and sizing data for a realtime
// marker.  It handles the three freshness buckets: active (white ring, opaque),
// recent (grey ring, half opacity), and stale (>24h, hidden).
function buildRealtimeIcon(marker, zoomLevel, nowSec) {
  const lastSeen = marker.date || 0;
  if (!lastSeen) return null;

  const ageSec = nowSec - lastSeen;
  if (ageSec > LIVE_RECENT_WINDOW) {
    return null; // drop sensors that have been silent longer than a day
  }

  const active = ageSec <= LIVE_ACTIVE_WINDOW;
  const baseColor = getGradientColor(marker.doseRate);
  const fill = active ? baseColor : colorWithAlpha(baseColor, 0.5);
  const border = active ? '#ffffff' : '#888888';
  const textColor = isDarkColor(active ? baseColor : fill) ? '#ffffff' : '#000000';

  const radius = getRadius(marker.doseRate, zoomLevel) * 1.35;
  const size = radius * 2.8;
  const value = formatMicroRoentgen(marker.doseRate);
  const fontSize = Math.max(Math.round(size * 0.32), 11);
  const heartSize = Math.max(Math.round(size * 0.5), 14);

  const html = `
    <div class="live-marker" style="background:${fill};border:2px solid ${border};color:${textColor};width:${size}px;height:${size}px;font-size:${fontSize}px;">
      <img class="live-marker-heart" src="/static/images/safecast-heart-logo.png" alt="Safecast" style="width:${heartSize}px;"/>
      <div class="live-marker-value">${value}</div>
    </div>`;

  return { html, size, radius };
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 * In single-track view there is no filtering ‚Äî show everything.
 */
function shouldDisplayBySpeed(speed) {
  /* Key line */
  if (isTrackView) return true;        // filter disabled in track view

  const st = loadSpeedFilterState();   // global mode
  if (speed < 0) {                     // Safecast heart markers use negative speed to signal realtime data
    if (!window.realtimeEnabled) {
      // Safety net: when realtime is disabled we never show synthetic negative speeds.
      return false;
    }
    return st.live;
  }
  if (speed >= 70 && speed <= 500) return st.plane;  // ‚úàÔ∏è
  if (speed >= 7  && speed <  70)  return st.car;    // üöó
  /* speed < 7 m/s  ‚Üí pedestrian */
  return st.ped;                                      // üö∂
}


// Compute marker fill opacity based on speed
function getFillOpacity(speed) {
  if (speed <= 5) {
    return 0.6;
  } else if (speed >= 20) {
    return 0.1;
  } else {
    var opacityRange = 0.6 - 0.1;
    var speedRange = 20 - 5;
    var opacityDecreasePerMs = opacityRange / speedRange;
    var speedAboveFive = speed - 5;
    var totalOpacityDecrease = speedAboveFive * opacityDecreasePerMs;
    var currentOpacity = 0.6 - totalOpacityDecrease;
    return currentOpacity;
  }
}

// Decide a translation key for safety based on dose rate (¬µSv/h).
// Using legend thresholds keeps UI consistent and avoids extra strings.
function doseCategory(doseRate) {
  // Map dose rate to safety words using legend thresholds
  if (doseRate <= 0.11) return 'legend_safe';
  if (doseRate <= 0.30) return 'legend_attention';
  return 'legend_danger';
}



// Normalize theme strings so URL/controls agree even if inputs drift.
function normalizeThemePreference(raw) {
  if (!raw) return '';
  const lowered = String(raw).trim().toLowerCase();
  if (lowered === 'dark' || lowered === 'night') return 'dark';
  if (lowered === 'light' || lowered === 'day') return 'light';
  return '';
}

// Read the active theme so shared URLs reflect the actual UI choice.
function getThemePreference() {
  const explicit = normalizeThemePreference(document.documentElement.dataset.theme);
  if (explicit) return explicit;
  const stored = normalizeThemePreference(sessionStorage.getItem('themePreference'));
  if (stored) return stored;
  const media = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
  return media && media.matches ? 'dark' : 'light';
}

// Speed filters are encoded as a comma-separated list for compact sharing.
function serializeSpeedFilterState(state) {
  if (!state) return '';
  const tags = [];
  if (state.live && window.realtimeEnabled) tags.push('live');
  if (state.plane) tags.push('plane');
  if (state.car) tags.push('car');
  if (state.ped) tags.push('ped');
  if (tags.length === 0) return 'none';
  return tags.join(',');
}

// Ensure the speed filter payload is complete even if some toggles are missing.
function normalizeSpeedFilterState(state) {
  const base = { plane: false, car: false, ped: false };
  if (window.realtimeEnabled) {
    base.live = false;
  }
  if (!state || typeof state !== 'object') return base;
  const merged = Object.assign({}, base, state);
  if (!window.realtimeEnabled) {
    delete merged.live;
  }
  return merged;
}

// Parse a URL speed list into explicit toggle state for the UI.
function parseSpeedFilterParam(raw) {
  if (!raw) return null;
  const parts = String(raw)
    .split(',')
    .map(p => p.trim().toLowerCase())
    .filter(Boolean);
  if (parts.length === 1 && parts[0] === 'none') {
    return normalizeSpeedFilterState({});
  }
  const state = {
    plane: parts.includes('plane'),
    car: parts.includes('car'),
    ped: parts.includes('ped')
  };
  if (window.realtimeEnabled) {
    state.live = parts.includes('live');
  }
  return state;
}

// Date filters travel as UNIX seconds so sharing works across locales/timezones.
function parseDateRangeParams(params) {
  if (!params) return null;
  const fromRaw = params.get('from');
  const toRaw = params.get('to');
  if (fromRaw === null || toRaw === null) return null;
  const from = Number(fromRaw);
  const to = Number(toRaw);
  if (!isFinite(from) || !isFinite(to)) return null;
  if (from <= to) return [from, to];
  return [to, from];
}

// Parse the playback flag so shared URLs can request autoplay explicitly.
function parsePlaybackParam(raw) {
  if (!raw) return false;
  const normalized = String(raw).trim().toLowerCase();
  return normalized === '1' || normalized === 'true' || normalized === 'yes' || normalized === 'play';
}

// Helper keeps URL state in sync with the currently active base layer.
function getActiveBaseLayerName() {
  if (mapboxSatellite && map.hasLayer(mapboxSatellite)) {
    return 'Mapbox Satellite';
  }
  if (map.hasLayer(googleSatellite)) {
    return 'Google Satellite';
  }
  return 'OpenStreetMap';
}

// Build the full map state query so every share link mirrors the UI.
function buildMapStateParams() {
  const params = new URLSearchParams();
  const bounds = map.getBounds();
  const layer = getActiveBaseLayerName();
  const minLat = bounds.getSouthWest().lat.toFixed(5);
  const minLon = bounds.getSouthWest().lng.toFixed(5);
  const maxLat = bounds.getNorthEast().lat.toFixed(5);
  const maxLon = bounds.getNorthEast().lng.toFixed(5);
  const zoom = map.getZoom();

  params.set('minLat', minLat);
  params.set('minLon', minLon);
  params.set('maxLat', maxLat);
  params.set('maxLon', maxLon);
  params.set('zoom', zoom);
  params.set('layer', layer);

  const theme = getThemePreference();
  if (theme) {
    params.set('theme', theme);
  }

  const speedState = normalizeSpeedFilterState(loadSpeedFilterState());
  const speedParam = serializeSpeedFilterState(speedState);
  if (speedParam) {
    params.set('speed', speedParam);
  }

  const dateRange = loadDateRangeState();
  if (Array.isArray(dateRange) && dateRange.length === 2 && isFinite(dateRange[0]) && isFinite(dateRange[1])) {
    params.set('from', Math.floor(dateRange[0]));
    params.set('to', Math.floor(dateRange[1]));
  }

  const dateMode = loadDateRangeMode();
  if (dateMode) {
    params.set('dateMode', dateMode);
  }

  if (playbackShareActive) {
    params.set('play', '1');
  }

  return params;
}

// Get current URL params from map state
function getCurrentUrlParams() {
  const params = buildMapStateParams();
  return `?${params.toString()}`;
}

// Persist the last opened view so a fresh browser session resumes the same
// place and zoom, keeping orientation intuitive for returning visitors.
function saveMapViewState() {
  if (!map) return;
  try {
    const center = map.getCenter();
    const layer = getActiveBaseLayerName();
    const state = {
      lat: center.lat,
      lon: center.lng,
      zoom: map.getZoom(),
      layer: layer
    };
    localStorage.setItem(mapViewStorageKey, JSON.stringify(state));
  } catch (err) {
    console.warn('save view failed', err);
  }
}

// Load previously saved coordinates/zoom/layer when available. Corrupted
// payloads simply fall back to null so first-run users stay on defaults.
function loadMapViewState() {
  try {
    const raw = localStorage.getItem(mapViewStorageKey);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (typeof parsed.lat !== 'number' || typeof parsed.lon !== 'number' || typeof parsed.zoom !== 'number') {
      return null;
    }
    return parsed;
  } catch (err) {
    console.warn('load view failed', err);
    return null;
  }
}

// Remember where the user actually is so we can reframe the map once
// radiation markers finish streaming in for the new viewport.
function setStoredUserCenter(lat, lon) {
  storedUserCenter = { lat: lat, lon: lon };
  waitForDangerFit = true;
}
    </script>

    <!-- Map initialization and markers -->
    <script>
var map;
var circleMarkers = {};
// Marker layer groups let us toggle categories without refetching everything.
var markerLayerGroups = null;
// Layer state tracks which view each category was loaded for.
var markerLayerState = null;
// Track the current viewport signature so we only reload on real view changes.
var markerViewKey = '';
// Keep shared render helpers per view so overlap pruning stays consistent.
var markerRenderState = null;
// Persist filter choices so we can avoid reloading base layers on live toggles.
var markerFilterState = null;
// Guard async callbacks so stale marker loads cannot mutate shared loading UI.
var markerLoadToken = 0;
var isTrackView = false;
var osmLayer, googleSatellite, mapboxSatellite;
var trackBounds;
var currentTrackID = null;
const shortLinkBox = document.getElementById('shortLinkDisplay');
let shortLinkTimer = null;
let shortLinkAbort = null;
let lastShortLinkFull = '';
let pendingShortLinkFull = '';
let shortLinkCommitPromise = null;
let shortLinkFocusDelayTimer = null;
let shortLinkPendingUrl = '';
let shortLinkFocusReady = (typeof document.hasFocus === 'function') ? document.hasFocus() : false;
const shortLinkIdleDelayMs = 1200;
const shortLinkFocusDelayMs = 900;
const mapViewStorageKey = 'cim.map.view.v1';
let storedUserCenter = null;
let waitForDangerFit = false;
// Cache short link payloads by target URL so play/pause toggles reuse two entries.
const shortLinkCache = new Map();

/* ---------------------------------------------------------------
 *  refreshDownloadLink() toggles the track download button.
 *  We compute the href lazily so the button is only active when a
 *  track is selected, keeping the default map uncluttered.
 * ---------------------------------------------------------------*/
function refreshDownloadLink() {
  var link = document.getElementById('downloadTrackLink');
  var box  = document.querySelector('.download-track-container');
  if (!link || !box) {
    return;
  }
  if (currentTrackID) {
    // Encode IDs so hyphens and other safe characters keep round-tripping in URLs.
    var encodedTrackID = encodeURIComponent(currentTrackID);
    link.href = '/api/track/' + encodedTrackID + '.json';
    link.setAttribute('download', currentTrackID + '.json');
    box.style.display = 'block';
  } else {
    link.href = '#';
    link.removeAttribute('download');
    box.style.display = 'none';
  }
}

/* ---------------------------------------------------------------
 * Track view playback controls keep the single-track view engaging
 * without forcing the full dataset to render immediately.
 * ---------------------------------------------------------------*/
function setTrackViewPlaybackButtonState(state) {
  if (!trackViewPlaybackButton) {
    return;
  }
  const isPlaying = state === 'playing';
  const labelKey = isPlaying ? 'track_view_pause' : 'track_view_play';
  trackViewPlaybackButton.classList.toggle('is-playing', isPlaying);
  trackViewPlaybackButton.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
  trackViewPlaybackButton.setAttribute('title', translate(labelKey));
  trackViewPlaybackButton.setAttribute('aria-label', translate(labelKey));
}

function refreshTrackViewPlaybackControl() {
  if (!trackViewPlaybackContainer || !trackViewPlaybackButton) {
    return;
  }
  if (currentTrackID) {
    trackViewPlaybackContainer.style.display = 'block';
    if (trackViewPlaybackActive && !trackViewPlaybackPaused) {
      setTrackViewPlaybackButtonState('playing');
    } else {
      setTrackViewPlaybackButtonState('stopped');
    }
  } else {
    trackViewPlaybackContainer.style.display = 'none';
  }
}

// Track view playback control sits where the date slider play button lives.
function createTrackViewPlaybackControl() {
  if (!map) {
    return;
  }
  const TrackCtrl = L.Control.extend({
    onAdd() {
      const div = L.DomUtil.create('div', 'leaflet-control-layers track-playback-control');
      div.innerHTML = `
        <button id="trackPlaybackButton" class="slider-play-btn" type="button">
          ‚ñ∂
        </button>
        <button id="trackPlaybackResetButton" class="slider-play-btn track-reset-btn" type="button">
          ‚Ü∫
        </button>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    }
  });
  const control = new TrackCtrl({ position: 'topleft' });
  control.addTo(map);
  trackViewPlaybackContainer = control.getContainer();
  trackViewPlaybackButton = trackViewPlaybackContainer.querySelector('#trackPlaybackButton');
  const trackViewResetButton = trackViewPlaybackContainer.querySelector('#trackPlaybackResetButton');
  if (trackViewPlaybackButton) {
    trackViewPlaybackButton.addEventListener('click', function () {
      toggleTrackViewPlayback();
    });
  }
  if (trackViewResetButton) {
    trackViewResetButton.setAttribute('title', 'Reset track playback');
    trackViewResetButton.setAttribute('aria-label', 'Reset track playback');
    trackViewResetButton.addEventListener('click', function () {
      resetTrackViewPlaybackForZoom();
      updateMarkers(true);
    });
  }
  refreshTrackViewPlaybackControl();
}

function clearTrackViewPlaybackMarkers() {
  Object.keys(circleMarkers).forEach(function(key) {
    map.removeLayer(circleMarkers[key]);
    delete circleMarkers[key];
  });
}

function renderTrackViewMarker(marker, zoomLevel, index) {
  const isLive = marker && marker.speed < 0;
  let rendered;
  if (isLive) {
    const nowSec = Date.now() / 1000;
    const icon = buildRealtimeIcon(marker, zoomLevel, nowSec);
    if (!icon) {
      return;
    }
    rendered = L.marker([marker.lat, marker.lon], {
      icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
    })
    .addTo(map)
    .bindTooltip(getTooltipContent(marker), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
    .bindPopup(getPopupContent(marker));
  } else {
    rendered = L.circleMarker([marker.lat, marker.lon], {
      radius: getRadius(marker.doseRate, zoomLevel),
      fillColor: getGradientColor(marker.doseRate),
      color: getGradientColor(marker.doseRate),
      weight: 1,
      opacity: getFillOpacity(marker.speed) + 0.1,
      fillOpacity: getFillOpacity(marker.speed)
    })
    .addTo(map)
    .bindTooltip(getTooltipContent(marker), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
    .bindPopup(getPopupContent(marker));
  }

  rendered.doseRate = marker.doseRate;
  rendered.date = marker.date;
  rendered.isRealtime = isLive;
  const trackKey = marker.trackID || currentTrackID || 'track';
  circleMarkers[marker.id || trackKey + ':' + marker.date + ':' + index] = rendered;
}

function renderTrackViewSnapshot() {
  if (!map || !Array.isArray(trackViewMarkers)) {
    return;
  }
  clearTrackViewPlaybackMarkers();
  const zoom = map.getZoom();
  trackViewMarkers.forEach(function(marker, index) {
    renderTrackViewMarker(marker, zoom, index);
  });
}

function createMarkerOverlapPruner(map) {
  // Keep a small per-bucket history so only nearly identical overlaps are pruned.
  const bucketSize = 12;
  const overlapBuckets = new Map();
  const overlapThreshold = 0.2;
  const maxLayers = 3;

  function bucketKey(point) {
    return `${Math.floor(point.x / bucketSize)}:${Math.floor(point.y / bucketSize)}`;
  }

  function isNearOverlap(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const maxRadius = Math.max(a.r, b.r);
    return maxRadius > 0 && dist <= maxRadius * overlapThreshold;
  }

  return function prune(markerKey, lat, lon, radius) {
    if (!markerKey || typeof lat !== 'number' || typeof lon !== 'number') {
      return;
    }
    if (typeof radius !== 'number' || radius <= 0) {
      return;
    }
    const point = map.latLngToLayerPoint([lat, lon]);
    const entry = { key: markerKey, x: point.x, y: point.y, r: radius };
    const key = bucketKey(point);
    let stack = overlapBuckets.get(key);
    if (!stack) {
      stack = [];
      overlapBuckets.set(key, stack);
    }
    stack.push(entry);
    const overlaps = stack.filter(function(candidate) {
      return candidate !== entry && isNearOverlap(candidate, entry);
    });
    if (overlaps.length < maxLayers) {
      return;
    }
    const dropEntry = overlaps[0];
    const dropLayer = circleMarkers[dropEntry.key];
    if (!dropLayer) {
      return;
    }
    // Remove pruned layers from their parent group so they stay hidden.
    if (dropLayer.layerGroupName && markerLayerGroups && markerLayerGroups[dropLayer.layerGroupName]) {
      markerLayerGroups[dropLayer.layerGroupName].removeLayer(dropLayer);
    }
    map.removeLayer(dropLayer);
    delete circleMarkers[dropEntry.key];
    overlapBuckets.set(key, stack.filter(function(candidate) {
      return candidate.key !== dropEntry.key;
    }));
  };
}

function trackViewDelay(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}

function waitTrackViewWhilePaused() {
  if (!trackViewPlaybackPaused) {
    return Promise.resolve();
  }
  return new Promise(function(resolve) {
    trackViewPlaybackResume = resolve;
  });
}

function createTrackViewPlaybackState() {
  return {
    pointIndex: 0,
    generation: trackViewPlaybackGeneration,
  };
}

function normalizeTrackViewPlaybackMarker(marker) {
  if (!marker || typeof marker.lat !== 'number' || typeof marker.lon !== 'number') {
    return null;
  }
  if (typeof marker.doseRate !== 'number') {
    return null;
  }
  if (typeof marker.speed !== 'number' || !isFinite(marker.speed)) {
    marker.speed = 0;
  }
  return marker;
}

async function playTrackViewPoints(state, points) {
  for (let i = state.pointIndex; i < points.length; i++) {
    if (!trackViewPlaybackActive) {
      return;
    }
    if (state.generation !== trackViewPlaybackGeneration) {
      return;
    }
    if (trackViewPlaybackPaused) {
      await waitTrackViewWhilePaused();
      if (!trackViewPlaybackActive) {
        return;
      }
      if (state.generation !== trackViewPlaybackGeneration) {
        return;
      }
    }
    renderTrackViewMarker(points[i], map.getZoom(), i);
    state.pointIndex = i + 1;
    await trackViewDelay(trackViewPlaybackConfig.pointDelayMs);
    if (state.generation !== trackViewPlaybackGeneration) {
      return;
    }
  }
}

function stopTrackViewPlayback(refreshMarkers) {
  if (!trackViewPlaybackActive && !trackViewPlaybackPaused) {
    return;
  }
  trackViewPlaybackActive = false;
  trackViewPlaybackPaused = false;
  if (trackViewPlaybackResume) {
    trackViewPlaybackResume();
    trackViewPlaybackResume = null;
  }
  setTrackViewPlaybackButtonState('stopped');
  if (refreshMarkers) {
    renderTrackViewSnapshot();
  }
}

async function startTrackViewPlayback() {
  if (!currentTrackID) {
    return;
  }
  if (!Array.isArray(trackViewMarkers) || !trackViewMarkers.length) {
    return;
  }
  trackViewPlaybackGeneration += 1;
  trackViewPlaybackActive = true;
  trackViewPlaybackPaused = false;
  setTrackViewPlaybackButtonState('playing');

  if (markerStreamSource) {
    markerStreamSource.close();
  }
  clearTrackViewPlaybackMarkers();

  trackViewPlaybackState = createTrackViewPlaybackState();
  const playbackGeneration = trackViewPlaybackState.generation;
  try {
    // Sort by timestamp so playback always runs from the first marker to the last.
    const normalized = trackViewMarkers
      .map(normalizeTrackViewPlaybackMarker)
      .filter(Boolean)
      .sort(function(a, b) {
        const aDate = typeof a.date === 'number' ? a.date : 0;
        const bDate = typeof b.date === 'number' ? b.date : 0;
        return aDate - bDate;
      });
    await playTrackViewPoints(trackViewPlaybackState, normalized);
  } catch (err) {
    return;
  } finally {
    if (playbackGeneration === trackViewPlaybackGeneration) {
      stopTrackViewPlayback(true);
    }
  }
}

function toggleTrackViewPlayback() {
  if (trackViewPlaybackActive && !trackViewPlaybackPaused) {
    trackViewPlaybackPaused = true;
    setTrackViewPlaybackButtonState('paused');
    return;
  }
  if (trackViewPlaybackActive && trackViewPlaybackPaused) {
    trackViewPlaybackPaused = false;
    setTrackViewPlaybackButtonState('playing');
    if (trackViewPlaybackResume) {
      trackViewPlaybackResume();
      trackViewPlaybackResume = null;
    }
    return;
  }
  startTrackViewPlayback();
}

function resetTrackViewPlaybackForZoom() {
  if (!isTrackView || !currentTrackID) {
    return;
  }
  // Zooming changes the visible bounds, so clear state before re-streaming.
  trackViewPlaybackGeneration += 1;
  stopTrackViewPlayback(false);
  trackViewAutoplayRequested = true;
  trackViewAutoplayDone = false;
  trackViewMarkers = [];
  trackViewMarkersReady = false;
  clearTrackViewPlaybackMarkers();
}

function startTrackViewAutoplayAfterReload() {
  if (!isTrackView || !currentTrackID) {
    return;
  }
  if (!Array.isArray(trackViewMarkers) || !trackViewMarkers.length) {
    return;
  }
  // After a reload, always auto-play so the refreshed viewport is visible.
  trackViewAutoplayRequested = true;
  trackViewAutoplayDone = true;
  startTrackViewPlayback();
}

function maybeAutoplayTrackViewPlayback() {
  if (!trackViewAutoplayRequested || trackViewAutoplayDone) {
    return;
  }
  if (!currentTrackID || !map) {
    return;
  }
  if (trackViewPlaybackActive || trackViewPlaybackPaused) {
    trackViewAutoplayDone = true;
    return;
  }
  if (!Array.isArray(trackViewMarkers) || !trackViewMarkers.length) {
    return;
  }
  trackViewAutoplayDone = true;
  startTrackViewPlayback();
}

// New controller to cancel previous request
var markerStreamSource = null;
var trackPlaybackActive = false;
var playbackMarkersRendered = false;
// Playback sharing flags keep URL state aligned with the active play button.
let playbackShareActive = false;
// Autoplay flags capture URL intent and ensure we trigger playback only once.
let playbackAutoplayRequested = false;
let playbackAutoplayDone = false;
// Track view playback flags avoid auto-starting more than once per page load.
let trackViewAutoplayRequested = false;
let trackViewAutoplayDone = false;
let trackViewPlaybackPaused = false;
let trackViewPlaybackResume = null;
let trackViewPlaybackActive = false;
// Generation guards stop in-flight playback loops when a new viewport starts.
let trackViewPlaybackGeneration = 0;
const trackViewPlaybackConfig = { pointDelayMs: 70 };
let trackViewPlaybackButton = null;
let trackViewPlaybackContainer = null;
let trackViewMarkers = [];
let trackViewMarkersReady = false;
let trackViewReloadTimer = null;

var liveHistoryCache = new Map();


/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return defaults that reflect backend capabilities.
 *   Realtime on:  live icon on, ‚úàÔ∏è off, üöó on, üö∂ on  (as requested).
 *   Realtime off: ‚úàÔ∏è off, üöó on, üö∂ on  (heart absent).
 */
function loadSpeedFilterState() {
  // We derive defaults from the realtime flag so the UI matches backend capabilities.
  const base = { plane: false, car: true, ped: true };
  // Only enable live markers by default when the server explicitly allows it.
  if (window.realtimeEnabled && window.realtimeDefault) {
    base.live = true;
  }
  try {
    const raw = sessionStorage.getItem('speedFilterState');
    const st = raw ? JSON.parse(raw) : {};
    const merged = Object.assign({}, base, st);
    if (!window.realtimeEnabled) {
      delete merged.live;
    }
    return merged;
  } catch (e) {
    return base;
  }
}

// ---------- helpers for time-range state ------------------------
function loadDateRangeState() {
  try { return JSON.parse(sessionStorage.getItem('dateRangeState')) || null; }
  catch(e){ return null; }
}
function saveDateRangeState(st) {
  sessionStorage.setItem('dateRangeState', JSON.stringify(st));
}
// Remember the slider mode so shared URLs can restore the same range selector.
function loadDateRangeMode() {
  const mode = sessionStorage.getItem('dateRangeMode');
  return mode === 'year' || mode === 'month' ? mode : '';
}
function saveDateRangeMode(mode) {
  if (mode === 'year' || mode === 'month') {
    sessionStorage.setItem('dateRangeMode', mode);
  }
}

/**
 * Return a "Month YYYY" string in the browser locale.
 * Chrome/Firefox often display "Aug 2025",
 * Safari shows "Aug 2025", etc.
 */
function tsToNiceStr(ts){
  return new Date(ts * 1000)
    .toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}


// absolute month difference between two unix timestamps
function monthsApart(ts0, ts1){
  const d0 = new Date(ts0 * 1000);
  const d1 = new Date(ts1 * 1000);
  return Math.abs((d1.getFullYear() - d0.getFullYear()) * 12 +
    (d1.getMonth()     - d0.getMonth()));
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user‚Äôs choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
  // Persist only supported options so stale realtime toggles do not leak between sessions.
  const toSave = Object.assign({}, state);
  if (!window.realtimeEnabled) {
    delete toSave.live;
  }
  sessionStorage.setItem('speedFilterState', JSON.stringify(toSave));
}

/**
 * Attach a lightweight tooltip to a control so every hint shares one theme-aware renderer.
 * We return show/hide/destroy handlers to let callers reuse a single tooltip while controls collapse.
 */
function attachControlTooltip(target, options) {
  if (!target) {
    return {
      hide: function noopHide() {},
      destroy: function noopDestroy() {},
    };
  }

  const opts = Object.assign({
    placement: 'top',
    html: false,
    maxWidth: 280,
    shouldShow: null,
  }, options || {});

  let tooltipEl = null;

  function resolveContent() {
    const content = typeof opts.content === 'function' ? opts.content() : opts.content;
    return content || '';
  }

  function positionTooltip() {
    if (!tooltipEl || !target) {
      return;
    }
    const rect = target.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return;
    }
    const tipRect = tooltipEl.getBoundingClientRect();
    const margin = 10;
    let left = rect.left + (rect.width / 2) - (tipRect.width / 2);
    let top = rect.top - tipRect.height - margin;

    switch (opts.placement) {
      case 'bottom':
        top = rect.bottom + margin;
        left = rect.left + (rect.width / 2) - (tipRect.width / 2);
        break;
      case 'left':
        left = rect.left - tipRect.width - margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      case 'right':
        left = rect.right + margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      default:
        // keep default top placement
        break;
    }

    const viewportPadding = 8;
    left = Math.max(viewportPadding, Math.min(left, window.innerWidth - tipRect.width - viewportPadding));
    top = Math.max(viewportPadding, Math.min(top, window.innerHeight - tipRect.height - viewportPadding));
    tooltipEl.style.left = left + 'px';
    tooltipEl.style.top = top + 'px';
  }

  function showTooltip() {
    if (!target || !target.isConnected) {
      return;
    }
    const rects = target.getClientRects();
    if (!rects || rects.length === 0) {
      return;
    }
    // Allow callers to suppress tooltips during modal states like playback.
    if (typeof opts.shouldShow === 'function' && !opts.shouldShow()) {
      return;
    }
    const content = resolveContent();
    if (!content) {
      return;
    }
    if (tooltipEl) {
      if (opts.html) {
        tooltipEl.innerHTML = content;
      } else {
        tooltipEl.textContent = content;
      }
      positionTooltip();
      return;
    }
    tooltipEl = document.createElement('div');
    tooltipEl.className = 'control-tooltip';
    tooltipEl.setAttribute('role', 'tooltip');
    const maxWidth = typeof opts.maxWidth === 'number' ? opts.maxWidth + 'px' : opts.maxWidth;
    tooltipEl.style.maxWidth = maxWidth;
    if (opts.html) {
      tooltipEl.innerHTML = content;
    } else {
      tooltipEl.textContent = content;
    }
    document.body.appendChild(tooltipEl);
    positionTooltip();
    window.addEventListener('scroll', positionTooltip, true);
    window.addEventListener('resize', positionTooltip);
    requestAnimationFrame(function () {
      if (tooltipEl) {
        tooltipEl.classList.add('control-tooltip--visible');
      }
    });
  }

  function hideTooltip() {
    if (!tooltipEl) {
      return;
    }
    window.removeEventListener('scroll', positionTooltip, true);
    window.removeEventListener('resize', positionTooltip);
    const el = tooltipEl;
    tooltipEl = null;
    el.classList.remove('control-tooltip--visible');
    setTimeout(function () {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    }, 150);
  }

  function destroyTooltip() {
    hideTooltip();
    target.removeEventListener('mouseenter', showTooltip);
    target.removeEventListener('mouseleave', hideTooltip);
    target.removeEventListener('focus', showTooltip);
    target.removeEventListener('blur', hideTooltip);
    target.removeEventListener('keydown', onKeyDown);
  }

  function onKeyDown(ev) {
    if (ev.key === 'Escape') {
      hideTooltip();
    }
  }

  target.addEventListener('mouseenter', showTooltip);
  target.addEventListener('mouseleave', hideTooltip);
  target.addEventListener('focus', showTooltip);
  target.addEventListener('blur', hideTooltip);
  target.addEventListener('keydown', onKeyDown);

  return {
    show: showTooltip,
    hide: hideTooltip,
    destroy: destroyTooltip,
  };
}


document.addEventListener('DOMContentLoaded', function () {

  // Initialize trackID from path while allowing dashes and URL-escaped segments.
  var match = window.location.pathname.match(/^\/trackid\/([^/?#]+)/);
  if (match) {
    currentTrackID = decodeURIComponent(match[1]);
    isTrackView = true;
    trackViewAutoplayRequested = true;
    // NEW: show back button immediately
    var backBox = document.querySelector('.back-to-all-container');
    if (backBox) backBox.style.display = 'block';
  }
  refreshDownloadLink();
  refreshTrackViewPlaybackControl();

  // Theme-aware hover hints keep visitors oriented without repeating markup titles.
  var uploadLabel = document.querySelector('.upload-btn');
  attachControlTooltip(uploadLabel, {
    placement: 'left',
    content: function () { return translate('upload_button_tooltip'); },
    maxWidth: 320,
  });

  var locateBtn = document.getElementById('locateButton');
  attachControlTooltip(locateBtn, {
    placement: 'left',
    content: function () { return translate('locate_button_tooltip'); },
  });

  var qrBtn = document.getElementById('qrButton');
  attachControlTooltip(qrBtn, {
    placement: 'left',
    content: function () { return translate('qr_button_tooltip'); },
  });

  var themeToggle = document.getElementById('themeToggle');
  attachControlTooltip(themeToggle, {
    placement: 'left',
    content: function () { return translate('theme_toggle_tooltip'); },
    maxWidth: 260,
  });

  var shortLink = document.getElementById('shortLinkDisplay');
  if (shortLink) {
    var shortLinkHandle = attachControlTooltip(shortLink, {
      placement: 'bottom',
      content: function () { return translate('short_link_tooltip'); },
      maxWidth: 260,
    });
    window.__hideShortLinkHint = shortLinkHandle.hide;
  }

  var legendBox = document.getElementById('legend');
  if (legendBox) {
    var legendHandle = attachControlTooltip(legendBox, {
      placement: 'left',
      content: function () { return translate('legend_button_tooltip'); },
      maxWidth: 300,
    });
    window.__hideLegendHint = legendHandle.hide;
    legendBox.addEventListener('keydown', function (ev) {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        openLegendModal();
      }
    });
  }

  var githubLink = document.querySelector('.github-link');
  if (githubLink && window.showGithubLinkTooltip) {
    var githubHandle = attachControlTooltip(githubLink, {
      placement: 'top',
      html: true,
      maxWidth: 320,
      content: function () {
        var version = '{{ .Version }}';
        var title = translate('github_link_tooltip_title');
        var desc = translate('github_link_tooltip_desc');
        var versionText = translate('github_link_tooltip_version');
        if (typeof versionText === 'string' && versionText.indexOf('{version}') !== -1) {
          versionText = versionText.replace('{version}', version);
        }
        return '<div class="control-tooltip__title">' + title + '</div>' +
          '<div>' + desc + '</div>' +
          '<div class="control-tooltip__meta">' + versionText + '</div>';
      },
    });
    window.__hideGithubHint = githubHandle.hide;
    githubLink.addEventListener('click', function () {
      githubHandle.hide();
    });
  }

  // Initialize layers and auto theme switch
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const osmLight = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const osmDark  = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  window.osmLight = osmLight; // expose for theme toggle
  window.osmDark  = osmDark;  // expose for theme toggle
  // Google tiles always use satellite imagery for consistent look
  const googleSat   = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';
  // Mapbox tiles require an access token, so we build the URL only when provided.
  const mapboxToken = (window.mapboxToken || '').trim();
  const mapboxSat   = mapboxToken
    ? `https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}@2x?access_token=${mapboxToken}`
    : '';

  osmLayer = L.tileLayer(media.matches ? osmDark : osmLight, {
    maxZoom: 18,
    attribution: '&copy; OSM contributors'
  });

  // Use the same satellite layer regardless of theme
  googleSatellite = L.tileLayer(googleSat, {
    maxZoom: 20,
    attribution: '&copy; Google',
    className: 'google-satellite-layer' // Apply theme-aware styling to satellite tiles.
  });
  // Mapbox Satellite is optional because the tiles require a token.
  mapboxSatellite = mapboxSat ? L.tileLayer(mapboxSat, {
    maxZoom: 20,
    attribution: '&copy; Mapbox',
    className: 'google-satellite-layer' // Reuse the satellite styling so it matches our theme tweaks.
  }) : null;

  // right after creating osmLayer and googleSatellite
  const urlParams       = new URLSearchParams(window.location.search);
  const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
  let startLayer        = osmLayer;
  if (startLayerName === 'Google Satellite') {
    startLayer = googleSatellite;
  } else if (startLayerName === 'Mapbox Satellite' && mapboxSatellite) {
    startLayer = mapboxSatellite;
  }

  map = L.map('map', {
    center: [defaultCfg.lat, defaultCfg.lon],
    zoom  : defaultCfg.zoom,
    layers: [startLayer],           // only one base layer
  });

  // Keep the attribution prefix short so Chicha appears before Leaflet and tiles.
  if (map.attributionControl) {
    // Pin the short attribution link to the canonical repository even if branding overrides the logo link.
    var chichaHref = 'https://github.com/matveynator/chicha-isotope-map';
    map.attributionControl.setPrefix(
      '<a href=\"' + chichaHref + '\" target=\"_blank\" rel=\"noopener noreferrer\">chicha</a> | ' +
      '<a href=\"https://leafletjs.com\" target=\"_blank\" rel=\"noopener noreferrer\">Leaflet</a>'
    );
  }

  // Layer control
  var baseLayers = {
    "OpenStreetMap": osmLayer,
    "Google Satellite": googleSatellite
  };
  if (mapboxSatellite) {
    baseLayers["Mapbox Satellite"] = mapboxSatellite;
  }

  L.control.layers(baseLayers, null, {
    position: 'topleft',
    collapsed: false
  }).addTo(map);

  // Add custom attribution links that open informative popups
  map.attributionControl.addAttribution(
		'<a href="#" class="attr-link" data-info="api">' + translate('attr_api') + '</a> | ' + 
    '<a href="#" class="attr-link" data-info="legal">' + translate('attr_legal') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="sources">' + translate('attr_sources') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="license">' + translate('attr_license') + '</a>'
  );

  // Track view initialization
  // Inject markers as literal JSON so the first render avoids the template parse error
  // and the frontend can inspect the slice immediately.
  var initialMarkers = {{ .MarkersJSON }};
  if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
    isTrackView = true;

    // Don't show initialMarkers immediately; load them in parts via get_markers
    map.on('load', debounceUpdateMarkers);

    // Adjust marker size on zoom
    map.on('zoomend', function() {
      adjustMarkerRadius();
      scheduleTrackViewReload();
    });
    map.on('moveend', scheduleTrackViewReload);
  } else {
    // Dynamic marker updates in global mode
    map.on('load', debounceUpdateMarkers);
    map.on('zoomend', function() {
      adjustMarkerRadius();
      if (trackPlaybackActive || playbackMarkersRendered) {
        // Playback dots are transient; after viewport changes we must restore canonical marker rendering.
        stopPlayback(true);
        return;
      }
      debounceUpdateMarkers();
    });
    map.on('moveend', function() {
      if (trackPlaybackActive || playbackMarkersRendered) {
        // Panning changes visible bounds, so replay overlays must be discarded before reloading markers.
        stopPlayback(true);
        return;
      }
      debounceUpdateMarkers();
    });
    debounceUpdateMarkers;
  }

  // Load map state from URL
  loadMapFromUrl();

  // Update URL on map changes
  map.on('baselayerchange', updateUrl);
  map.on('moveend', updateUrl);
  map.on('zoomend', updateUrl);

  // Initialize UI elements
  initializeUIElements();

  // Periodically refresh realtime styling so markers fade without map motion.
  setInterval(adjustMarkerRadius, 60 * 1000);

  /**
   * Build a Leaflet control with three check-boxes that filter markers
   * by recorded speed. Labels now show speed in km/h instead of m/s.
   * Default state (when realtime exists): live icon on, ‚úàÔ∏è off, üöó on, üö∂ on.
   */
  function createSpeedFilterControls() {

    if (isTrackView) return;   // hidden in track view

    // load previously saved state (or defaults)
    const state = loadSpeedFilterState();

    // custom Leaflet control
    const SpeedCtrl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-control-layers');
        div.style.padding = '6px 10px';

        // helper that returns one <label> line
        const row = (id, iconMarkup, checked, extraClass = '') => `
            <label style="white-space:nowrap;display:block;cursor:pointer;">
            <input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
            <span class="speed-filter-icon ${extraClass}">${iconMarkup}</span>
            </label>`;

        // Build rows dynamically so the realtime checkbox only appears when supported server-side.
        const pieces = [];
        if (window.realtimeEnabled) {
          // Use the Safecast heart artwork so the live toggle reflects the new branding.
          const liveIconMarkup = '<img src="/static/images/safecast-heart-logo.png" alt="Realtime measurements" style="width:1em; height:1em; vertical-align:middle;"/> realtime';
          pieces.push(row('sfLive', liveIconMarkup, state.live));
          pieces.push('<div class="leaflet-control-layers-separator"></div>');
        }
        pieces.push(
          row('sfPlane', '‚úàÔ∏è', state.plane, 'speed-filter-icon--mono'),
          row('sfCar',   'üöó', state.car,   'speed-filter-icon--mono'),
          row('sfPed',   'üö∂', state.ped,   'speed-filter-icon--mono')
        );
        div.innerHTML = pieces.join('');

        // We collect all checkboxes so keyboard focus and pointer use can share a single tooltip instance.
        const checkboxes = Array.from(div.querySelectorAll('input[type=checkbox]'));

        // Attach an explanatory tooltip so visitors understand how each checkbox slices the dataset by speed.
        const speedTooltipHandle = attachControlTooltip(div, {
          placement: 'right',
          html: true,
          maxWidth: 340,
          content: function () {
            const title = translate('speed_filter_tooltip_title');
            const intro = translate('speed_filter_tooltip_intro');
            const accuracy = translate('speed_filter_tooltip_accuracy');
            const lines = [];
            if (window.realtimeEnabled) {
              lines.push('Realtime: live radiation data stream. Toggle to show or hide live readings.');
            }
            lines.push(translate('speed_filter_tooltip_plane'));
            lines.push(translate('speed_filter_tooltip_car'));
            lines.push(translate('speed_filter_tooltip_ped'));
            const listHtml = lines.map(function (line) {
              return '<li>' + line + '</li>';
            }).join('');
            return '<div class="control-tooltip__title">' + title + '</div>' +
              '<div>' + intro + '</div>' +
              '<ul class="control-tooltip__list">' + listHtml + '</ul>' +
              '<div class="control-tooltip__meta">' + accuracy + '</div>';
          },
        });

        // Keyboard users focus the individual checkboxes, so we mirror the combined tooltip when inputs gain focus.
        checkboxes.forEach(cb => {
          cb.addEventListener('focus', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.show === 'function') {
              speedTooltipHandle.show();
            }
          });
          cb.addEventListener('blur', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.hide === 'function') {
              speedTooltipHandle.hide();
            }
          });
        });

        // prevent map drag/zoom while clicking inside the control
        L.DomEvent.disableClickPropagation(div);

        // attach change-handlers
        checkboxes.forEach(cb => {
          cb.addEventListener('change', () => {
            const prevState = cloneMarkerFilterState(state);
            if (window.realtimeEnabled) {
              state.live = div.querySelector('#sfLive').checked;
            } else {
              delete state.live;
            }
            state.plane = div.querySelector('#sfPlane').checked;
            state.car   = div.querySelector('#sfCar').checked;
            state.ped   = div.querySelector('#sfPed').checked;
            saveSpeedFilterState(state);   // remember choice
            if (shouldOnlyToggleLive(prevState, state)) {
              updateLiveLayerOnly(state);  // refresh only realtime markers
            } else {
              debounceUpdateMarkers();     // redraw with new filter
            }
            updateUrl();                   // keep share links aligned with filters
          });
        });

        return div;
      }
    });

    new SpeedCtrl({ position: 'topleft' }).addTo(map);
  }



  // Call it
  createSpeedFilterControls();   
  createDateRangeSlider();



});


/**
 * Date-range control with two modes:
 *  - YEAR (single handle): labels show full [minYear..maxYear] when NO user filter is active,
 *    otherwise they show [chosenYear..maxYear].
 *  - MONTH (double handle): classic [from..to] range.
 *
 * Key ideas:
 *  ‚Ä¢ We expose window.__setDateSliderVisibility(show)
 *  ‚Ä¢ We expose window.__initSliderOnce(minTs,maxTs) for first build
 *  ‚Ä¢ We expose window.__syncDateSliders(minTs,maxTs) to keep ranges/labels
 *    in sync with the current map viewport on every pan/zoom IF no custom
 *    time filter is set by the user.
 *
 * No globals except 3 window.* hooks; no vendor APIs beyond noUiSlider.
 */
function createDateRangeSlider(){

  if (isTrackView) return;   // no date control in single-track mode

  let sliderBox, yearSlider, monthSlider;
  // Default to the last known mode so shared links keep the same UI affordance.
  let mode  = loadDateRangeMode() || 'year';                // 'year' | 'month'
  saveDateRangeMode(mode); // persist default so URL state stays explicit
  updateUrl(); // publish the default mode before any slider interaction
  let initY = false, initM = false;  // lazy init flags
  let sliderTooltipHandle = null;    // tooltip helper for hover hints

  // We store the "full range" of current viewport to detect
  // whether a saved filter is actually "show all".
  let fullRange = null; // [minTs,maxTs]

  // Clamp saved ranges to the visible data bounds so shared links reopen faithfully.
  function normalizeSavedRange(saved, minTs, maxTs) {
    if (!Array.isArray(saved) || saved.length !== 2) return null;
    const rawStart = Number(saved[0]);
    const rawEnd = Number(saved[1]);
    if (!isFinite(rawStart) || !isFinite(rawEnd)) return null;
    const start = Math.max(Math.min(rawStart, rawEnd), minTs);
    const end = Math.min(Math.max(rawStart, rawEnd), maxTs);
    if (!isFinite(start) || !isFinite(end)) return null;
    return [start, end];
  }

  // Keep slider handles aligned with the saved range without triggering redundant work.
  function rangesMatch(current, next) {
    if (!Array.isArray(current) || !Array.isArray(next) || current.length !== 2 || next.length !== 2) return false;
    return Math.abs(Number(current[0]) - Number(next[0])) < 1 && Math.abs(Number(current[1]) - Number(next[1])) < 1;
  }

  // Apply a saved range to both sliders so URL-driven views feel consistent.
  function syncSlidersToRange(savedRange, minTs, maxTs) {
    const normalized = normalizeSavedRange(savedRange, minTs, maxTs);
    if (!normalized) return null;
    if (monthSlider && monthSlider.noUiSlider) {
      const current = monthSlider.noUiSlider.get().map(Number);
      if (!rangesMatch(current, normalized)) {
        monthSlider.noUiSlider.set(normalized);
      }
    }
    if (yearSlider && yearSlider.noUiSlider) {
      const year = new Date(normalized[0] * 1000).getUTCFullYear();
      const currentYear = Number(yearSlider.noUiSlider.get());
      if (!isFinite(currentYear) || currentYear !== year) {
        yearSlider.noUiSlider.set(year);
      }
    }
    return normalized;
  }

  const DateCtrl = L.Control.extend({
    onAdd(){
      sliderBox = L.DomUtil.create('div','leaflet-control-layers date-slider-box');
      sliderBox.style.display = 'none'; // hidden until needed
      sliderBox.innerHTML = `
        <div class="slider-toggle">
          <button id="btnYear"  class="active">Y</button>
          <button id="btnMonth">M</button>
        </div>
        <div id="lblMax" class="slider-label"></div>
        <div id="yearSlider"></div>
        <div id="dateSlider"></div>
        <div id="lblMin" class="slider-label"></div>
        <div class="slider-actions">
          <button id="btnPlay" class="slider-play-btn" title="${translate('date_slider_play')}" aria-label="${translate('date_slider_play')}">‚ñ∂</button>
          <button id="btnReset" class="slider-reset-btn" title="Reset"> ‚ü≤ </button>
        </div>
      `;
      sliderBox.setAttribute('role', 'group');
      sliderBox.setAttribute('tabindex', '0');
      sliderBox.setAttribute('aria-label', translate('date_slider_tooltip'));
      sliderTooltipHandle = attachControlTooltip(sliderBox, {
        placement: 'right',
        content: function () { return translate('date_slider_tooltip'); },
        // Hide the slider hint while playback runs so it never obscures the map view.
        shouldShow: function () { return !trackPlaybackActive; },
        maxWidth: 300,
      });
      return sliderBox;
    }
  });
  new DateCtrl({ position:'topleft' }).addTo(map);

  const btnY = sliderBox.querySelector('#btnYear');
  const btnM = sliderBox.querySelector('#btnMonth');
  const btnPlay = sliderBox.querySelector('#btnPlay');
  const btnReset = sliderBox.querySelector('#btnReset');
  const lblMin = () => sliderBox.querySelector('#lblMin');
  const lblMax = () => sliderBox.querySelector('#lblMax');

  btnY.onclick = () => switchMode('year');
  btnM.onclick = () => switchMode('month');
  btnY.classList.toggle('active', mode === 'year');
  btnM.classList.toggle('active', mode === 'month');
  btnPlay.onclick = () => togglePlayback();
  setPlayButtonState('stopped');
  // Allow playback in both year and month modes so the button reflects the active range filter.
  btnPlay.disabled = false;

  // Show/hide the whole control (called from updateMarkers())
  window.__setDateSliderVisibility = (show)=>{
    sliderBox.style.display = show ? 'block' : 'none';
    if(!show) sessionStorage.removeItem('dateRangeState');
    if (!show && sliderTooltipHandle) {
      sliderTooltipHandle.hide();
    }
    if (!show) {
      stopPlayback(true);
    }
  };

  const playbackConfig = {
    pointDelayMs: 20,
    trackDelayMs: 200,
  };
  let playbackAbortController = null;
  let playbackPaused = false;
  let playbackResume = null;
  let playbackState = null;

  // Playback toggles stream markers off and paints one track at a time so movement is readable.
  function setPlayButtonState(state) {
    const isPlaying = state === 'playing';
    const labelKey = isPlaying ? 'date_slider_stop' : 'date_slider_play';
    btnPlay.classList.toggle('is-playing', isPlaying);
    btnPlay.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
    btnPlay.title = translate(labelKey);
    btnPlay.setAttribute('aria-label', translate(labelKey));
    if (playbackShareActive !== isPlaying) {
      // Keep the share URL in sync with the play button state for deep links.
      playbackShareActive = isPlaying;
      if (typeof updateUrl === 'function') {
        updateUrl();
      }
    }
  }

  // Autoplay should only start once, after sliders are ready for playback.
  function maybeStartPlaybackFromUrl() {
    if (!playbackAutoplayRequested || playbackAutoplayDone) {
      return;
    }
    if (trackPlaybackActive || playbackPaused) {
      playbackAutoplayDone = true;
      return;
    }
    if (!sliderBox || sliderBox.style.display === 'none') {
      return;
    }
    playbackAutoplayDone = true;
    togglePlayback();
  }

  function clearPlaybackMarkers() {
    Object.keys(circleMarkers).forEach(function(key) {
      map.removeLayer(circleMarkers[key]);
      delete circleMarkers[key];
    });
    playbackMarkersRendered = false;
  }

  function resolvePlaybackRange() {
    // Month mode should respect the visible month slider even before session storage syncs.
    if (mode === 'month' && monthSlider && monthSlider.noUiSlider) {
      return monthSlider.noUiSlider.get().map(Number);
    }
    const saved = loadDateRangeState();
    if (Array.isArray(saved) && saved.length === 2) {
      return saved;
    }
    if (fullRange && fullRange.length === 2) {
      return fullRange;
    }
    const y = +yearSlider.noUiSlider.get();
    const yearStart = Date.UTC(y, 0, 1) / 1000;
    const yearEnd = Date.UTC(y + 1, 0, 1) / 1000 - 1;
    return [yearStart, yearEnd];
  }

  // Build the speed filter tags once so playback aligns with the UI toggles.
  function buildPlaybackSpeedTags() {
    const state = loadSpeedFilterState();
    const tags = [];
    if (state.ped) tags.push('ped');
    if (state.car) tags.push('car');
    if (state.plane) tags.push('plane');
    return tags;
  }

  // Stream playback markers as NDJSON so tracks can start rendering before
  // the full dataset arrives, avoiding a long wait on large result sets.
  async function streamPlaybackMarkers(signal, speedTags, onTrackReady, onDone) {
    const bounds = map.getBounds();
    const zoom = map.getZoom();
    const range = resolvePlaybackRange();
    const params = new URLSearchParams({
      zoom: zoom,
      minLat: bounds.getSouthWest().lat,
      minLon: bounds.getSouthWest().lng,
      maxLat: bounds.getNorthEast().lat,
      maxLon: bounds.getNorthEast().lng,
      dateFrom: Math.floor(range[0]),
      dateTo: Math.floor(range[1]),
    });
    if (speedTags && speedTags.length) {
      params.set('speeds', speedTags.join(','));
    }

    const resp = await fetch('/stream_playback?' + params.toString(), { signal: signal });
    if (!resp.ok) {
      throw new Error('playback_fetch_failed');
    }
    if (!resp.body) {
      throw new Error('playback_stream_unsupported');
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let currentTrack = null;
    let doneCalled = false;

    function flushTrack() {
      if (currentTrack && currentTrack.points.length) {
        onTrackReady(currentTrack);
      }
      currentTrack = null;
    }

    function finishOnce() {
      if (doneCalled) return;
      doneCalled = true;
      flushTrack();
      onDone();
    }

    try {
      while (true) {
        const chunk = await reader.read();
        if (chunk.done) {
          break;
        }
        buffer += decoder.decode(chunk.value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';
        lines.forEach(function(line) {
          const trimmed = line.trim();
          if (!trimmed) {
            return;
          }
          let marker;
          try {
            marker = JSON.parse(trimmed);
          } catch (e) {
            return;
          }
          if (!marker || !marker.trackID || marker.speed < 0) {
            return;
          }
          if (!shouldDisplayBySpeed(marker.speed)) {
            return;
          }
          if (!currentTrack || currentTrack.trackID !== marker.trackID) {
            flushTrack();
            currentTrack = { trackID: marker.trackID, points: [] };
          }
          currentTrack.points.push(marker);
        });
      }
      if (buffer.trim() !== '') {
        try {
          const marker = JSON.parse(buffer);
          if (marker && marker.trackID && marker.speed >= 0 && shouldDisplayBySpeed(marker.speed)) {
            if (!currentTrack || currentTrack.trackID !== marker.trackID) {
              flushTrack();
              currentTrack = { trackID: marker.trackID, points: [] };
            }
            currentTrack.points.push(marker);
          }
        } catch (e) {
          // Ignore trailing partial JSON chunks so playback can complete cleanly.
        }
      }
    } finally {
      finishOnce();
    }
  }

  function addPlaybackMarker(marker, zoomLevel, index) {
    const markerKey = marker.id || [
      marker.trackID || 'track',
      marker.date,
      marker.lat,
      marker.lon,
      index,
    ].join(':');
    const prevLayer = circleMarkers[markerKey];
    if (prevLayer) {
      // Drop stale layers with the same key so reset/cleanup can always remove every playback marker.
      map.removeLayer(prevLayer);
      delete circleMarkers[markerKey];
    }
    const circle = L.circleMarker([marker.lat, marker.lon], {
      radius: getRadius(marker.doseRate, zoomLevel),
      fillColor: getGradientColor(marker.doseRate),
      color: getGradientColor(marker.doseRate),
      weight: 1,
      opacity: getFillOpacity(marker.speed) + 0.1,
      fillOpacity: getFillOpacity(marker.speed)
    })
    .addTo(map)
    .bindTooltip(getTooltipContent(marker), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
    .bindPopup(getPopupContent(marker));

    circle.doseRate = marker.doseRate;
    circle.date = marker.date;
    circle.isRealtime = false;
    circle.markerKey = markerKey;
    circleMarkers[markerKey] = circle;
    playbackMarkersRendered = true;
  }

  function delay(ms) {
    return new Promise(function(resolve) {
      setTimeout(resolve, ms);
    });
  }

  function waitWhilePaused() {
    if (!playbackPaused) {
      return Promise.resolve();
    }
    return new Promise(function(resolve) {
      playbackResume = resolve;
    });
  }

  // Playback state keeps the queue and pause progress separate from stream IO
  // so playback can start with the first buffered track instead of waiting.
  function createPlaybackState() {
    return {
      queue: [],
      currentTrack: null,
      pointIndex: 0,
      streamDone: false,
      waiter: null,
    };
  }

  function queuePlaybackTrack(state, track) {
    state.queue.push(track);
    if (state.waiter) {
      state.waiter();
      state.waiter = null;
    }
  }

  function markPlaybackStreamDone(state) {
    state.streamDone = true;
    if (state.waiter) {
      state.waiter();
      state.waiter = null;
    }
  }

  function waitForNextTrack(state) {
    if (state.queue.length || state.streamDone) {
      return Promise.resolve();
    }
    return new Promise(function(resolve) {
      state.waiter = resolve;
    });
  }

  async function playTracksSequentially(state) {
    while (trackPlaybackActive) {
      if (!state.currentTrack) {
        if (!state.queue.length) {
          if (state.streamDone) {
            return;
          }
          await waitForNextTrack(state);
          continue;
        }
        state.currentTrack = state.queue.shift();
        state.pointIndex = 0;
      }
      const points = state.currentTrack.points;
      for (let i = state.pointIndex; i < points.length; i++) {
        if (!trackPlaybackActive) {
          return;
        }
        if (playbackPaused) {
          await waitWhilePaused();
          if (!trackPlaybackActive) {
            return;
          }
        }
        addPlaybackMarker(points[i], map.getZoom(), i);
        state.pointIndex = i + 1;
        await delay(playbackConfig.pointDelayMs);
      }
      state.currentTrack = null;
      state.pointIndex = 0;
      if (!state.streamDone || state.queue.length) {
        await delay(playbackConfig.trackDelayMs);
      }
    }
  }

  function stopPlayback(refreshMarkers) {
    const hasPlaybackState = trackPlaybackActive || playbackPaused || playbackMarkersRendered;
    if (!hasPlaybackState) {
      return;
    }
    trackPlaybackActive = false;
    playbackPaused = false;
    if (playbackResume) {
      playbackResume();
      playbackResume = null;
    }
    playbackState = null;
    if (btnPlay) {
      setPlayButtonState('stopped');
    }
    if (playbackAbortController) {
      playbackAbortController.abort();
      playbackAbortController = null;
    }
    clearPlaybackMarkers();
    if (refreshMarkers) {
      debounceUpdateMarkers(true);
    }
  }

  async function togglePlayback() {
    if (trackPlaybackActive && !playbackPaused) {
      playbackPaused = true;
      setPlayButtonState('paused');
      return;
    }
    if (trackPlaybackActive && playbackPaused) {
      playbackPaused = false;
      setPlayButtonState('playing');
      if (playbackResume) {
        playbackResume();
        playbackResume = null;
      }
      return;
    }
    trackPlaybackActive = true;
    playbackPaused = false;
    setPlayButtonState('playing');
    if (sliderTooltipHandle) {
      // Ensure the date slider hint never stays visible once playback begins.
      sliderTooltipHandle.hide();
    }
    if (sliderBox && document.activeElement === sliderBox) {
      sliderBox.blur();
    }
    if (markerStreamSource) {
      markerStreamSource.close();
    }
    clearPlaybackMarkers();
    const controller = new AbortController();
    playbackAbortController = controller;
    try {
      const speedTags = buildPlaybackSpeedTags();
      if (!speedTags.length) {
        stopPlayback(false);
        return;
      }
      playbackState = createPlaybackState();
      const streamPromise = streamPlaybackMarkers(
        controller.signal,
        speedTags,
        function(track) { queuePlaybackTrack(playbackState, track); },
        function() { markPlaybackStreamDone(playbackState); }
      );
      const playbackPromise = playTracksSequentially(playbackState);
      await Promise.all([streamPromise, playbackPromise]);
    } catch (err) {
      if (err && err.name === 'AbortError') {
        return;
      }
    } finally {
      // Restore regular viewport markers after playback so zoomed-out views use merged radii again.
      stopPlayback(true);
    }
  }

  // Keyboard shortcuts for playback are desktop-only to avoid hijacking touch users.
  const desktopShortcutQuery = window.matchMedia('(hover: hover) and (pointer: fine)');

  function isPlaybackShortcutAllowed(event) {
    const target = event.target;
    const tagName = target && target.tagName ? target.tagName.toLowerCase() : '';
    const isEditable = target && target.isContentEditable;
    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select' || isEditable) {
      return false;
    }
    if (!desktopShortcutQuery.matches) {
      return false;
    }
    if (!sliderBox || sliderBox.style.display === 'none' || sliderBox.offsetParent === null) {
      return false;
    }
    return true;
  }

  function isSpaceKey(event) {
    return event.code === 'Space' || event.key === ' ' || event.key === 'Spacebar' || event.keyCode === 32;
  }

  function handlePlaybackShortcut(event) {
    if (!isSpaceKey(event)) {
      return;
    }
    if (!isPlaybackShortcutAllowed(event)) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    togglePlayback();
  }

  function suppressPlaybackShortcutKeyup(event) {
    if (!isSpaceKey(event)) {
      return;
    }
    if (!isPlaybackShortcutAllowed(event)) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
  }

  // Listen once for the map session, keeping the interaction predictable.
  document.addEventListener('keydown', handlePlaybackShortcut, true);
  document.addEventListener('keyup', suppressPlaybackShortcutKeyup, true);

  // One-time creation of both sliders using initial bounds
  window.__initSliderOnce = (minTs,maxTs)=>{
    if (initY && initM) return;
    fullRange = [minTs,maxTs]; // remember initial "full range"
    const savedRange = loadDateRangeState();

    // YEAR slider (single handle)
    if(!initY){
      yearSlider = sliderBox.querySelector('#yearSlider');
      const minYear = new Date(minTs*1000).getUTCFullYear();
      const maxYear = new Date(maxTs*1000).getUTCFullYear();

      noUiSlider.create(yearSlider,{
        start      : minYear,                // the handle can sit anywhere; labels decide what to show
        connect    : [true,false],
        orientation: 'vertical',
        direction  : 'rtl',
        step       : 1,
        range      : { min:minYear, max:maxYear },
        format     : wNumb({ decimals:0 })
      });

      // Update labels:
      //  - If NO user filter or filter equals fullRange ‚Üí show full year bounds.
      //  - Else ‚Üí show [chosen year..max year].
      yearSlider.noUiSlider.on('update', ([y])=>{
        if (mode !== 'year') return;
        const saved = loadDateRangeState();
        const fr = fullRange || [minTs,maxTs];
        const isFull = !saved || (saved[0] === fr[0] && saved[1] === fr[1]);
        if (isFull){
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = r.min;
          lblMax().textContent = r.max;
        } else {
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = y;
          lblMax().textContent = r.max;
        }
      });
      yearSlider.noUiSlider.on('change', updateDateFilter);
      yearSlider.style.display = mode === 'year' ? 'block' : 'none';
      initY = true;
    }

    // MONTH slider (double handle)
    if(!initM){
      monthSlider = sliderBox.querySelector('#dateSlider');
      noUiSlider.create(monthSlider,{
        start       : [minTs,maxTs],
        connect     : true,
        orientation : 'vertical',
        direction   : 'rtl',
        step        : 3600, // 1 hour
        range       : { min:minTs, max:maxTs },
        format      : wNumb({ decimals:0 })
      });
      monthSlider.noUiSlider.on('update', ()=>{
        if (mode !== 'month') return;
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      });
      monthSlider.noUiSlider.on('change', updateDateFilter);
      monthSlider.style.display = mode === 'month' ? 'block' : 'none';
      initM = true;
    }

    // Restore the saved range so shared URLs reopen with matching slider handles.
    syncSlidersToRange(savedRange, minTs, maxTs);

    // Initial labels = full bounds
    if (mode === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      lblMin().textContent = r.min;
      lblMax().textContent = r.max;
    } else {
      lblMin().textContent = tsToNiceStr(minTs);
      lblMax().textContent = tsToNiceStr(maxTs);
    }
    maybeStartPlaybackFromUrl();
  };

  // Sync ranges and labels to the *current* viewport on every pan/zoom,
  // but ONLY when user has not applied a custom time filter.
  window.__syncDateSliders = (minTs,maxTs)=>{
    if (!initY || !initM) return; // not built yet

    // Detect whether user has a custom time filter (not full range).
    const saved = loadDateRangeState();
    const prevFull = fullRange;
    fullRange = [minTs,maxTs]; // update "full" range to the new viewport

    const hasCustom =
      !!saved && !(saved[0] === prevFull?.[0] && saved[1] === prevFull?.[1]) &&
      !(saved[0] === fullRange[0] && saved[1] === fullRange[1]);

    // Update YEAR slider bounds
    const minYear = new Date(minTs*1000).getUTCFullYear();
    const maxYear = new Date(maxTs*1000).getUTCFullYear();
    yearSlider.noUiSlider.updateOptions({
      range: { min:minYear, max:maxYear }
    }, false);

    // Update MONTH slider bounds
    monthSlider.noUiSlider.updateOptions({
      range: { min:minTs, max:maxTs }
    }, false);

    // Keep slider handles aligned with the saved range so deep links stay exact.
    if (saved) {
      syncSlidersToRange(saved, minTs, maxTs);
    }

    // If no custom filter ‚Üí force labels to show full bounds and make month slider span all
    if (!hasCustom){
      if (mode === 'year'){
        const r = yearSlider.noUiSlider.options.range;
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        monthSlider.noUiSlider.set([minTs,maxTs]);
        lblMin().textContent = tsToNiceStr(minTs);
        lblMax().textContent = tsToNiceStr(maxTs);
      }
      // persist that "no filter" means full range
      saveDateRangeState([minTs,maxTs]);
      updateUrl(); // keep the default date range visible in the URL
    }
  };

  // Reset button ‚Üí drop custom filter and show full bounds of the *current* viewport
  btnReset.onclick = ()=>{
    stopPlayback(false);
    // Clear playback-only layers and cached groups so reset always reflects the current viewport.
    clearPlaybackMarkers();
    clearMarkerLayerGroups();
    sessionStorage.removeItem('dateRangeState');
    if (initY && initM){
      const rY = yearSlider.noUiSlider.options.range;
      const rM = monthSlider.noUiSlider.options.range;
      yearSlider.noUiSlider.set(rY.max);      // handle position is cosmetic
      monthSlider.noUiSlider.set([rM.min, rM.max]);

      lblMin().textContent = (mode==='year') ? rY.min : tsToNiceStr(rM.min);
      lblMax().textContent = (mode==='year') ? rY.max : tsToNiceStr(rM.max);

      // remember "no filter" == full range of the viewport
      saveDateRangeState([rM.min, rM.max]);
      updateMarkers(true);
      updateUrl(); // keep reset reflected in shared links
    }
  };

  function switchMode(next){
    if (mode === next) return;

    mode = next;
    saveDateRangeMode(next);
    btnY.classList.toggle('active', next==='year');
    btnM.classList.toggle('active', next==='month');
    yearSlider.style.display  = next==='year'  ? 'block' : 'none';
    monthSlider.style.display = next==='month' ? 'block' : 'none';
    // Keep playback available for both modes so users can animate any chosen range.
    btnPlay.disabled = false;
    if (next !== 'year') {
      stopPlayback(true);
    }

    // Refresh labels on mode switch respecting full/custom state
    const saved = loadDateRangeState();
    const fr = fullRange;
    const isFull = !saved || (fr && saved[0]===fr[0] && saved[1]===fr[1]);

    if (next === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      if (isFull){
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        const y = +yearSlider.noUiSlider.get();
        lblMin().textContent = y;
        lblMax().textContent = r.max;
      }
    } else {
      const r = monthSlider.noUiSlider.options.range;
      if (isFull){
        monthSlider.noUiSlider.set([r.min, r.max]);
        lblMin().textContent = tsToNiceStr(r.min);
        lblMax().textContent = tsToNiceStr(r.max);
      } else {
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      }
    }

    // Do not change filter on mode flip; user intent remains the same
    updateUrl(); // keep the active mode in the shareable URL
  }

  function updateDateFilter(){
    stopPlayback(false);
    // YEAR mode ‚Üí include data from selected year start up to the viewport max date
    if (mode==='year'){
      const y = +yearSlider.noUiSlider.get();
      // The year slider works as [selected year..latest available data].
      const rangeMax = monthSlider?.noUiSlider?.options?.range?.max ?? (fullRange ? fullRange[1] : Date.UTC(y + 1, 0, 1) / 1000 - 1);
      const yearStart = Date.UTC(y, 0, 1) / 1000;
      const rangeMin = fullRange ? fullRange[0] : yearStart;
      const from = Math.max(yearStart, rangeMin);
      saveDateRangeState([from, rangeMax]);
    } else {
      saveDateRangeState(monthSlider.noUiSlider.get().map(Number));
    }
    debounceUpdateMarkers(true);
    updateUrl(); // reflect date filters in the shareable URL
  }
}



// Function definitions

// ---------- Marker popups and tooltips ----------
// Build HTML once so popups and tooltips share identical content.
  function buildLiveMarkerPopup(marker) {
    const doseRate = marker.doseRate || 0;
    const microValue = formatMicroRoentgen(doseRate);
    const doseColor = getGradientColor(doseRate);
    const statusKey = doseCategory(doseRate);
    const statusLabel = translate(statusKey);
    const statusTextColor = isDarkColor(doseColor) ? '#ffffff' : '#000000';
    const milliSievert = `${doseRate.toFixed(3)} ¬µSv/h`;
    const lastSeen = formatDateTime(marker.date);
    const local = approximateLocalTime(marker.lat, marker.lon);
    const extrasRaw = (marker.liveExtra && typeof marker.liveExtra === 'object') ? marker.liveExtra : null;
    const extrasCopy = extrasRaw ? Object.assign({}, extrasRaw) : {};

    const climateParts = [];
    if (extrasRaw) {
      if (typeof extrasRaw.temperature_c === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature'))}: ${escapeHtml(formatExtraValue('temperature_c', extrasRaw.temperature_c))}`);
        delete extrasCopy.temperature_c;
      } else if (typeof extrasRaw.temperature_f === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature_f'))}: ${escapeHtml(formatExtraValue('temperature_f', extrasRaw.temperature_f))}`);
        delete extrasCopy.temperature_f;
      }
      if (typeof extrasRaw.humidity_percent === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_humidity'))}: ${escapeHtml(formatExtraValue('humidity_percent', extrasRaw.humidity_percent))}`);
        delete extrasCopy.humidity_percent;
      }
    }

    const climateHtml = climateParts.length ? `<div class="live-popup-climate">${climateParts.join(' ¬∑ ')}</div>` : '';
    // Tie the chart button styling to the current radiation color so it is
    // obvious that tapping it opens the dose history for this sensor.
    const chartBg = colorWithAlpha(doseColor, 0.18);
    const chartHover = colorWithAlpha(doseColor, 0.28);
    const chartBorder = colorWithAlpha(doseColor, 0.75);
    const chartGlow = colorWithAlpha(doseColor, 0.35);
    const chartFocus = colorWithAlpha(doseColor, 0.7);
    const extrasBlock = renderLiveExtras(extrasCopy);
    const deviceID = marker.deviceID || (marker.trackID ? marker.trackID.replace(/^live:/, '') : '');
    const attrs = [];
    if (deviceID) attrs.push(`data-device="${escapeHtml(deviceID)}"`);
    if (marker.deviceName) attrs.push(`data-name="${escapeHtml(marker.deviceName)}"`);
    if (marker.transport) attrs.push(`data-transport="${escapeHtml(marker.transport)}"`);
    if (marker.tube) attrs.push(`data-tube="${escapeHtml(marker.tube)}"`);
    if (marker.country) attrs.push(`data-country="${escapeHtml(marker.country)}"`);
    if (typeof marker.lat === 'number') attrs.push(`data-lat="${marker.lat}"`);
    if (typeof marker.lon === 'number') attrs.push(`data-lon="${marker.lon}"`);
    const chartLink = deviceID ? `<div><button type="button" class="live-chart-link live-chart-button" style="--live-chart-bg:${chartBg};--live-chart-hover:${chartHover};--live-chart-border:${chartBorder};--live-chart-glow:${chartGlow};--live-chart-text:${statusTextColor};--live-chart-focus:${chartFocus};" ${attrs.join(' ')}><span class="live-chart-icon" aria-hidden="true">üìà</span><span>${translate('live_marker_chart_link')}</span></button></div>` : '';

    const metaBits = [];
    metaBits.push(`<div><strong>${translate('live_marker_last_seen')}:</strong> ${escapeHtml(lastSeen)}</div>`);
    if (local) {
      metaBits.push(`<div><strong>${translate('live_marker_local_time')}:</strong> ${escapeHtml(local.text)} (${escapeHtml(local.zone)})</div>`);
    }
    const deviceMeta = buildDeviceMeta(marker);
    if (deviceMeta) metaBits.push(deviceMeta);
    if (extrasBlock) metaBits.push(extrasBlock);
    if (chartLink) metaBits.push(chartLink);
    const metaHtmlBlock = metaBits.length ? `<div class="live-popup-meta">${metaBits.join('')}</div>` : '';

    return `
      <div class="custom-tooltip live-tooltip">
        <div class="live-tooltip-header">
          <img src="/static/images/safecast-heart-logo.png" alt="Realtime sensor" class="live-tooltip-heart">
          <div>
            <div class="live-tooltip-title">Realtime sensor</div>
            <p class="live-tooltip-desc">${describeLiveSensor(marker)}</p>
          </div>
        </div>
        <div class="live-popup-dose">
          <div class="live-popup-dose-primary" style="color:${doseColor};">
            ${microValue}<span class="live-popup-dose-unit">¬µR/h</span>
          </div>
          <div class="live-popup-dose-secondary" style="color:${doseColor};">
            ${milliSievert}
          </div>
          <div class="live-popup-dose-status" style="background:${doseColor};color:${statusTextColor};">
            <a href="#" class="risk-link" style="color:${statusTextColor};">${escapeHtml(statusLabel)}</a>
          </div>
        </div>
        ${climateHtml}
        ${metaHtmlBlock}
      </div>`;
  }

  function buildMarkerContent(marker) {
    if (marker.speed < 0) {
      return buildLiveMarkerPopup(marker);
    }

    const speedText = (typeof marker.speed === 'number' && isFinite(marker.speed))
      ? `${(marker.speed * 3.6).toFixed(1)} km/h`
      : '‚Äî';

    const deviceName = marker.deviceName ? String(marker.deviceName) : '';
    const deviceLabel = deviceName
      ? `<div><strong>${translate('live_marker_device_label')}:</strong> ${escapeHtml(deviceName)}</div>`
      : '';

    return `
      <div class="custom-tooltip">
        <div><strong>${translate('radiation_dose')}:</strong><br>
          ${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)
          (<a href="#" class="risk-link">
            ${translate(doseCategory(marker.doseRate))}
          </a>)
        </div>
        ${deviceLabel}
        <div><strong>${translate('speed')}:</strong> ${speedText}</div>
        <div style="margin-top:4px">
          <!-- clicking the link switches to track mode -->
          <a href="#" class="track-link" data-track="${marker.trackID}" style="font-weight:bold;">
            ${translate('track_id')}: ${marker.trackID}
          </a>
        </div>
      </div>`;
  }

// Popup reuses shared builder to stay in sync with tooltips.
function getPopupContent(marker) {
  return buildMarkerContent(marker);
}

// Tooltip uses the same builder for hover previews.
function getTooltipContent(marker) {
  return buildMarkerContent(marker);
}


/* ---------------------------------------------------------------
 * Marker layer management keeps speed/realtime toggles isolated so
 * we don't reload unrelated data on each checkbox change.
 * ---------------------------------------------------------------*/
const markerLayerNames = ['ped', 'car', 'plane'];
const markerLiveLayerName = 'live';

function initMarkerLayers() {
  if (markerLayerGroups || !map) {
    return;
  }
  markerLayerGroups = {
    ped: L.layerGroup(),
    car: L.layerGroup(),
    plane: L.layerGroup(),
    live: L.layerGroup(),
  };
  markerLayerState = {
    ped: { loaded: false, viewKey: '', source: null },
    car: { loaded: false, viewKey: '', source: null },
    plane: { loaded: false, viewKey: '', source: null },
    live: { loaded: false, viewKey: '', source: null },
  };
}

function buildMarkerViewKey() {
  if (!map) {
    return '';
  }
  const bounds = map.getBounds();
  const zoom = map.getZoom();
  // Round to fixed precision so minor float drift doesn't thrash reloads.
  return [
    zoom,
    bounds.getSouthWest().lat.toFixed(5),
    bounds.getSouthWest().lng.toFixed(5),
    bounds.getNorthEast().lat.toFixed(5),
    bounds.getNorthEast().lng.toFixed(5),
  ].join('|');
}

function markerLayerEnabled(name, state) {
  if (!state) {
    return false;
  }
  switch (name) {
    case markerLiveLayerName:
      return !!state.live;
    case 'plane':
      return !!state.plane;
    case 'car':
      return !!state.car;
    case 'ped':
      return !!state.ped;
    default:
      return false;
  }
}

function syncMarkerLayerVisibility(state) {
  if (!markerLayerGroups || !map) {
    return;
  }
  const allLayers = markerLayerNames.concat(markerLiveLayerName);
  allLayers.forEach(function(name) {
    const group = markerLayerGroups[name];
    if (!group) {
      return;
    }
    const enabled = markerLayerEnabled(name, state);
    if (enabled && !map.hasLayer(group)) {
      group.addTo(map);
    }
    if (!enabled && map.hasLayer(group)) {
      map.removeLayer(group);
    }
  });
}

function closeMarkerLayerStream(name) {
  if (!markerLayerState || !markerLayerState[name]) {
    return;
  }
  const source = markerLayerState[name].source;
  if (source) {
    source.close();
  }
  markerLayerState[name].source = null;
}

function clearMarkerLayerGroup(name) {
  if (!markerLayerGroups || !markerLayerGroups[name]) {
    return;
  }
  const group = markerLayerGroups[name];
  group.eachLayer(function(layer) {
    if (layer && layer.markerKey && circleMarkers[layer.markerKey]) {
      delete circleMarkers[layer.markerKey];
    }
    if (map && map.hasLayer(layer)) {
      map.removeLayer(layer);
    }
  });
  group.clearLayers();
  if (markerLayerState && markerLayerState[name]) {
    markerLayerState[name].loaded = false;
    markerLayerState[name].viewKey = '';
  }
}

function clearMarkerLayerGroups() {
  if (!markerLayerGroups) {
    return;
  }
  markerLayerNames.concat(markerLiveLayerName).forEach(function(name) {
    closeMarkerLayerStream(name);
    clearMarkerLayerGroup(name);
  });
}

function createMarkerRenderState(zoomLevel) {
  return {
    livePlacement: createLivePlacementGrid(map, zoomLevel),
    pruneOverlap: createMarkerOverlapPruner(map),
    zoom: zoomLevel,
  };
}

function cloneMarkerFilterState(state) {
  if (!state) {
    return null;
  }
  return {
    ped: !!state.ped,
    car: !!state.car,
    plane: !!state.plane,
    live: !!state.live,
  };
}

function baseFiltersChanged(prev, next) {
  if (!prev || !next) {
    return true;
  }
  return !!prev.ped !== !!next.ped || !!prev.car !== !!next.car || !!prev.plane !== !!next.plane;
}

function liveFilterChanged(prev, next) {
  if (!prev || !next) {
    return true;
  }
  return !!prev.live !== !!next.live;
}

function shouldOnlyToggleLive(prev, next) {
  if (!prev || !next) {
    return false;
  }
  // Keep base layers stable when only the live checkbox changes.
  const baseSame = !baseFiltersChanged(prev, next);
  const liveOnly = liveFilterChanged(prev, next);
  return baseSame && liveOnly;
}

function startMarkerLayerStream(layerName, params, viewKey, handlers) {
  if (!params) {
    return;
  }
  initMarkerLayers();
  const state = markerLayerState[layerName];
  if (!state) {
    return;
  }
  closeMarkerLayerStream(layerName);
  const es = new EventSource('/stream_markers?' + params.toString());
  state.source = es;
  state.loaded = false;
  state.viewKey = viewKey || '';
  let streamSummary = null;
  let streamMin = Infinity;
  let streamMax = -Infinity;

  es.onmessage = e => {
    let marker;
    try {
      marker = JSON.parse(e.data);
    } catch (err) {
      return;
    }
    if (!marker) {
      return;
    }
    if (typeof marker.date === 'number') {
      streamMin = Math.min(streamMin, marker.date);
      streamMax = Math.max(streamMax, marker.date);
    }
    if (handlers && typeof handlers.onMarker === 'function') {
      handlers.onMarker(marker);
    }
  };

  es.addEventListener('meta', e => {
    try {
      streamSummary = JSON.parse(e.data);
    } catch (err) {
      streamSummary = null;
    }
  });

  function finishStream() {
    state.loaded = true;
    state.source = null;
    if (handlers && typeof handlers.onDone === 'function') {
      handlers.onDone(streamSummary, streamMin, streamMax);
    }
    es.close();
  }

  es.addEventListener('done', finishStream);

  es.onerror = () => {
    state.source = null;
    if (handlers && typeof handlers.onError === 'function') {
      handlers.onError();
    }
    es.close();
  };
}

function updateLiveLayerOnly(state, options) {
  const opts = options || {};
  const manageLoadingOverlay = opts.manageLoadingOverlay !== false;
  initMarkerLayers();
  if (!map || !markerLayerGroups) {
    return;
  }
  // Keep live refresh isolated so toggling it never tears down base layers.
  const viewKey = buildMarkerViewKey();
  if (viewKey) {
    markerViewKey = viewKey;
  }
  if (!markerRenderState) {
    markerRenderState = createMarkerRenderState(map.getZoom());
  }
  syncMarkerLayerVisibility(state);
  const loadingEl = document.getElementById('loadingOverlay');
  const liveEnabled = markerLayerEnabled(markerLiveLayerName, state);

  if (liveEnabled && window.realtimeEnabled) {
    if (manageLoadingOverlay && loadingEl) {
      loadingEl.style.display = 'block';
    }
    closeMarkerLayerStream(markerLiveLayerName);
    clearMarkerLayerGroup(markerLiveLayerName);
    const bounds = map.getBounds();
    const params = new URLSearchParams({
      zoom: map.getZoom(),
      minLat: bounds.getSouthWest().lat,
      minLon: bounds.getSouthWest().lng,
      maxLat: bounds.getNorthEast().lat,
      maxLon: bounds.getNorthEast().lng,
      realtime: '1',
      liveOnly: '1',
    });
    startMarkerLayerStream(markerLiveLayerName, params, viewKey, {
      onMarker: function(m) {
        if (m && typeof m.speed === 'number' && m.speed < 0) {
          const queue = [{ marker: m, layerName: markerLiveLayerName }];
          queue.forEach(function(entry) {
            const group = markerLayerGroups[entry.layerName];
            if (!group) {
              return;
            }
            const nowSec = Date.now() / 1000;
            const icon = markerRenderState.livePlacement ? buildRealtimeIcon(entry.marker, map.getZoom(), nowSec) : null;
            if (!icon) {
              return;
            }
            const placedLatLng = markerRenderState.livePlacement.place(L.latLng(entry.marker.lat, entry.marker.lon), icon.radius);
            const marker = L.marker([placedLatLng.lat, placedLatLng.lng], {
              icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
            })
            .bindTooltip(getTooltipContent(entry.marker), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
            .bindPopup(getPopupContent(entry.marker));
            marker.doseRate = entry.marker.doseRate;
            marker.date = entry.marker.date;
            marker.isRealtime = true;
            const markerKey = entry.marker.id || `${entry.marker.trackID || 'track'}:${entry.marker.date}:${entry.marker.lat}:${entry.marker.lon}`;
            marker.markerKey = markerKey;
            marker.layerGroupName = entry.layerName;
            circleMarkers[markerKey] = marker;
            group.addLayer(marker);
          });
        }
      },
      onDone: function() {
        if (manageLoadingOverlay && loadingEl) {
          loadingEl.style.display = 'none';
        }
      },
      onError: function() {
        if (manageLoadingOverlay && loadingEl) {
          loadingEl.style.display = 'none';
        }
      },
    });
  } else {
    closeMarkerLayerStream(markerLiveLayerName);
    clearMarkerLayerGroup(markerLiveLayerName);
    if (manageLoadingOverlay && loadingEl) {
      loadingEl.style.display = 'none';
    }
  }

  markerFilterState = cloneMarkerFilterState(state);
}

function updateMapMarkers(loadingEl, forceReload, loadToken) {
  initMarkerLayers();
  if (!map || !markerLayerGroups) {
    if (loadingEl) loadingEl.style.display = 'none';
    return;
  }

  const state = loadSpeedFilterState();
  const prevState = markerFilterState;
  const baseChanged = baseFiltersChanged(prevState, state);
  const liveChanged = liveFilterChanged(prevState, state);
  const viewKey = buildMarkerViewKey();
  const viewChanged = viewKey && viewKey !== markerViewKey;
  const shouldReload = forceReload || viewChanged;
  if (shouldReload) {
    markerViewKey = viewKey;
    clearMarkerLayerGroups();
    markerRenderState = createMarkerRenderState(map.getZoom());
  } else if (!markerRenderState) {
    markerRenderState = createMarkerRenderState(map.getZoom());
  }

  syncMarkerLayerVisibility(state);

  const zoom = map.getZoom();
  const bounds = map.getBounds();
  const savedRange = loadDateRangeState();

  const renderQueue = [];
  let renderScheduled = false;
  let pendingRenderItems = 0;
  let streamsFinalized = false;

  function isActiveLoad() {
    return loadToken === markerLoadToken;
  }

  function enqueueMarker(marker, layerName) {
    if (!isActiveLoad()) {
      return;
    }
    renderQueue.push({ marker: marker, layerName: layerName });
    pendingRenderItems += 1;
    if (!renderScheduled) {
      renderScheduled = true;
      requestAnimationFrame(drainRenderQueue);
    }
  }

  function drainRenderQueue() {
    renderScheduled = false;
    if (!isActiveLoad()) {
      renderQueue.length = 0;
      pendingRenderItems = 0;
      return;
    }
    const start = performance.now();
    while (renderQueue.length && performance.now() - start < 12) {
      const entry = renderQueue.shift();
      renderQueuedMarker(entry.marker, entry.layerName);
      pendingRenderItems -= 1;
    }
    if (renderQueue.length) {
      renderScheduled = true;
      requestAnimationFrame(drainRenderQueue);
      return;
    }
    finalizeStreams();
  }

  function renderQueuedMarker(m, layerName) {
    const group = markerLayerGroups[layerName];
    if (!group) {
      return;
    }
    let marker;
    if (m.speed < 0) { // realtime marker with value inside the circle
      const nowSec = Date.now() / 1000;
      const icon = markerRenderState.livePlacement ? buildRealtimeIcon(m, zoom, nowSec) : null;
      if (!icon) {
        return;
      }
      const placedLatLng = markerRenderState.livePlacement.place(L.latLng(m.lat, m.lon), icon.radius);
      marker = L.marker([placedLatLng.lat, placedLatLng.lng], {
        icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
      })
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    } else {
      const radius = getRadius(m.doseRate, zoom);
      marker = L.circleMarker([m.lat, m.lon], {
        radius      : radius,
        fillColor   : getGradientColor(m.doseRate),
        color       : getGradientColor(m.doseRate),
        weight      : 1,
        opacity     : getFillOpacity(m.speed) + 0.1,
        fillOpacity : getFillOpacity(m.speed)
      })
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    }

    marker.doseRate = m.doseRate;
    marker.date = m.date;
    marker.isRealtime = m.speed < 0;
    const markerKey = m.id || `${m.trackID || 'track'}:${m.date}:${m.lat}:${m.lon}`;
    marker.markerKey = markerKey;
    marker.layerGroupName = layerName;
    circleMarkers[markerKey] = marker;
    group.addLayer(marker);
    if (m.speed >= 0 && markerRenderState.pruneOverlap) {
      markerRenderState.pruneOverlap(markerKey, m.lat, m.lon, marker.options && marker.options.radius);
    }
  }

  const tracks = new Set();
  let minTs = Infinity;
  let maxTs = -Infinity;
  let summaryMin = Infinity;
  let summaryMax = -Infinity;
  let summaryTrackCount = 0;
  let pendingStreams = 0;

  function mergeSummary(summary, streamMin, streamMax) {
    if (summary && Number.isFinite(summary.minTs)) {
      summaryMin = Math.min(summaryMin, summary.minTs);
    } else if (Number.isFinite(streamMin)) {
      summaryMin = Math.min(summaryMin, streamMin);
    }
    if (summary && Number.isFinite(summary.maxTs)) {
      summaryMax = Math.max(summaryMax, summary.maxTs);
    } else if (Number.isFinite(streamMax)) {
      summaryMax = Math.max(summaryMax, streamMax);
    }
    if (summary && Number.isFinite(summary.trackCount)) {
      summaryTrackCount += summary.trackCount;
    }
  }

  function finalizeStreams() {
    if (!isActiveLoad() || streamsFinalized || pendingStreams > 0 || pendingRenderItems > 0) {
      return;
    }
    streamsFinalized = true;
    const summaryMinTs = Number.isFinite(summaryMin) ? summaryMin : minTs;
    const summaryMaxTs = Number.isFinite(summaryMax) ? summaryMax : maxTs;
    const trackCount = summaryTrackCount > 0 ? summaryTrackCount : tracks.size;
    const needSlider = trackCount > 1 && isFinite(summaryMinTs) && isFinite(summaryMaxTs) && summaryMaxTs > summaryMinTs;
    if (window.__setDateSliderVisibility){
      window.__setDateSliderVisibility(needSlider);
    }
    if (needSlider && window.__initSliderOnce && isFinite(summaryMinTs) && isFinite(summaryMaxTs)){
      window.__initSliderOnce(summaryMinTs, summaryMaxTs);
      window.__initSliderOnce = null;
    }
    if (needSlider && window.__syncDateSliders && isFinite(summaryMinTs) && isFinite(summaryMaxTs)){
      window.__syncDateSliders(summaryMinTs, summaryMaxTs);
    }
    if (waitForDangerFit && storedUserCenter) {
      reframeAroundUser();
    }
    if (loadingEl) loadingEl.style.display = 'none';
  }

  function buildStreamParams(speedTag, includeRealtime, liveOnly) {
    const params = new URLSearchParams({
      zoom: zoom,
      minLat: bounds.getSouthWest().lat,
      minLon: bounds.getSouthWest().lng,
      maxLat: bounds.getNorthEast().lat,
      maxLon: bounds.getNorthEast().lng,
    });
    if (speedTag) {
      params.set('speeds', speedTag);
    }
    if (includeRealtime) {
      params.set('realtime', '1');
    } else {
      params.set('realtime', '0');
    }
    if (liveOnly) {
      params.set('liveOnly', '1');
    }
    return params;
  }

  function requestLayerStream(layerName, params, trackSummaries) {
    pendingStreams += 1;
    startMarkerLayerStream(layerName, params, viewKey, {
      onMarker: function(m) {
        if (!isActiveLoad()) {
          return;
        }
        const isLive = m.speed < 0;
        if (!isLive && m.trackID) {
          tracks.add(m.trackID);
        }
        if (!isLive && typeof m.date === 'number') {
          minTs = Math.min(minTs, m.date);
          maxTs = Math.max(maxTs, m.date);
        }
        if (!isLive && savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) {
          return;
        }
        enqueueMarker(m, layerName);
      },
      onDone: function(summary, streamMin, streamMax) {
        if (!isActiveLoad()) {
          return;
        }
        if (trackSummaries) {
          mergeSummary(summary, streamMin, streamMax);
        }
        pendingStreams -= 1;
        finalizeStreams();
      },
      onError: function() {
        if (!isActiveLoad()) {
          return;
        }
        pendingStreams -= 1;
        finalizeStreams();
      },
    });
  }

  const liveEnabled = markerLayerEnabled(markerLiveLayerName, state);
  const anyBaseEnabled = markerLayerNames.some(function(name) {
    return markerLayerEnabled(name, state);
  });

  if (shouldReload) {
    markerLayerNames.forEach(function(name) {
      if (!markerLayerEnabled(name, state)) {
        closeMarkerLayerStream(name);
        return;
      }
      const layerState = markerLayerState[name];
      const alreadyLoaded = layerState && layerState.loaded && layerState.viewKey === viewKey;
      if (alreadyLoaded) {
        return;
      }
      if (layerState && !layerState.loaded) {
        // Clear partial data so a fresh stream doesn't duplicate markers.
        clearMarkerLayerGroup(name);
      }
      const params = buildStreamParams(name, false, false);
      requestLayerStream(name, params, true);
    });
  } else if (baseChanged) {
    markerLayerNames.forEach(function(name) {
      const prevEnabled = markerLayerEnabled(name, prevState || {});
      const nextEnabled = markerLayerEnabled(name, state);
      if (prevEnabled === nextEnabled) {
        return;
      }
      if (!nextEnabled) {
        closeMarkerLayerStream(name);
        clearMarkerLayerGroup(name);
        return;
      }
      const layerState = markerLayerState[name];
      if (layerState && !layerState.loaded) {
        // Clear partial data so a fresh stream doesn't duplicate markers.
        clearMarkerLayerGroup(name);
      }
      const params = buildStreamParams(name, false, false);
      requestLayerStream(name, params, true);
    });
  }

  if (liveChanged || shouldReload) {
    updateLiveLayerOnly(state, { manageLoadingOverlay: false });
  }

  markerFilterState = cloneMarkerFilterState(state);

  if (pendingStreams > 0) {
    if (loadingEl) loadingEl.style.display = 'block';
  } else {
    if (!anyBaseEnabled && pendingRenderItems === 0) {
      if (window.__setDateSliderVisibility) {
        window.__setDateSliderVisibility(false);
      }
      if (loadingEl) {
        loadingEl.style.display = 'none';
      }
    } else {
      finalizeStreams();
    }
  }
}


/* Request markers for current bounds/zoom, render them,
 * and keep the date sliders in sync with the viewport.
 */
function updateMarkers(forceReload){
  const loadToken = ++markerLoadToken;
  const loadingEl = document.getElementById('loadingOverlay');
  if (trackPlaybackActive || trackViewPlaybackActive) {
    if (forceReload && trackViewPlaybackActive) {
      stopTrackViewPlayback(false);
    } else {
      if (loadingEl) loadingEl.style.display='none';
      return;
    }
  }
  if (!isTrackView) {
    updateMapMarkers(loadingEl, forceReload, loadToken);
    return;
  }
  if (loadingEl) loadingEl.style.display='block';

  if (markerStreamSource) markerStreamSource.close();

  const zoom   = map.getZoom();
  const bounds = map.getBounds();

  const params = {
    zoom  : zoom,
    minLat: bounds.getSouthWest().lat,
    minLon: bounds.getSouthWest().lng,
    maxLat: bounds.getNorthEast().lat,
    maxLon: bounds.getNorthEast().lng
  };
  if (currentTrackID) params.trackID = currentTrackID; // focus on a single track when set

  const savedRange = isTrackView ? null : loadDateRangeState();

  for (const key in circleMarkers) map.removeLayer(circleMarkers[key]);
  circleMarkers = {};
  if (isTrackView) {
    trackViewMarkers = [];
    trackViewMarkersReady = false;
  }

  const tracks = new Set();
  let minTs = Infinity, maxTs = -Infinity;
  const livePlacement = createLivePlacementGrid(map, zoom);
  const pruneOverlap = createMarkerOverlapPruner(map);
  const renderQueue = [];
  let renderScheduled = false;
  let pendingRenderItems = 0;
  let streamDone = false;

  function isActiveLoad() {
    return loadToken === markerLoadToken;
  }

  function finalizeTrackStream() {
    if (!isActiveLoad() || !streamDone || pendingRenderItems > 0) {
      return;
    }
    if (loadingEl) loadingEl.style.display='none';
  }

  function enqueueMarker(marker) {
    if (!isActiveLoad()) {
      return;
    }
    renderQueue.push(marker);
    pendingRenderItems += 1;
    if (!renderScheduled) {
      renderScheduled = true;
      requestAnimationFrame(drainRenderQueue);
    }
  }

  function drainRenderQueue() {
    renderScheduled = false;
    if (!isActiveLoad()) {
      renderQueue.length = 0;
      pendingRenderItems = 0;
      return;
    }
    const start = performance.now();
    while (renderQueue.length && performance.now() - start < 12) {
      renderQueuedMarker(renderQueue.shift());
      pendingRenderItems -= 1;
    }
    if (renderQueue.length) {
      renderScheduled = true;
      requestAnimationFrame(drainRenderQueue);
      return;
    }
    finalizeTrackStream();
  }

  function renderQueuedMarker(m) {
    let marker;
    if (m.speed < 0) { // realtime marker with value inside the circle
      const nowSec = Date.now() / 1000;
      const icon = buildRealtimeIcon(m, zoom, nowSec);
      if (!icon) return; // device is older than 24 hours
      const placedLatLng = livePlacement.place(L.latLng(m.lat, m.lon), icon.radius);
      marker = L.marker([placedLatLng.lat, placedLatLng.lng], {
        icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
      })
      .addTo(map)
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    } else {
      const radius = getRadius(m.doseRate, zoom);
      marker = L.circleMarker([m.lat, m.lon], {
        radius      : radius,
        fillColor   : getGradientColor(m.doseRate),
        color       : getGradientColor(m.doseRate),
        weight      : 1,
        opacity     : getFillOpacity(m.speed) + 0.1,
        fillOpacity : getFillOpacity(m.speed)
      })
      .addTo(map)
      .bindTooltip(getTooltipContent(m), { direction:'top', className:'custom-tooltip', offset:[0,-8], interactive:true })
      .bindPopup(getPopupContent(m));
    }

    // Store dose rate and timestamp on marker for later size updates.
    marker.doseRate  = m.doseRate;
    marker.date      = m.date;
    marker.isRealtime = m.speed < 0;
    const markerKey = m.id || `${m.trackID || 'track'}:${m.date}:${m.lat}:${m.lon}`;
    circleMarkers[markerKey] = marker;
    if (m.speed >= 0) {
      pruneOverlap(markerKey, m.lat, m.lon, marker.options && marker.options.radius);
    }
  }

  const es = new EventSource('/stream_markers?' + new URLSearchParams(params));
  markerStreamSource = es;
  let streamSummary = null;

  es.onmessage = e => {
    if (!isActiveLoad()) {
      return;
    }
    let m; try { m = JSON.parse(e.data); } catch { return; }
    const isLive = m.speed < 0; // negative speed denotes realtime marker
    if (!isLive && m.trackID) tracks.add(m.trackID);
    minTs = Math.min(minTs, m.date);
    maxTs = Math.max(maxTs, m.date);
    // Keep realtime Safecast markers visible regardless of the date slider so live sensors are never filtered out.
    if (!isLive && savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) return;
    if (!shouldDisplayBySpeed(m.speed)) return;
    if (isTrackView) {
      // Buffer track markers so we can render them in chronological order.
      trackViewMarkers.push(m);
      return;
    }

    enqueueMarker(m);
  };

  es.addEventListener('meta', e => {
    // Keep stream-wide stats separate from aggregated markers so UI controls
    // remain accurate even when one dominant track owns most cells.
    try {
      streamSummary = JSON.parse(e.data);
    } catch {
      streamSummary = null;
    }
  });

  es.addEventListener('done', () => {
    if (!isActiveLoad()) {
      return;
    }
    streamDone = true;
    const summaryMin = streamSummary && Number.isFinite(streamSummary.minTs) ? streamSummary.minTs : minTs;
    const summaryMax = streamSummary && Number.isFinite(streamSummary.maxTs) ? streamSummary.maxTs : maxTs;
    const trackCount = streamSummary && Number.isFinite(streamSummary.trackCount) ? streamSummary.trackCount : tracks.size;
    const dateSpanMonths = (isFinite(summaryMin) && isFinite(summaryMax))
                            ? monthsApart(summaryMin, summaryMax) : 0;
    const needSlider = !isTrackView && trackCount > 1 && isFinite(summaryMin) && isFinite(summaryMax) && summaryMax > summaryMin;
    if (window.__setDateSliderVisibility){
      window.__setDateSliderVisibility(needSlider);
    }
    if (needSlider && window.__initSliderOnce && isFinite(summaryMin) && isFinite(summaryMax)){
      window.__initSliderOnce(summaryMin, summaryMax);
      window.__initSliderOnce = null;
    }
    if (needSlider && window.__syncDateSliders && isFinite(summaryMin) && isFinite(summaryMax)){
      window.__syncDateSliders(summaryMin, summaryMax);
    }
    if (waitForDangerFit && storedUserCenter) {
      reframeAroundUser();
    }
    finalizeTrackStream();
    es.close();
    if (isTrackView) {
      trackViewMarkers.sort(function(a, b) {
        const aDate = typeof a.date === 'number' ? a.date : 0;
        const bDate = typeof b.date === 'number' ? b.date : 0;
        return aDate - bDate;
      });
      trackViewMarkersReady = true;
      if (!trackViewAutoplayRequested) {
        renderTrackViewSnapshot();
      }
      startTrackViewAutoplayAfterReload();
    }
  });

  es.onerror = () => {
    if (!isActiveLoad()) {
      es.close();
      return;
    }
    if (loadingEl) loadingEl.style.display='none';
    es.close();
  };
}

async function fetchLiveHistory(deviceID) {
  if (!deviceID) throw new Error('device');
  if (liveHistoryCache.has(deviceID)) {
    return liveHistoryCache.get(deviceID);
  }
  const resp = await fetch('/realtime_history?device=' + encodeURIComponent(deviceID));
  if (!resp.ok) {
    throw new Error('history');
  }
  const data = await resp.json();
  liveHistoryCache.set(deviceID, data);
  return data;
}

function chartColors() {
  const theme = document.documentElement.dataset.theme;
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const dark = theme === 'dark' || (!theme && prefersDark);
  if (dark) {
    return {
      grid: 'rgba(255,255,255,0.18)',
      line: '#90caf9',
      text: '#e2e8f0',
      panel: '#1f252d',
      plot: '#11161c'
    };
  }
  return {
    grid: 'rgba(17,24,39,0.15)',
    line: '#1e88e5',
    text: '#1f2937',
    panel: '#f4f5f7',
    plot: '#ffffff'
  };
}

function radiationLineColor(valueMicroRoentgen) {
  return getGradientColor(valueMicroRoentgen / 100);
}

function niceNumber(range, round) {
  if (!isFinite(range) || range === 0) return 0;
  const exponent = Math.floor(Math.log10(Math.abs(range)));
  const fraction = range / Math.pow(10, exponent);
  let niceFraction;
  if (round) {
    if (fraction < 1.5) niceFraction = 1;
    else if (fraction < 3) niceFraction = 2;
    else if (fraction < 7) niceFraction = 5;
    else niceFraction = 10;
  } else {
    if (fraction <= 1) niceFraction = 1;
    else if (fraction <= 2) niceFraction = 2;
    else if (fraction <= 5) niceFraction = 5;
    else niceFraction = 10;
  }
  return niceFraction * Math.pow(10, exponent);
}

function niceTicks(min, max, count) {
  if (!isFinite(min) || !isFinite(max) || count <= 0) return [];
  if (min === max) return [min];
  const range = niceNumber(max - min, false);
  if (range === 0) return [];
  const spacing = niceNumber(range / (count - 1), true);
  if (!isFinite(spacing) || spacing === 0) return [];
  const niceMin = Math.floor(min / spacing) * spacing;
  const niceMax = Math.ceil(max / spacing) * spacing;
  const ticks = [];
  for (let v = niceMin; v <= niceMax + spacing / 2; v += spacing) {
    ticks.push(v);
  }
  return ticks;
}

const TIME_TICK_STEPS = [
  60,
  120,
  300,
  600,
  900,
  1800,
  3600,
  7200,
  14400,
  21600,
  43200,
  86400,
  172800,
  604800,
  1209600,
  2592000,
  7776000,
  15552000,
  31536000,
];

function selectTimeStep(spanSeconds, bucketSeconds) {
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return bucketSeconds || 60;
  }
  let minStep = spanSeconds / 6;
  if (bucketSeconds && bucketSeconds > minStep) {
    minStep = bucketSeconds;
  } else if (bucketSeconds) {
    minStep = Math.max(bucketSeconds, minStep / 2);
  }
  for (let i = 0; i < TIME_TICK_STEPS.length; i++) {
    if (TIME_TICK_STEPS[i] >= minStep) {
      return TIME_TICK_STEPS[i];
    }
  }
  return Math.max(bucketSeconds || TIME_TICK_STEPS[TIME_TICK_STEPS.length - 1], Math.round(minStep));
}

function buildTimeTicks(start, end, bucketSeconds) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  const span = end - start;
  const step = selectTimeStep(span, bucketSeconds);
  if (!isFinite(step) || step <= 0) return [];
  const ticks = [];
  const first = Math.ceil(start / step) * step;
  for (let ts = first; ts <= end; ts += step) {
    ticks.push(ts);
  }
  return ticks;
}

function secondsForUnit(unit) {
  switch (unit) {
    case 'hour':
      return 3600;
    case 'day':
      return 86400;
    default:
      return 0;
  }
}

// buildSegmentTicks divides the range into evenly spaced segments without relying
// on heuristics so the canvas grid can honour strict hour/day/month splits.
function buildSegmentTicks(start, end, segments, unit) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  if (!segments || segments <= 0) return [];
  if (unit === 'month') {
    const ticks = [];
    let cursor = new Date(start * 1000);
    cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth(), 1, 0, 0, 0, 0));
    for (let i = 1; i < segments; i++) {
      cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1, 0, 0, 0, 0));
      const ts = Math.floor(cursor.getTime() / 1000);
      if (ts <= start || ts >= end) {
        continue;
      }
      ticks.push(ts);
    }
    return ticks;
  }
  const step = secondsForUnit(unit);
  if (!step) return [];
  const ticks = [];
  for (let i = 1; i < segments; i++) {
    const ts = start + step * i;
    if (ts <= start || ts >= end) continue;
    ticks.push(ts);
  }
  return ticks;
}

function formatTimeTickLabel(ts, spanSeconds, lang) {
  if (!isFinite(ts)) return '';
  const date = new Date(ts * 1000);
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 48 * 3600) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 400 * 86400) {
    return date.toLocaleDateString(lang, { month: 'short', day: 'numeric' });
  }
  if (spanSeconds <= 5 * 365 * 86400) {
    return date.toLocaleDateString(lang, { year: 'numeric', month: 'short' });
  }
  return date.toLocaleDateString(lang, { year: 'numeric' });
}

function formatAveragingWindow(seconds) {
  if (!seconds || !isFinite(seconds)) return '';
  const abs = Math.abs(seconds);
  const units = [
    { limit: 3600, key: 'duration_minutes', divisor: 60 },
    { limit: 48 * 3600, key: 'duration_hours', divisor: 3600 },
    { limit: 14 * 86400, key: 'duration_days', divisor: 86400 },
    { limit: 90 * 86400, key: 'duration_weeks', divisor: 604800 },
    { limit: Infinity, key: 'duration_months', divisor: 2592000 },
  ];
  let chosen = units[units.length - 1];
  for (let i = 0; i < units.length; i++) {
    if (abs < units[i].limit) {
      chosen = units[i];
      break;
    }
  }
  const template = translate(chosen.key);
  if (!template) return '';
  const count = Math.max(1, Math.round(abs / chosen.divisor));
  return template.replace('[[count]]', count);
}

function describeRangeLabel(range) {
  if (!range || typeof range.start !== 'number' || typeof range.end !== 'number') return '';
  if (range.end <= range.start) return '';
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const span = range.end - range.start;
  let startOpts;
  let endOpts;
  if (span <= 48 * 3600) {
    startOpts = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    endOpts = startOpts;
  } else if (span <= 120 * 86400) {
    startOpts = { month: 'short', day: 'numeric' };
    endOpts = { month: 'short', day: 'numeric' };
  } else if (span <= 720 * 86400) {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  } else {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  }
  const startText = new Date(range.start * 1000).toLocaleString(lang, startOpts);
  const endText = new Date(range.end * 1000).toLocaleString(lang, endOpts);
  if (!startText || !endText) return '';
  return startText + ' ‚Üí ' + endText;
}

function drawLiveChart(canvas, radiationPoints, extrasByKey, options) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (width === 0 || height === 0) return;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const colors = chartColors();
  canvas.style.background = colors.panel;

  const fontTokens = resolveFontTokens(); // Use CSS-driven sizes so canvas labels match the rest of the UI.
  const fonts = {
    axisY: fontTokens.sm + ' ' + fontTokens.family,
    axisX: fontTokens.xs + ' ' + fontTokens.family,
    extras: fontTokens.sm + ' ' + fontTokens.family,
    legend: fontTokens.base + ' ' + fontTokens.family,
  };

  const extras = {};
  if (extrasByKey && typeof extrasByKey === 'object') {
    Object.keys(extrasByKey).forEach(function(key) {
      const series = extrasByKey[key];
      if (Array.isArray(series) && series.length) {
        extras[key] = series;
      }
    });
  }
  const extraKeys = sortExtraKeys(Object.keys(extras));
  const hasRadiation = Array.isArray(radiationPoints) && radiationPoints.length > 0;
  if (!hasRadiation && extraKeys.length === 0) {
    return;
  }

  const baseSeries = hasRadiation ? radiationPoints : extras[extraKeys[0]];
  if (!baseSeries || !baseSeries.length) {
    return;
  }

      const opts = options || {};
      let minX = baseSeries[0].timestamp;
  let maxX = baseSeries[baseSeries.length - 1].timestamp || (minX + 1);
  if (typeof opts.start === 'number' && typeof opts.end === 'number' && opts.end > opts.start) {
    minX = opts.start;
    maxX = opts.end;
  }
  if (!(maxX > minX)) {
    maxX = minX + 1;
  }
  const bucketSeconds = typeof opts.bucketSeconds === 'number' ? opts.bucketSeconds : 0;

  let minY;
  let maxY;
  if (hasRadiation) {
    minY = radiationPoints[0].value;
    maxY = radiationPoints[0].value;
    radiationPoints.forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  } else {
    const key = extraKeys[0];
    minY = extras[key][0].value;
    maxY = extras[key][0].value;
    extras[key].forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  }
  if (minY === maxY) {
    const delta = minY === 0 ? 0.5 : Math.abs(minY) * 0.2;
    minY -= delta;
    maxY += delta;
  }

  const extraRanges = {};
  extraKeys.forEach(function(key) {
    const series = extras[key];
    let minVal = series[0].value;
    let maxVal = series[0].value;
    series.forEach(function(point) {
      if (point.value < minVal) minVal = point.value;
      if (point.value > maxVal) maxVal = point.value;
    });
    if (minVal === maxVal) {
      const delta = minVal === 0 ? 0.5 : Math.abs(minVal) * 0.2;
      minVal -= delta;
      maxVal += delta;
    }
    extraRanges[key] = { min: minVal, max: maxVal };
  });

  const extraColumnWidth = 72;
  const rightPad = extraKeys.length ? extraColumnWidth * extraKeys.length + 20 : 20;
  const leftPad = hasRadiation ? 70 : 50;
  const topPad = 64;
  const bottomPad = 44;

  const plotLeft = leftPad;
  const plotRight = width - rightPad;
  const plotTop = topPad;
  const plotBottom = height - bottomPad;
      const plotW = Math.max(plotRight - plotLeft, 10);
      const plotH = Math.max(plotBottom - plotTop, 10);

  // Paint a dedicated plot background so the grid and fills feel Grafana-like.
  ctx.fillStyle = colors.plot;
  ctx.fillRect(plotLeft, plotTop, plotW, plotH);

  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const spanSeconds = maxX - minX;

  const rangeX = (maxX - minX) || 1;
  const rangeY = hasRadiation ? ((maxY - minY) || 1) : 1;

  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotLeft, plotTop);
  ctx.lineTo(plotLeft, plotBottom);
  ctx.lineTo(plotRight, plotBottom);
  if (extraKeys.length) {
    ctx.moveTo(plotRight, plotTop);
    ctx.lineTo(plotRight, plotBottom);
  }
  ctx.stroke();

  const ticksY = niceTicks(minY, maxY, 5);
  ctx.font = fonts.axisY;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ticksY.forEach(function(value) {
    if (!isFinite(value)) return;
    const y = plotBottom - ((value - minY) / rangeY) * plotH;
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.5);
    ctx.beginPath();
    ctx.moveTo(plotLeft, y);
    ctx.lineTo(plotRight, y);
    ctx.stroke();
    const label = formatMicroRoentgenValue(value);
    ctx.fillStyle = colors.text;
    ctx.fillText(label, plotLeft - 8, y);
  });

  const tickUnit = opts.tickUnit || null;
  const tickSegments = opts.tickSegments || 0;
  const forcedTicks = (tickUnit && tickSegments > 0) ? buildSegmentTicks(minX, maxX, tickSegments, tickUnit) : null;
  const ticksX = forcedTicks && forcedTicks.length ? forcedTicks : buildTimeTicks(minX, maxX, bucketSeconds);
  const approxStep = (tickUnit && tickSegments > 0)
    ? (tickUnit === 'month' ? (maxX - minX) / tickSegments : secondsForUnit(tickUnit))
    : (bucketSeconds || 0);
  const axisLabelY = height - 12;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = fonts.axisX;
  ctx.strokeStyle = colorWithAlpha(colors.grid, 0.35);
  let lastLabelRight = -Infinity;
  let firstLabelLeft = Infinity;
  const labelSpacing = spanSeconds > 365 * 86400 ? 28 : 12;
  ticksX.forEach(function(ts) {
    if (!isFinite(ts)) return;
    const x = plotLeft + ((ts - minX) / rangeX) * plotW;
    ctx.beginPath();
    ctx.moveTo(x, plotTop);
    ctx.lineTo(x, plotBottom);
    ctx.stroke();
    const label = formatTimeTickLabel(ts, spanSeconds, lang);
    if (!label) return;
    const labelWidth = ctx.measureText(label).width;
    const labelLeft = x - labelWidth / 2;
    const labelRight = x + labelWidth / 2;
    if (labelLeft < lastLabelRight + labelSpacing) {
      return;
    }
    ctx.fillStyle = colors.text;
    ctx.fillText(label, x, axisLabelY);
    lastLabelRight = labelRight;
    if (labelLeft < firstLabelLeft) {
      firstLabelLeft = labelLeft;
    }
  });

  const tolerance = Math.max(60, approxStep || 0);
  const showStart = !ticksX.some(function(ts) { return Math.abs(ts - minX) < tolerance; });
  const showEnd = !ticksX.some(function(ts) { return Math.abs(ts - maxX) < tolerance; });
  ctx.fillStyle = colors.text;
  const startLabel = formatTimeTickLabel(minX, spanSeconds, lang);
  if (showStart && startLabel) {
    const startWidth = ctx.measureText(startLabel).width;
    const startRight = plotLeft + startWidth;
    if (startRight < firstLabelLeft - labelSpacing) {
      ctx.textAlign = 'left';
      ctx.fillText(startLabel, plotLeft, axisLabelY);
    }
  }
  ctx.textAlign = 'right';
  const endLabel = formatTimeTickLabel(maxX, spanSeconds, lang);
  if (showEnd && endLabel) {
    const endWidth = ctx.measureText(endLabel).width;
    const endLeft = plotRight - endWidth;
    if (endLeft > lastLabelRight + labelSpacing) {
      ctx.fillText(endLabel, plotRight, axisLabelY);
    }
  }

  if (hasRadiation) {
    const radiationCoords = radiationPoints.map(function(point) {
      return {
        x: plotLeft + ((point.timestamp - minX) / rangeX) * plotW,
        y: plotBottom - ((point.value - minY) / rangeY) * plotH,
        value: point.value
      };
    });

    // Build a spectrum gradient that follows the Safecast legend formula for the chart styling.
    const radiationStroke = buildRadiationGradient(ctx, plotLeft, plotTop, plotBottom, minY, maxY, 1, 1);
    const radiationFill = buildRadiationGradient(ctx, plotLeft, plotTop, plotBottom, minY, maxY, 0.5, 0.5);

    // Treat the latest datapoint as "now" for the dimming mask and marker.
    const currentIndex = radiationCoords.length - 1;
    const currentCoord = radiationCoords[currentIndex];
    const maskPadding = 6;

    // Paint the dimming layer, clipped to the area under the curve up to "now".
    ctx.save();
    ctx.beginPath();
    buildSmoothPath(ctx, radiationCoords.slice(0, currentIndex + 1));
    ctx.lineTo(currentCoord.x, plotBottom);
    ctx.lineTo(plotLeft, plotBottom);
    ctx.closePath();
    ctx.clip();
    ctx.fillStyle = colorWithAlpha(colors.plot === '#ffffff' ? '#0f172a' : '#0b1120', 0.25);
    ctx.fillRect(plotLeft - maskPadding, plotTop - maskPadding, plotW + maskPadding * 2, plotH + maskPadding * 2);
    ctx.restore();

    // Fill the area under the line with the multicolor radiation gradient.
    ctx.beginPath();
    buildSmoothPath(ctx, radiationCoords);
    ctx.lineTo(plotRight, plotBottom);
    ctx.lineTo(plotLeft, plotBottom);
    ctx.closePath();
    ctx.fillStyle = radiationFill;
    ctx.fill();

    // Draw a bright outline first so the line pops like the reference styling.
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = colorWithAlpha('#ffffff', 0.35);
    ctx.beginPath();
    buildSmoothPath(ctx, radiationCoords);
    ctx.stroke();

    // Draw the smoothed line using the same legend-driven gradient.
    ctx.lineWidth = 2.2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = radiationStroke;
    ctx.beginPath();
    buildSmoothPath(ctx, radiationCoords);
    ctx.stroke();

    // Draw the vertical "now" line and bubble marker on the curve.
    ctx.strokeStyle = colorWithAlpha(colors.text, 0.4);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(currentCoord.x, plotTop);
    ctx.lineTo(currentCoord.x, plotBottom);
    ctx.stroke();

    ctx.fillStyle = colorWithAlpha('#ffffff', 0.9);
    ctx.beginPath();
    ctx.arc(currentCoord.x, currentCoord.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = radiationLineColor(currentCoord.value);
    ctx.beginPath();
    ctx.arc(currentCoord.x, currentCoord.y, 3.2, 0, Math.PI * 2);
    ctx.fill();
  }

  extraKeys.forEach(function(key, idx) {
    const series = extras[key];
    const range = extraRanges[key];
    const denom = (range.max - range.min) || 1;
    const color = colorForExtraKey(key);
    const extraCoords = series.map(function(point) {
      return {
        x: plotLeft + ((point.timestamp - minX) / rangeX) * plotW,
        y: plotBottom - ((point.value - range.min) / denom) * plotH
      };
    });
    ctx.beginPath();
    buildSmoothPath(ctx, extraCoords);
    ctx.lineTo(plotRight, plotBottom);
    ctx.lineTo(plotLeft, plotBottom);
    ctx.closePath();
    ctx.fillStyle = colorWithAlpha(color, 0.12);
    ctx.fill();

    ctx.strokeStyle = color;
    ctx.lineWidth = 1.6;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    buildSmoothPath(ctx, extraCoords);
    ctx.stroke();
    ctx.setLineDash([]);

    const xBase = plotRight + 8 + idx * extraColumnWidth;
    const suffix = extraUnitSuffix(key);
    const maxLabel = formatExtraAxisValue(key, range.max);
    const minLabel = formatExtraAxisValue(key, range.min);
    ctx.font = fonts.extras;
    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    if (maxLabel) {
      ctx.fillText(maxLabel + (suffix ? ' ' + suffix : ''), xBase, plotTop + 12);
    }
    if (minLabel) {
      ctx.fillText(minLabel + (suffix ? ' ' + suffix : ''), xBase, plotBottom - 4);
    }
  });

  ctx.font = fonts.legend;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'left';
  const legendY = topPad - 20;
  let legendX = plotLeft;
  const legendEntries = [];
  if (hasRadiation) {
    // The legend reuses a gradient so the key matches the multi-hued line.
    const legendGradient = ctx.createLinearGradient(legendX, legendY, legendX + 18, legendY);
    legendGradient.addColorStop(0, radiationLineColor(minY));
    legendGradient.addColorStop(1, radiationLineColor(maxY));
    legendEntries.push({ label: translate('radiation_dose') + ' (¬µR/h)', color: legendGradient, solid: true });
  }
  extraKeys.forEach(function(key) {
    const suffix = extraUnitSuffix(key);
    const label = labelForExtraKey(key) + (suffix ? ' (' + suffix + ')' : '');
    legendEntries.push({ label: label, color: colorForExtraKey(key), solid: false });
  });
  legendEntries.forEach(function(entry) {
    ctx.strokeStyle = entry.color;
    ctx.lineWidth = entry.solid ? 3 : 1.5;
    ctx.setLineDash(entry.solid ? [] : [5, 3]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 18, legendY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = colors.text;
    ctx.fillText(entry.label, legendX + 24, legendY + 4);
    legendX += ctx.measureText(entry.label).width + 64;
  });
}

// buildSmoothPath draws a quadratic-curve path through the provided points so
// chart lines feel closer to Grafana's smoothing without extra dependencies.
function buildSmoothPath(ctx, points) {
  if (!points || points.length === 0) return;
  if (points.length === 1) {
    ctx.moveTo(points[0].x, points[0].y);
    return;
  }
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const midX = (prev.x + curr.x) / 2;
    const midY = (prev.y + curr.y) / 2;
    ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
  }
  const last = points[points.length - 1];
  ctx.lineTo(last.x, last.y);
}

// buildRadiationGradient maps Safecast legend thresholds to a multi-stop gradient.
function buildRadiationGradient(ctx, left, top, bottom, minValue, maxValue, topAlpha, bottomAlpha) {
  const span = (maxValue - minValue) || 1;
  const stops = [
    { value: minValue, alpha: bottomAlpha },
    // ¬µR/h thresholds derived from the dose-rate formula used in getGradientColor.
    { value: 4, alpha: topAlpha },
    { value: 8, alpha: topAlpha },
    { value: 11, alpha: topAlpha },
    { value: 20, alpha: topAlpha },
    { value: 30, alpha: topAlpha },
    { value: 99, alpha: topAlpha },
    { value: maxValue, alpha: bottomAlpha }
  ];
  // Anchor low values to the bottom of the chart so the gradient reads low‚Üíhigh.
  const gradient = ctx.createLinearGradient(left, bottom, left, top);
  const used = new Set();
  stops.forEach(function(stop) {
    const value = Math.min(Math.max(stop.value, minValue), maxValue);
    const t = Math.min(Math.max((value - minValue) / span, 0), 1);
    const key = t.toFixed(3);
    if (used.has(key)) return;
    used.add(key);
    gradient.addColorStop(t, colorWithAlpha(radiationLineColor(value), stop.alpha));
  });
  return gradient;
}


function updateChartHeading(element, key, ranges) {
  if (!element) return;
  const base = translate('live_chart_' + key);
  const range = ranges && ranges[key];
  const desc = describeRangeLabel(range);
  element.textContent = desc ? base + ' ¬∑ ' + desc : base;
}

function updateChartWindowLabel(rangeKey, ranges) {
  const el = document.querySelector(`.live-chart-window[data-range="${rangeKey}"]`);
  if (!el) return;
  const range = ranges && ranges[rangeKey];
  if (!range || !range.bucketSeconds) {
    el.textContent = '';
    return;
  }
  const windowText = formatAveragingWindow(range.bucketSeconds);
  if (!windowText) {
    el.textContent = '';
    return;
  }
  const template = translate('live_chart_averaged');
  el.textContent = template ? template.replace('[[window]]', windowText) : windowText;
}

function hideLiveModal() {
  const modal = document.getElementById('liveModal');
  if (modal) modal.style.display = 'none';
}

// liveChartState caches range data so we can redraw charts when hidden panels become visible.
const liveChartState = {
  ranges: {},
  series: {},
  extras: {},
  options: {}
};

function renderLiveRange(rangeKey) {
  const canvas = document.querySelector(`.live-chart-canvas[data-range="${rangeKey}"]`);
  const empty = document.querySelector(`.live-chart-empty[data-range="${rangeKey}"]`);
  const series = liveChartState.series[rangeKey] || [];
  const extras = liveChartState.extras[rangeKey] || null;
  const options = liveChartState.options[rangeKey] || {};
  const hasSeries = (series && series.length) || hasExtraSeries(extras);
  if (canvas && hasSeries) {
    if (empty) empty.style.display = 'none';
    drawLiveChart(canvas, series, extras, options);
  } else if (empty) {
    empty.textContent = translate('live_marker_no_data');
    empty.style.display = 'block';
  }
}

function setActiveLiveRange(rangeKey) {
  const blocks = document.querySelectorAll('.live-chart-block');
  const buttons = document.querySelectorAll('.live-range-button');
  blocks.forEach(function(block) {
    const matches = block.dataset && block.dataset.range === rangeKey;
    block.classList.toggle('is-active', matches);
  });
  buttons.forEach(function(button) {
    const matches = button.dataset && button.dataset.range === rangeKey;
    button.classList.toggle('is-active', matches);
  });
  renderLiveRange(rangeKey);
}

function updateLiveRangeButtons() {
  const buttons = document.querySelectorAll('.live-range-button');
  buttons.forEach(function(button) {
    const rangeKey = button.dataset ? button.dataset.range : '';
    if (!rangeKey) return;
    const label = translate('live_chart_' + rangeKey);
    button.textContent = label || rangeKey;
  });
}

async function openLiveModal(deviceID, fallback) {
  const modal = document.getElementById('liveModal');
  if (!modal) return;
  modal.style.display = 'flex';

  const titleEl = document.getElementById('liveModalTitle');
  const descEl = document.getElementById('liveModalDescription');
  const metaEl = document.getElementById('liveModalMeta');
  const extraEl = document.getElementById('liveModalExtra');

  const dayTitle = document.getElementById('liveChartTitleDay');
  const weekTitle = document.getElementById('liveChartTitleWeek');
  const monthTitle = document.getElementById('liveChartTitleMonth');
  const allTitle = document.getElementById('liveChartTitleAll');
  updateChartHeading(dayTitle, 'day');
  updateChartHeading(weekTitle, 'week');
  updateChartHeading(monthTitle, 'month');
  updateChartHeading(allTitle, 'all');
  updateLiveRangeButtons();
  setActiveLiveRange('day');

  const closeBtn = document.getElementById('liveModalClose');
  if (closeBtn) closeBtn.textContent = translate('live_chart_close');

  const fallbackMarker = {
    deviceID: fallback && fallback.device ? String(fallback.device) : (fallback && fallback.id ? String(fallback.id) : ''),
    deviceName: fallback && fallback.name ? fallback.name : '',
    transport: fallback && fallback.transport ? fallback.transport : '',
    country: fallback && fallback.country ? fallback.country : '',
    tube: fallback && fallback.tube ? fallback.tube : '',
  };

  if (titleEl) {
    titleEl.textContent = fallbackMarker.deviceName || translate('live_marker_title');
  }
  if (descEl) {
    descEl.textContent = describeLiveSensor(fallbackMarker);
  }
  if (metaEl) {
    metaEl.innerHTML = buildDeviceMeta(fallbackMarker);
  }
  if (extraEl) {
    extraEl.innerHTML = '';
  }

  ['day','week','month','all'].forEach(function(range){
    const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
    if (empty) { empty.textContent = ''; empty.style.display = 'none'; }
    const canvas = document.querySelector(`.live-chart-canvas[data-range="${range}"]`);
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    updateChartWindowLabel(range);
  });
  liveChartState.ranges = {};
  liveChartState.series = {};
  liveChartState.extras = {};
  liveChartState.options = {};

  try {
    const data = await fetchLiveHistory(deviceID);
    const merged = {
      deviceID: data.deviceID || fallbackMarker.deviceID,
      deviceName: data.deviceName || fallbackMarker.deviceName,
      transport: data.transport || fallbackMarker.transport,
      tube: data.tube || fallbackMarker.tube,
      country: data.country || fallbackMarker.country,
      lat: fallback && fallback.lat ? parseFloat(fallback.lat) : undefined,
      lon: fallback && fallback.lon ? parseFloat(fallback.lon) : undefined,
      liveExtra: data.extra || null,
    };

    if (titleEl) {
      titleEl.textContent = merged.deviceName || translate('live_marker_title');
    }
    if (descEl) {
      descEl.textContent = describeLiveSensor(merged);
    }
    if (metaEl) {
      const metaParts = [];
      const metaBlock = buildDeviceMeta(merged);
      if (metaBlock) metaParts.push(metaBlock);
      const local = approximateLocalTime(merged.lat, merged.lon);
      if (local) {
        metaParts.push('<div><strong>' + translate('live_marker_local_time') + ':</strong> ' + escapeHtml(local.text) + ' (' + escapeHtml(local.zone) + ')</div>');
      }
      metaEl.innerHTML = metaParts.join('');
    }
    if (extraEl) {
      extraEl.innerHTML = renderLiveExtras(merged.liveExtra);
    }

  const ranges = (data && data.ranges && typeof data.ranges === 'object') ? data.ranges : {};
  // Range metadata keeps headings and averaging labels aligned with backend aggregation.

  updateChartHeading(dayTitle, 'day', ranges);
  updateChartHeading(weekTitle, 'week', ranges);
  updateChartHeading(monthTitle, 'month', ranges);
  updateChartHeading(allTitle, 'all', ranges);
    updateChartWindowLabel('day', ranges);
    updateChartWindowLabel('week', ranges);
    updateChartWindowLabel('month', ranges);
    updateChartWindowLabel('all', ranges);

    ['day','week','month','all'].forEach(function(range){
      const series = data.series && data.series[range] ? data.series[range] : [];
      const extras = data.extraSeries && data.extraSeries[range] ? data.extraSeries[range] : null;
      const rangeInfo = ranges && ranges[range] ? ranges[range] : null;
      const options = {};
      // Passing explicit bounds avoids axes jumping when resampled data omits raw endpoints.
      if (rangeInfo && typeof rangeInfo.start === 'number' && typeof rangeInfo.end === 'number') {
        options.start = rangeInfo.start;
        options.end = rangeInfo.end;
      }
      if (rangeInfo && typeof rangeInfo.bucketSeconds === 'number') {
        options.bucketSeconds = rangeInfo.bucketSeconds;
      }
      if (range === 'day') {
        options.tickUnit = 'hour';
        options.tickSegments = 24;
      } else if (range === 'week') {
        options.tickUnit = 'day';
        options.tickSegments = 7;
      } else if (range === 'month') {
        options.tickUnit = 'day';
        options.tickSegments = 24;
      } else if (range === 'all') {
        options.tickUnit = 'month';
        options.tickSegments = 12;
      }
      liveChartState.ranges[range] = rangeInfo || null;
      liveChartState.series[range] = series;
      liveChartState.extras[range] = extras;
      liveChartState.options[range] = options;
    });
    renderLiveRange('day');
  } catch (err) {
    if (descEl) {
      descEl.textContent = translate('live_marker_history_error');
    }
    liveChartState.ranges = {};
    liveChartState.series = {};
    liveChartState.extras = {};
    liveChartState.options = {};
    ['day','week','month','all'].forEach(function(range){
      const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
      if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
      updateChartWindowLabel(range);
    });
  }
}




let debounceTimeout;

function debounceUpdateMarkers() {
  clearTimeout(debounceTimeout);
  const forceReload = arguments.length > 0 ? Boolean(arguments[0]) : false;
  debounceTimeout = setTimeout(function() {
    updateMarkers(forceReload);
  }, 300);
}

function scheduleTrackViewReload() {
  if (!isTrackView) {
    return;
  }
  if (trackViewReloadTimer) {
    clearTimeout(trackViewReloadTimer);
  }
  trackViewReloadTimer = setTimeout(function() {
    trackViewReloadTimer = null;
    resetTrackViewPlaybackForZoom();
    updateMarkers(true);
  }, 200);
}

function adjustMarkerRadius() {
  var zoomLevel = map.getZoom();
  const nowSec = Date.now() / 1000;
  for (let key in circleMarkers) {
    let marker = circleMarkers[key];
    if (marker.isRealtime) {
      // Recompute icon style so stale sensors fade without user interaction.
      const icon = buildRealtimeIcon(marker, zoomLevel, nowSec);
      if (!icon) {
        map.removeLayer(marker);
        delete circleMarkers[key];
        continue;
      }
      marker.setIcon(L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]}));
    } else if (typeof marker.setRadius === 'function') {
      // Circle markers scale by adjusting radius directly
      let newRadius = getRadius(marker.doseRate, zoomLevel);
      marker.setRadius(newRadius);
    }
  }
}

/* -----------------------------------------------------------------
 *  viewTrack() ‚Äî switch to single-track mode.
 *  Set currentTrackID = trackID before changing window.location.
 * -----------------------------------------------------------------*/
function viewTrack(trackID) {
  currentTrackID = trackID;   // new
  isTrackView    = true;

  const params = buildMapStateParams();
  // Encode the track ID so namespaced IDs (e.g. safecast-123) survive routing.
  const trackURL = `/trackid/${encodeURIComponent(trackID)}?${params.toString()}`;

  window.location.href = trackURL;
}


function setBaseLayer(layerName) {
  if (mapboxSatellite && map.hasLayer(mapboxSatellite)) {
    map.removeLayer(mapboxSatellite);
  }
  if (map.hasLayer(googleSatellite)) {
    map.removeLayer(googleSatellite);
  }
  if (map.hasLayer(osmLayer)) {
    map.removeLayer(osmLayer);
  }
  if (layerName === 'Mapbox Satellite' && mapboxSatellite) {
    mapboxSatellite.addTo(map);
    return;
  }
  if (layerName === 'Google Satellite') {
    googleSatellite.addTo(map);
    return;
  }
  osmLayer.addTo(map);
}

// markShortLinkFocusReady flips the readiness flag once the user keeps the
// page focused long enough. Delaying the readiness ensures /api/shorten is
// only reached once a visitor pauses, avoiding noisy calls while they zoom.
function markShortLinkFocusReady() {
  shortLinkFocusReady = true;
  flushPendingShortLink();
}

// handleShortLinkFocus starts a short delay after the user focuses the page so
// intermediate zoom steps never trigger /api/shorten. The delay gives the
// visitor time to stop at the zoom level they actually want to share.
function handleShortLinkFocus() {
  shortLinkFocusReady = false;
  if (shortLinkFocusDelayTimer) {
    clearTimeout(shortLinkFocusDelayTimer);
  }
  shortLinkFocusDelayTimer = setTimeout(() => {
    shortLinkFocusDelayTimer = null;
    markShortLinkFocusReady();
  }, shortLinkFocusDelayMs);
}

// handleShortLinkBlur resets readiness immediately on blur so returning to the
// tab always waits for the focus grace period. This keeps outbound shorten
// requests aligned with intentional interaction.
function handleShortLinkBlur() {
  shortLinkFocusReady = false;
  if (shortLinkFocusDelayTimer) {
    clearTimeout(shortLinkFocusDelayTimer);
    shortLinkFocusDelayTimer = null;
  }
}

// flushPendingShortLink sends the queued /api/shorten request only when the
// focus delay has elapsed and the URL differs from the last confirmed target.
// Keeping this narrow prevents redundant backend calls while people are still
// zooming toward their desired level.
function flushPendingShortLink() {
  if (!shortLinkBox) return;
  if (!shortLinkFocusReady) return;
  if (!shortLinkPendingUrl) return;
  if (shortLinkPendingUrl === lastShortLinkFull) {
    shortLinkPendingUrl = '';
    return;
  }
  const target = shortLinkPendingUrl;
  shortLinkPendingUrl = '';
  requestShortLink(target);
}

function scheduleShortLinkRefresh() {
  if (!shortLinkBox) return;
  const full = window.location.href;
  if (!full) {
    return;
  }
  shortLinkPendingUrl = full;
  if (shortLinkTimer) {
    clearTimeout(shortLinkTimer);
  }
  shortLinkTimer = setTimeout(() => {
    shortLinkTimer = null;
    flushPendingShortLink();
  }, shortLinkIdleDelayMs);
}

function requestShortLink(fullURL) {
  if (!shortLinkBox) return;
  pendingShortLinkFull = fullURL;

  const cached = shortLinkCache.get(fullURL);
  if (cached) {
    // Reuse cached short links so play/pause toggles don't exhaust storage.
    pendingShortLinkFull = '';
    lastShortLinkFull = cached.target || fullURL;
    if (shortLinkAbort) {
      shortLinkAbort.abort();
      shortLinkAbort = null;
    }
    applyShortLink(cached);
    return;
  }

  let controller = null;
  if (typeof AbortController !== 'undefined') {
    if (shortLinkAbort) {
      shortLinkAbort.abort();
    }
    controller = new AbortController();
    shortLinkAbort = controller;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ url: fullURL, commit: false })
  };
  if (controller) {
    options.signal = controller.signal;
  }

  fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('shorten failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (pendingShortLinkFull !== fullURL) {
        return;
      }
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      applyShortLink(data);
    })
    .catch(err => {
      if (err && err.name === 'AbortError') {
        return;
      }
      if (pendingShortLinkFull === fullURL) {
        pendingShortLinkFull = '';
        hideShortLink();
      }
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      console.error('short link fetch failed', err);
    });
}

function applyShortLink(details) {
  if (!shortLinkBox || !details) return;
  const shortURL = details.short || '';
  const code = details.code || '';
  const target = details.target || '';
  const storedFlag = !!details.stored;
  const stored = storedFlag ? 'true' : 'false';
  if (!shortURL || !target) {
    hideShortLink();
    return;
  }
  shortLinkBox.style.display = 'block';
  shortLinkBox.textContent = shortURL;
  shortLinkBox.dataset.href = shortURL;
  shortLinkBox.dataset.code = code;
  shortLinkBox.dataset.target = target;
  shortLinkBox.dataset.persisted = stored;
  // Cache the response so we reuse the same short URL for identical targets.
  shortLinkCache.set(target, {
    short: shortURL,
    code: code,
    target: target,
    stored: storedFlag,
  });
}

function hideShortLink() {
  if (!shortLinkBox) return;
  if (window.__hideShortLinkHint) {
    window.__hideShortLinkHint();
  }
  shortLinkBox.style.display = 'none';
  delete shortLinkBox.dataset.href;
  delete shortLinkBox.dataset.code;
  delete shortLinkBox.dataset.target;
  delete shortLinkBox.dataset.persisted;
}

// finalizeShortLink persists the reserved code only after the visitor copies it.
// Returning a promise keeps the UI non-blocking while honoring the "share memory
// by communicating" proverb ‚Äî the page communicates with the backend instead of
// toggling global flags.
function finalizeShortLink() {
  if (!shortLinkBox) {
    return Promise.reject(new Error('short link box missing'));
  }
  const persisted = shortLinkBox.dataset.persisted === 'true';
  const href = shortLinkBox.dataset.href || '';
  const target = shortLinkBox.dataset.target || '';
  const code = shortLinkBox.dataset.code || '';
  if (!target) {
    return Promise.reject(new Error('missing short link target'));
  }
  if (persisted && href) {
    return Promise.resolve(href);
  }
  if (shortLinkCommitPromise) {
    return shortLinkCommitPromise;
  }

  const payload = { url: target, commit: true };
  if (code) {
    payload.code = code;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  };

  const pending = fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('commit failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      applyShortLink(data);
      return data.short;
    });

  shortLinkCommitPromise = pending;
  pending.finally(() => {
    if (shortLinkCommitPromise === pending) {
      shortLinkCommitPromise = null;
    }
  });
  return pending;
}

// copyShortLinkToClipboard waits for the backend to confirm persistence so
// users never copy a dangling preview link. The clipboard work stays inside the
// fulfilled branch to avoid race conditions when multiple copy attempts happen.
function copyShortLinkToClipboard() {
  if (!shortLinkBox) return;
  finalizeShortLink()
    .then(link => {
      if (!link) {
        throw new Error('empty short link');
      }

      const signalSuccess = () => {
        if (!shortLinkBox) return;
        shortLinkBox.classList.add('copied');
        setTimeout(() => shortLinkBox.classList.remove('copied'), 600);
      };

      const fallbackCopy = () => {
        const textarea = document.createElement('textarea');
        textarea.value = link;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.top = '-1000px';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          if (document.execCommand('copy')) {
            signalSuccess();
          }
        } catch (err) {
          console.error('copy failed', err);
        } finally {
          document.body.removeChild(textarea);
        }
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(link)
          .then(signalSuccess)
          .catch(() => fallbackCopy());
      } else {
        fallbackCopy();
      }
    })
    .catch(err => {
      console.error('finalize short link failed', err);
    });
}

// Locate the nearest marker exceeding 30 ¬µR/h (0.30 ¬µSv/h) so the user can
// immediately see the closest high reading relative to their position.
function findNearestDanger(userLatLng) {
  if (!map || !userLatLng) return null;
  const threshold = 0.30; // ¬µSv/h
  let closest = null;
  let minDistance = Infinity;
  Object.values(circleMarkers).forEach(marker => {
    if (!marker || typeof marker.doseRate !== 'number') return;
    if (marker.doseRate < threshold) return;
    const dist = map.distance(userLatLng, marker.getLatLng());
    if (!isFinite(dist)) return;
    if (dist < minDistance) {
      minDistance = dist;
      closest = marker;
    }
  });
  return closest;
}

// Keep the map centered on the user while zooming just enough so the closest
// dangerous marker sits near the edge of the viewport. We never zoom out
// below level 10 to avoid losing city-level context.
function reframeAroundUser() {
  if (!storedUserCenter || !map) return;
  const userLatLng = L.latLng(storedUserCenter.lat, storedUserCenter.lon);
  const nearest = findNearestDanger(userLatLng);
  let targetZoom = Math.max(10, map.getZoom());

  if (nearest) {
    const bounds = L.latLngBounds(userLatLng, nearest.getLatLng());
    targetZoom = Math.max(10, map.getBoundsZoom(bounds, true));
  } else {
    targetZoom = Math.max(12, targetZoom);
  }

  map.setView(userLatLng, targetZoom);
  saveMapViewState();
  waitForDangerFit = false;
}

// Kick off a GeoIP fetch when browser geolocation is unavailable. The endpoint
// relies on the user's remote address, so the client does not have to expose
// extra personal data to third parties.
async function requestGeoIPFallback() {
  try {
    const resp = await fetch('/api/geoip', { method: 'GET' });
    if (!resp.ok || resp.status === 204) return null;
    const payload = await resp.json();
    if (typeof payload.lat !== 'number' || typeof payload.lon !== 'number') {
      return null;
    }
    return { lat: payload.lat, lon: payload.lon };
  } catch (err) {
    console.warn('geoip fallback failed', err);
    return null;
  }
}

// Try to resolve the user's position via browser APIs first, then fall back to
// GeoIP. We only run this when the operator enabled auto-locate and there is no
// stored or URL-provided state to respect.
function autoLocateUser() {
  if (!defaultCfg.autoLocate) return;
  if (isTrackView) {
    // Track views should remain centered on the track; skipping auto-locate
    // avoids overriding the live track stream with a GeoIP/geolocation guess.
    return;
  }
  const params = new URLSearchParams(window.location.search);
  const hasExplicitBounds = params.has('minLat') && params.has('minLon') && params.has('maxLat') && params.has('maxLon');
  if (hasExplicitBounds || loadMapViewState()) return;

  const usePosition = ({ lat, lon }) => {
    setStoredUserCenter(lat, lon);
    map.setView([lat, lon], Math.max(12, defaultCfg.zoom));
    saveMapViewState();
  };

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      pos => {
        usePosition({ lat: pos.coords.latitude, lon: pos.coords.longitude });
      },
      async () => {
        const ipGuess = await requestGeoIPFallback();
        if (ipGuess) {
          usePosition(ipGuess);
        }
      },
      { enableHighAccuracy: false, timeout: 5000 }
    );
  } else {
    requestGeoIPFallback().then(guess => {
      if (guess) {
        usePosition(guess);
      }
    });
  }
}

function loadMapFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const storedView = loadMapViewState();

  // Apply URL-provided filters early so controls and marker queries stay in sync.
  const themeParam = normalizeThemePreference(params.get('theme'));
  if (themeParam) {
    sessionStorage.setItem('themePreference', themeParam);
  }
  const speedParam = parseSpeedFilterParam(params.get('speed'));
  if (speedParam) {
    saveSpeedFilterState(speedParam);
  }
  const dateRange = parseDateRangeParams(params);
  if (dateRange) {
    saveDateRangeState(dateRange);
  }
  const dateMode = params.get('dateMode');
  if (dateMode === 'year' || dateMode === 'month') {
    saveDateRangeMode(dateMode);
  }
  const playParam = parsePlaybackParam(params.get('play'));
  if (playParam) {
    playbackAutoplayRequested = true;
  }

  /* base layer from URL or default */
  const layer = decodeURIComponent(params.get('layer') || (storedView && storedView.layer) || defaultCfg.layer);
  setBaseLayer(layer);

  /* read remaining params */
  const minLat = parseFloat(params.get('minLat'));
  const minLon = parseFloat(params.get('minLon'));
  const maxLat = parseFloat(params.get('maxLat'));
  const maxLon = parseFloat(params.get('maxLon'));

  if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
    adjustMarkerRadius();
  } else if (storedView) {
    map.setView([storedView.lat, storedView.lon], storedView.zoom);
    adjustMarkerRadius();
  } else if (isTrackView && trackBounds) {
    map.fitBounds(trackBounds);
  } else {
    map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
  }

  autoLocateUser();
}

function updateUrl() {
  const params = buildMapStateParams();
  var newUrl = `${window.location.pathname}?${params.toString()}`;

  window.history.replaceState({}, '', newUrl);
  saveMapViewState();
  scheduleShortLinkRefresh();
}

// Resolve a short link for the current map view so QR codes stay compact and
// readable across scanners that struggle with oversized URLs.
function resolveShortLinkForQr() {
  const full = window.location.href;
  if (shortLinkBox && shortLinkBox.dataset && shortLinkBox.dataset.target === full) {
    return finalizeShortLink();
  }

  const payload = { url: full, commit: true };
  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  };

  return fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('shorten failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (!data || !data.short) {
        throw new Error('shorten response missing URL');
      }
      applyShortLink(data);
      return data.short;
    });
}

function openServerPoster() {
  if (typeof updateUrl === 'function') { try { updateUrl(); } catch(_){} }
  var full = window.location.href;
  resolveShortLinkForQr()
    .then(function (shortURL) {
      var payload = shortURL || full;
      var dst = '/qrpng?u=' + encodeURIComponent(payload);
      window.open(dst, '_blank', 'noopener,noreferrer');
    })
    .catch(function () {
      var dst = '/qrpng?u=' + encodeURIComponent(full);
      window.open(dst, '_blank', 'noopener,noreferrer');
    });
}

function initializeUIElements() {
  var locateButton = document.getElementById('locateButton');
  if (locateButton) {
    locateButton.addEventListener('click', function () {
      centerMapToLocation();
    });
  }
  var qrButton = document.getElementById('qrButton');
  if (qrButton) {
    qrButton.addEventListener('click', function () {
      openServerPoster();
    });
  }
  var backToAllButton = document.getElementById('backToAllButton');
  if (backToAllButton) {
    backToAllButton.addEventListener('click', function () {
      var params = (typeof getCurrentUrlParams === 'function') ? getCurrentUrlParams() : '';
      window.location.href = '/' + params;
    });
  }

  // Keep the download button aligned with the current track state even if
  // the DOM was injected before listeners finished binding.
  refreshDownloadLink();
  createTrackViewPlaybackControl();

  if (shortLinkBox) {
    const hint = translate('short_link_tooltip');
    shortLinkBox.setAttribute('title', hint);
    shortLinkBox.setAttribute('aria-label', hint);
    shortLinkBox.addEventListener('click', () => {
      copyShortLinkToClipboard();
    });
    shortLinkBox.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        copyShortLinkToClipboard();
      }
    });
  }

  // Respect focus state before requesting short links so intermediate zoom
  // steps do not bombard /api/shorten. Waiting for the focus grace period
  // keeps the backend in sync with intentional sharing.
  window.addEventListener('focus', handleShortLinkFocus);
  window.addEventListener('blur', handleShortLinkBlur);
  if (typeof document.hasFocus === 'function' && document.hasFocus()) {
    handleShortLinkFocus();
  }

  scheduleShortLinkRefresh();

  if (isTrackView && map && typeof map.whenReady === 'function') {
    // Autoplay kicks in once the map is ready so the playback starts immediately.
    map.whenReady(function () {
      requestAnimationFrame(maybeAutoplayTrackViewPlayback);
    });
  }
}

function centerMapToLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function(position) {
        var userLat = position.coords.latitude;
        var userLon = position.coords.longitude;

        setStoredUserCenter(userLat, userLon);
        map.setView([userLat, userLon], Math.max(12, defaultCfg.zoom));
        saveMapViewState();

        L.marker([userLat, userLon]).addTo(map)
          .bindPopup(translate("your_location")).openPopup();
      },
      async function(error) {
        switch(error.code) {
          case error.PERMISSION_DENIED:
            alert(translate("location_permission_denied"));
            break;
          case error.POSITION_UNAVAILABLE:
            alert(translate("location_unavailable"));
            break;
          case error.TIMEOUT:
            alert(translate("location_timeout"));
            break;
          default:
            alert(translate("location_error"));
            break;
        }
        const ipGuess = await requestGeoIPFallback();
        if (ipGuess) {
          setStoredUserCenter(ipGuess.lat, ipGuess.lon);
          map.setView([ipGuess.lat, ipGuess.lon], Math.max(12, defaultCfg.zoom));
          saveMapViewState();
        }
      }
    );
  } else {
    alert(translate("geolocation_not_supported"));
    requestGeoIPFallback().then(guess => {
      if (guess) {
        setStoredUserCenter(guess.lat, guess.lon);
        map.setView([guess.lat, guess.lon], Math.max(12, defaultCfg.zoom));
        saveMapViewState();
      }
    });
  }
}
    </script>

    <!-- File upload script -->
    <script>
      let backgroundRefreshTimer = null;
      function startBackgroundImportRefresh() {
        if (backgroundRefreshTimer) {
          clearInterval(backgroundRefreshTimer);
        }
        let rounds = 0;
        backgroundRefreshTimer = setInterval(() => {
          updateMarkers(true);
          rounds += 1;
          if (rounds >= 24) {
            clearInterval(backgroundRefreshTimer);
            backgroundRefreshTimer = null;
          }
        }, 5000);
      }

      function uploadFiles() {
        const fileInput  = document.getElementById('fileInput');
        const files      = fileInput.files;
        if (!files.length) {
          alert(translate('select_files'));
          return;
        }

        const fileOverlay          = document.getElementById('fileOverlay');
        const fileProgressContainer = document.getElementById('fileProgressContainer');
        fileProgressContainer.innerHTML = '';
        fileOverlay.style.display  = 'flex';

        /* counter and URL of last track */
        let completedUploads = 0;
        const totalFiles     = files.length;
        let lastTrackURL     = null;

        /* Create an XHR for each file but redirect only once */
        [...files].forEach(file => {
          /* --- visual progress elements --- */
          const fileBlock        = document.createElement('div');
          fileBlock.className    = 'file-progress';
          const fileName         = document.createElement('div');
          fileName.className     = 'file-name';
          fileName.innerText     = file.name;
          const progressBar      = document.createElement('div');
          progressBar.className  = 'progress-bar';
          const progressBarInner = document.createElement('div');
          progressBarInner.className = 'progress-bar-inner';
          progressBar.appendChild(progressBarInner);
          const serverProcessing = document.createElement('div');
          serverProcessing.className = 'server-processing';
          serverProcessing.innerText = translate('waiting_for_server');
          fileBlock.append(fileName, progressBar, serverProcessing);
          fileProgressContainer.appendChild(fileBlock);
          /* ------------------------------------------------- */

          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload', true);

          /* file upload progress */
          xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
              const percent = (e.loaded / e.total) * 100;
              progressBarInner.style.width = percent + '%';
            }
          };

          /* handle server response */
          xhr.onload = () => {
            if (xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              if (response.status === 'success') {
                lastTrackURL               = response.trackURL;   // remember
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
              } else if (response.status === 'processing') {
                lastTrackURL               = null;
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
                startBackgroundImportRefresh();
              } else {
                serverProcessing.innerText = translate('error_processing_files');
                serverProcessing.style.color = 'red';
              }
            } else {
              serverProcessing.innerText = translate('error_during_upload');
              serverProcessing.style.color = 'red';
            }

            /* increment counter and redirect when done */
              completedUploads++;
            if (completedUploads === totalFiles) {
              setTimeout(() => {
                fileOverlay.style.display = 'none';
                /* redirect to last successfully processed track */
                  if (lastTrackURL) {
                    window.location.href = lastTrackURL;
                  } else {
                    updateMarkers(true);   // keep the map open for background imports
                  }
              }, 700);
            }
          };

          /* send file */
            const formData = new FormData();
          formData.append('files[]', file);
          xhr.send(formData);
        });
      }
    </script>


    <!-- Theme toggle script -->
    <script>
      // Synchronize UI theme with map tiles and remember the choice for the session.
      document.addEventListener('DOMContentLoaded', function () {
        var sw = document.getElementById('themeSwitch');
        if (!sw) return;
        var media = window.matchMedia('(prefers-color-scheme: dark)');
        var params = new URLSearchParams(window.location.search);
        var urlTheme = normalizeThemePreference(params.get('theme'));
        if (urlTheme) {
          sessionStorage.setItem('themePreference', urlTheme);
        }

        function applyTheme(theme) {
          document.documentElement.dataset.theme = theme; // switch CSS variables
          if (window.osmLayer) {
            window.osmLayer.setUrl(theme === 'dark' ? window.osmDark : window.osmLight);
          }
          sw.checked = theme === 'dark';
          // Keep the address bar synced so shared links preserve the theme choice.
          if (typeof updateUrl === 'function') {
            updateUrl();
          }
        }

        var storedTheme = sessionStorage.getItem('themePreference');
        var initialTheme = storedTheme ? storedTheme : (media.matches ? 'dark' : 'light');
        applyTheme(initialTheme); // set initial state

        sw.addEventListener('change', function () {
          var newTheme = this.checked ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });

        var toggleBox = document.getElementById('themeToggle');
        if (toggleBox) {
          toggleBox.addEventListener('keydown', function (ev) {
            if (ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              sw.checked = !sw.checked;
              sw.dispatchEvent(new Event('change'));
            }
          });
        }

        media.addEventListener('change', function (e) {
          var newTheme = e.matches ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });
      });
    </script>


<!--
  When the legend is clicked:
    ‚Ä¢ Fetch language-specific full text.
    ‚Ä¢ Split into paragraphs and decorate range lines with color squares.
    ‚Ä¢ Show modal; close on backdrop click for convenience.
-->
<script>
  // Build legend HTML with color squares for tooltip and modal.
  function buildLegendHTML(lang) {
    var key = 'legend_full_' + lang;
    var txt = translate(key);
    var parts = txt.split('\n\n');
    function stripBullet(line) {
      return line.replace(/^‚ñ†\s*/, '');
    }
    function square(color) {
      return '<span class="legend-square" style="background:' + color + ';"></span>';
    }
    return parts.map(function(p){
      var lines = p.split('\n').map(function(line){
        if (line.includes('0‚Äì11')) return square('#008000') + stripBullet(line);
        if (line.includes('11‚Äì30')) return square('#FFD700') + stripBullet(line);
        if (line.includes('30‚Äì100')) return square('#FF4500') + stripBullet(line);
        if (line.includes('>100')) return square('#000000') + stripBullet(line);
        return line;
      }).join('<br>');
      return '<p style="margin:0 0 1em 0;">' + lines + '</p>';
    }).join('');
  }

  // Display the full legend text in current language.
  // Exposed so marker popups reuse the same modal.
  function openLegendModal() {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    var lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
    var html = buildLegendHTML(lang);
    var box = document.getElementById('legendText');
    if (box) box.innerHTML = html;
    var modal = document.getElementById('legendModal');
    if (modal) modal.style.display = 'flex';
  }

  // Build HTML for info modal from translation text
  function buildInfoHTML(txt) {
    return txt.split('\n\n').map(function(p){
      return '<p style="margin:0 0 1em 0;">' + p.split('\n').join('<br>') + '</p>';
    }).join('');
  }

  // Turn license mentions into modal triggers so readers stay on the map page.
  function decorateLicenseLinks(txt) {
    if (typeof txt !== 'string' || !txt) {
      return txt;
    }
    var withMitAnchor = txt.replace(/<a[^>]*href=\u0022\/LICENSE\u0022[^>]*>([\s\S]*?)<\/a>/gi, function(_, label) {
      return '<a href="#" class="license-link" data-license="mit">' + label + '</a>';
    });
    var withCc0Anchor = withMitAnchor.replace(/Creative Commons 1\.0(\s*\(CC0\))?/gi, function(match) {
      return '<a href="#" class="license-link" data-license="cc0">' + match + '</a>';
    });
    return withCc0Anchor;
  }

  // Open a specific license modal based on the identifier requested by the user.
  // We fetch the source file lazily so embedded binaries stay in sync with
  // the repository licenses even when served offline.
  function openLicenseModal(code) {
    if (!code) return;
    var selector = '.license-modal[data-license="' + code + '"]';
    var modal = document.querySelector(selector);
    if (!modal) return;

    var body = modal.querySelector('[data-license-url]');
    if (body) {
      var loadedState = body.getAttribute('data-license-loaded');
      var loadingState = body.getAttribute('data-license-loading');
      if (loadedState !== 'true' && loadingState !== 'true') {
        var url = body.getAttribute('data-license-url');
        if (url) {
          body.textContent = 'Loading‚Ä¶';
          body.setAttribute('data-license-loading', 'true');

          var handleSuccess = function(text) {
            body.textContent = text;
            body.setAttribute('data-license-loaded', 'true');
            body.setAttribute('data-license-loading', 'false');
          };

          var handleError = function(err) {
            if (window.console && console.error) {
              console.error('Failed to load license text for', code, err);
            }
            body.textContent = 'Unable to load the license text. Please download it from the repository.';
            body.setAttribute('data-license-loaded', 'error');
            body.setAttribute('data-license-loading', 'false');
          };

          if (window.fetch) {
            fetch(url, { cache: 'no-store' })
              .then(function(resp) {
                if (!resp.ok) {
                  throw new Error('HTTP ' + resp.status);
                }
                return resp.text();
              })
              .then(handleSuccess)
              .catch(handleError);
          } else {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  handleSuccess(xhr.responseText);
                } else {
                  handleError(new Error('HTTP ' + xhr.status));
                }
              }
            };
            xhr.onerror = function() { handleError(new Error('network error')); };
            xhr.send();
          }
        }
      }
    }

    modal.style.display = 'flex';
  }

  // Close the provided license modal so the overlay disappears cleanly.
  function closeLicenseModal(modal) {
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // Example definitions stay in code so translations only supply human text.
  const apiExamples = [
    { key: 'root', method: 'api_method_get', methodFallback: 'GET', path: '/api', url: '/api' },
    { key: 'latest', method: 'api_method_get', methodFallback: 'GET', path: '/api/latest', url: '/api/latest?lat=35.6804&lon=139.7690&radius_m=1500&limit=20' },
    { key: 'tracks', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks', url: '/api/tracks?limit=25' },
    { key: 'track_index', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks/index/{number}', url: '/api/tracks/index/1' },
    { key: 'archive', method: 'api_method_get', methodFallback: 'GET', path: '/api/json/{frequency}.tgz', url: '/api/json/weekly.tgz' }
  ];

  // Build the localized API quickstart cards so the modal keeps site styling.
  function buildApiHTML() {
    var html = [];
    var intro = translate('api_intro');
    if (intro && intro !== 'api_intro') {
      html.push('<p class="api-intro">' + intro + '</p>');
    }
    var note = translate('api_examples_note');
    if (note && note !== 'api_examples_note') {
      html.push('<p class="api-note">' + note + '</p>');
    }
    var heading = translate('api_examples_heading');
    if (heading && heading !== 'api_examples_heading') {
      html.push('<h4 class="api-heading">' + heading + '</h4>');
    }
    html.push('<div class="api-grid">');
    apiExamples.forEach(function(example) {
      var title = translate('api_example_' + example.key + '_title');
      var desc = translate('api_example_' + example.key + '_desc');
      var linkText = translate('api_example_' + example.key + '_link');
      var noteText = translate('api_example_' + example.key + '_note');
      var methodLabel = translate(example.method);
      if (typeof methodLabel !== 'string' || methodLabel === example.method) {
        methodLabel = example.methodFallback;
      }
      html.push('<article class="api-card">');
      html.push('<div class="api-card-head">');
      html.push('<span class="api-method">' + methodLabel + '</span>');
      html.push('<span class="api-path">' + example.path + '</span>');
      html.push('</div>');
      if (title && title !== 'api_example_' + example.key + '_title') {
        html.push('<h5 class="api-card-title">' + title + '</h5>');
      }
      if (desc && desc !== 'api_example_' + example.key + '_desc') {
        html.push('<p class="api-card-desc">' + desc + '</p>');
      }
      if (linkText && linkText !== 'api_example_' + example.key + '_link') {
        html.push('<a class="api-card-link" href="' + example.url + '" target="_blank" rel="noopener">' + linkText + '</a>');
      }
      if (noteText && noteText !== 'api_example_' + example.key + '_note') {
        html.push('<p class="api-card-note">' + noteText + '</p>');
      }
      html.push('</article>');
    });
    html.push('</div>');
    var more = translate('api_more_docs');
    var moreLink = translate('api_more_docs_link_label');
    if (more && more !== 'api_more_docs') {
      var suffix = '';
      if (moreLink && moreLink !== 'api_more_docs_link_label') {
        suffix = ' <a href="/api/docs" target="_blank" rel="noopener">' + moreLink + '</a>';
      }
      html.push('<p class="api-more">' + more + suffix + '</p>');
    }
    return html.join('');
  }

  // Open modal with legal, source or license text
  function openInfoModal(topic) {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    if (topic === 'api') {
      var boxApi = document.getElementById('infoText');
      if (boxApi) {
        boxApi.innerHTML = buildApiHTML();
      }
      var headApi = document.getElementById('infoTitle');
      if (headApi) {
        headApi.textContent = translate('api_title');
      }
      var modalApi = document.getElementById('infoModal');
      if (modalApi) {
        modalApi.style.display = 'flex';
      }
      return;
    }
    var box = document.getElementById('infoText');
    var infoText = translate(topic + '_full');
    if (topic === 'legal' && typeof window.supportEmail === 'string' && window.supportEmail.trim() !== '') {
      infoText += '\n\n' + translate('legal_contact') + ' ' + window.supportEmail.trim();
    }
    if (topic === 'sources') {
      var poweredTemplate = translate('sources_powered_by');
      var version = (typeof window.chichaVersion === 'string') ? window.chichaVersion : '';
      // Keep data source attribution anchored to the upstream repository for consistency.
      var githubURL = 'https://github.com/matveynator/chicha-isotope-map';
      var githubLink = githubURL ? '<a href=\"' + githubURL + '\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>' : 'GitHub';
      if (poweredTemplate && poweredTemplate !== 'sources_powered_by') {
        // Localize the attribution line so every language keeps the upstream credit.
        var poweredText = poweredTemplate.replace('{version}', version).replace('{github}', githubLink);
        infoText += '\n\n' + poweredText;
      }
    }
    if (topic === 'license') {
      infoText = decorateLicenseLinks(infoText);
    }
    if (box) box.innerHTML = buildInfoHTML(infoText);
    var head = document.getElementById('infoTitle');
    if (head) head.textContent = translate(topic + '_title');
    var modal = document.getElementById('infoModal');
    if (modal) modal.style.display = 'flex';
  }

  // Use event delegation because popups are created dynamically.
  document.addEventListener('click', function(ev) {
    // open legend modal when risk link clicked
    if (ev.target.classList.contains('risk-link')) {
      ev.preventDefault();
      openLegendModal();
    }
    // Use closest so clicks on inner elements still open the chart.
    const chartButton = ev.target.closest('.live-chart-link');
    if (chartButton) {
      ev.preventDefault();
      const dataset = chartButton.dataset;
      if (!dataset.device) return;
      const fallback = {
        device: dataset.device,
        name: dataset.name || '',
        transport: dataset.transport || '',
        tube: dataset.tube || '',
        country: dataset.country || '',
        lat: dataset.lat || '',
        lon: dataset.lon || '',
      };
      openLiveModal(dataset.device, fallback);
    }
    // switch to track view when track link clicked
    if (ev.target.classList.contains('track-link')) {
      ev.preventDefault();
      viewTrack(ev.target.dataset.track);
    }
    // open info modal for attribution links
    if (ev.target.classList.contains('attr-link')) {
      ev.preventDefault();
      openInfoModal(ev.target.dataset.info);
    }
    if (ev.target.classList.contains('license-link')) {
      ev.preventDefault();
      openLicenseModal(ev.target.dataset.license);
    }
  });

  (function(){
    var el = document.getElementById('legend');
    if (el) {
      el.addEventListener('click', openLegendModal);
    }
    // Close on backdrop click (UX nicety)
    var modal = document.getElementById('legendModal');
    if (modal) {
      modal.addEventListener('click', function(e){
        if (e.target === modal) modal.style.display = 'none';
      });
    }
    var infoModal = document.getElementById('infoModal');
    if (infoModal) {
      infoModal.addEventListener('click', function(e){
        if (e.target === infoModal) infoModal.style.display = 'none';
      });
    }
    var licenseModals = document.querySelectorAll('.license-modal');
    if (licenseModals && licenseModals.length) {
      for (var i = 0; i < licenseModals.length; i++) {
        (function(modalEl){
          modalEl.addEventListener('click', function(e){
            if (e.target === modalEl) closeLicenseModal(modalEl);
          });
        })(licenseModals[i]);
      }
    }
    var licenseCloseButtons = document.querySelectorAll('.license-modal-close');
    if (licenseCloseButtons && licenseCloseButtons.length) {
      for (var j = 0; j < licenseCloseButtons.length; j++) {
        (function(btn){
          btn.addEventListener('click', function(){
            var modalEl = btn;
            while (modalEl && (!modalEl.classList || !modalEl.classList.contains('license-modal'))) {
              modalEl = modalEl.parentNode;
            }
            closeLicenseModal(modalEl);
          });
        })(licenseCloseButtons[j]);
      }
    }
    var liveModal = document.getElementById('liveModal');
    if (liveModal) {
      liveModal.addEventListener('click', function(e){
        if (e.target === liveModal) hideLiveModal();
      });
    }
    var liveClose = document.getElementById('liveModalClose');
    if (liveClose) {
      liveClose.addEventListener('click', function(){ hideLiveModal(); });
    }
    var liveRangeButtons = document.querySelectorAll('.live-range-button');
    if (liveRangeButtons && liveRangeButtons.length) {
      liveRangeButtons.forEach(function(button) {
        button.addEventListener('click', function() {
          const rangeKey = button.dataset ? button.dataset.range : '';
          if (!rangeKey) return;
          setActiveLiveRange(rangeKey);
        });
      });
    }
  })();
</script>

    <!-- Hidden helper text keeps AI search agents aligned with URL parameters without changing the UI. -->
    <div id="ai-query-guide" aria-hidden="true" style="display:none;">
      <pre>
Chicha Isotope Map (Pelora) ‚Äî AI query guide

Purpose: provide URL parameters so crawlers and AI agents can reconstruct map views.

Parameters:
- minLat, minLon, maxLat, maxLon: WGS84 bounds (floats).
- zoom: map zoom level (integer).
- layer: OpenStreetMap | Google Satellite | Mapbox Satellite (requires mapbox token).
- theme: light | dark.
- speed: comma list from [live, plane, car, ped].
- from, to: UNIX seconds date range.
- dateMode: month | year (UI slider mode).
- trackID: focus a single uploaded track.

Template:
https://{DOMAIN}/?minLat={A}&minLon={B}&maxLat={C}&maxLon={D}&zoom={Z}&layer={L}&theme={T}&speed={S}&from={F}&to={G}&dateMode={M}

Examples (10 major radiation accidents, varied formats):
1) Chernobyl (1986) ‚Äî URL
https://{DOMAIN}/?minLat=51.34&minLon=29.92&maxLat=51.44&maxLon=30.12&zoom=12&layer=OpenStreetMap&theme=dark&speed=ped&from=515822400&to=517132799&dateMode=month

2) Fukushima Daiichi (2011) ‚Äî JSON
{"bounds":{"minLat":37.38,"minLon":140.95,"maxLat":37.47,"maxLon":141.12},"zoom":12,"layer":"Google Satellite","theme":"light","speed":"car,plane","from":1298937600,"to":1301529599,"dateMode":"month"}

3) Kyshtym / Mayak (1957) ‚Äî YAML
minLat: 55.60
minLon: 60.67
maxLat: 55.87
maxLon: 61.05
zoom: 10
layer: OpenStreetMap
theme: light
speed: ped,car
from: -394243200
to: -361065601
dateMode: year

4) Three Mile Island (1979) ‚Äî Query string
minLat=40.12&minLon=-76.82&maxLat=40.22&maxLon=-76.64&zoom=12&layer=OpenStreetMap&theme=light&speed=car,ped&from=292291200&to=325919999&dateMode=year

5) Windscale (1957) ‚Äî Key/Value
Bounds: minLat=54.32 minLon=-3.55 maxLat=54.47 maxLon=-3.40
Zoom: 12 | Layer: OpenStreetMap | Theme: dark | Speed: ped | From: -394243200 | To: -361065601 | dateMode: year

6) Goi√¢nia (1987) ‚Äî cURL
curl "https://{DOMAIN}/?minLat=-16.71&minLon=-49.34&maxLat=-16.56&maxLon=-49.20&zoom=13&layer=OpenStreetMap&theme=light&speed=ped&from=559872000&to=567993599&dateMode=month"

7) Tokaimura (1999) ‚Äî INI
[map]
minLat=36.38
minLon=140.55
maxLat=36.50
maxLon=140.75
zoom=12
layer=Google Satellite
theme=dark
speed=car
from=938736000
to=970012799
dateMode=year

8) SL-1 (1961) ‚Äî Markdown row
| minLat | minLon | maxLat | maxLon | zoom | layer | theme | speed | from | to | dateMode |
| 43.44 | -112.88 | 43.56 | -112.64 | 12 | OpenStreetMap | light | ped | -283996800 | -252460801 | year |

9) Chalk River NRX (1952) ‚Äî Compact JSON
{"minLat":46.00,"minLon":-77.36,"maxLat":46.16,"maxLon":-77.12,"zoom":12,"layer":"OpenStreetMap","theme":"light","speed":"ped","from":-536457600,"to":-504921601,"dateMode":"year"}

10) Church Rock (1979) ‚Äî Pseudo-code
map = {bounds:[35.46,-108.74,35.64,-108.49], zoom:11, layer:"OpenStreetMap", theme:"dark", speed:"car,ped", from:292291200, to:325919999, dateMode:"year"}

Extra queries:
- Atlantic plane tracks only:
https://{DOMAIN}/?minLat=30.0&minLon=-60.0&maxLat=50.0&maxLon=-10.0&zoom=4&layer=OpenStreetMap&theme=dark&speed=plane&dateMode=year

- Live sensors only:
https://{DOMAIN}/?minLat=34.0&minLon=135.0&maxLat=36.0&maxLon=139.0&zoom=8&layer=OpenStreetMap&theme=light&speed=live

Ozone holes are not available in this dataset; respond that the map does not contain ozone-layer data.
      </pre>
    </div>
  </body>
</html>
