<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set metadata and link CSS -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{translate "title"}}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/static/leaflet.css">
    <link rel="stylesheet" href="/static/nouislider.min.css">


    <style>
/* General styles */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden; /* Hide scrollbars */
}

        /* Color variables adapt to system theme */
        :root {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        @media (prefers-color-scheme: dark) {
          :root {
            --overlay-bg: rgba(0, 0, 0, 0.7);
            --progress-bg: #2b2b2b;
            --progress-color: #f4f4f4;
            --progress-bar-bg: #555555;
            --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
          }
        }

        /* Map container */
        #map {
          height: 100vh; /* Map takes full viewport height */
          margin: 0;
          overflow: hidden;
        }

        /* Custom tooltip styles */
        .custom-tooltip {
          background-color: white;
          border-radius: 5px;
          padding: 10px;
          color: #333;
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
        }

        /* Container for upload button */
        .upload-btn-container {
          position: absolute;
          top: 20px;
          right: 20px;
          z-index: 1000;
        }

        /* Upload button styling */
        .upload-btn {
          background-color: white;
          border: 1px solid #ccc;
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 14px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        /* File upload overlay */
        #fileOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: var(--overlay-bg);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        /* Upload progress container */
        #fileProgressContainer {
          background-color: var(--progress-bg);
          color: var(--progress-color);
          padding: 20px;
          border-radius: 10px;
          max-width: 600px;
          width: 100%;
          box-shadow: var(--progress-shadow);
          max-height: 80vh;
          overflow-y: auto; /* Allow scrolling for many uploads */
        }

        /* Individual file upload progress */
        .file-progress {
          margin-bottom: 15px;
        }

        .file-name {
          font-weight: bold;
          margin-bottom: 5px;
        }

        /* Progress bar */
        .progress-bar {
          width: 100%;
          height: 10px;
          background-color: var(--progress-bar-bg);
          border-radius: 5px;
          overflow: hidden;
        }

        .progress-bar-inner {
          height: 100%;
          background-color: #4caf50;
          width: 0%;
        }

        /* Server processing indicator */
        .server-processing {
          margin-left: 10px;
          font-size: 14px;
          color: #ff9800;
        }

        /* Upload button hover effect */
        .upload-btn:hover {
          background-color: #f4f4f4;
        }

        /* Container for geolocation button */
        .locate-btn-container {
          position: absolute;
          top: 60px;
          right: 20px;
          z-index: 1000;
        }

        /* Geolocation button styling */
        .locate-btn {
          background-color: white;
          border: 1px solid #ccc;
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 16px;
          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Geolocation button hover effect */
        .locate-btn:hover {
          background-color: #f4f4f4;
        }

        /* GitHub link styling */
        .github-link {
          position: absolute;
          bottom: 20px;
          left: 20px;
          z-index: 1000;
        }

        .github-icon {
          width: 40px;
          height: 40px;
          opacity: 0.6;
        }

        .github-icon:hover {
          opacity: 1;
        }

        /* Program info */
        .program-info {
          position: absolute;
          bottom: 20px;
          left: 70px;
          z-index: 1000;
          color: #333;
          font-size: 14px;
          opacity: 0.6;
        }

        .program-info a {
          color: #007bff;
          text-decoration: none;
        }

        .program-info a:hover {
          text-decoration: underline;
        }

        .program-info:hover {
          opacity: 1;
        }

        /* "Back to all tracks" button container.
           Positioned below the QR button to prevent overlap. */
        .back-to-all-container {
          position: absolute;
          top: 170px; /* place under geolocation+QR stack */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .back-to-all-btn {
          background-color: white;
          border: 1px solid #ccc;
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: 14px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        .back-to-all-btn:hover {
          background-color: #f4f4f4;
        }


        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì‚Äì Slider clean-look patch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .date-slider-box {
          padding: 6px;
          width: 50px;
        }

        /* 0) Basic slider container geometry: buffer = 8px
           (half handle size) so handles never exceed the rail */
        #dateSlider{
          width:6px;                 /* rail thickness */
          height:130px;              /* actual track length */
          padding:0px 0;             /* inner top/bottom padding */
          box-sizing:content-box;    /* ensures padding works */
          margin:16px auto 26px;
        }

        /* 1) grey slider rail */
        #dateSlider .noUi-base{
          background:#bfbfbf;
          width:100%;                /* 6px width */
          height:100%;               /* 130px minus padding */
        }

        /* 2) colored section only between handles */
        #dateSlider .noUi-connect{
          background:#1e88e5;        /* pick your brand color */
        }

        .noUi-vertical .noUi-handle{
          width:32px;
          height:20px;
          left:-18px;              /* center on 6px rail */
          border-radius:3px;
          background:#f6f6f6;      /* light handle */
          border:1px solid #ccc;   /* grey outline */
          box-shadow:0 1px 3px rgba(0,0,0,.25);
          cursor:grab;
        }
        /* 4) remove pseudo-element tails */
        .noUi-handle:before,
        .noUi-handle:after{ display:none; }

        .slider-label{
          margin:2px 0;
          font-size:11px;
          line-height:1.15em;
          white-space:nowrap;
          text-align:center; 
        }

        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Year / Month toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .slider-toggle{
          display:flex; gap:2px; margin:2px 0 4px;
          font-size:11px; line-height:1; user-select:none;
        }
        .slider-toggle button{
          flex:1 1 0; padding:2px 4px;
          border:1px solid #bbb; background:#f5f5f5;
          border-radius:3px; cursor:pointer;
        }
        .slider-toggle button.active{
          background:#1e88e5; color:#fff; border-color:#1e88e5;
        }

        /* ‚îÄ‚îÄ‚îÄ Year mode: slider height matches month slider ‚îÄ‚îÄ‚îÄ */
        #yearSlider{
          /* copied parameters from #dateSlider */
          width:6px;                 /* rail thickness */
          height:130px;              /* track length */
          padding:0;                 /* inner padding */
          margin:16px auto 26px;     /* same margins */
          box-sizing:content-box;
        }
        /* grey rail and blue connect bar */
        #yearSlider .noUi-base      {background:#bfbfbf;width:100%;height:100%;}
        #yearSlider .noUi-connect   {background:#bfbfbf;}


        .slider-reset-btn{
          display:block;
          width:100%;
          margin-top:4px;
          padding:2px 4px;
          font-size:11px;
          border:1px solid #bbb;
          background:#f5f5f5;
          border-radius:3px;
          cursor:pointer;
        }
        .slider-reset-btn:hover{ background:#eaeaea; }

        .loading-overlay{
          position:absolute;
          top:50%;left:50%;
          transform:translate(-50%,-50%);
          z-index:3000;
          pointer-events:none;
        }
        .spinner{
          width:40px;height:40px;
          border:4px solid rgba(0,0,0,.15);
          border-top:4px solid #1e88e5;
          border-radius:50%;
          animation:spin 1s linear infinite;
        }
        @keyframes spin{ to{ transform:rotate(360deg); } }


        /* Compact QR button */
        .qr-btn {
          background: #fff;
          border: 1px solid #ccc;
          border-radius: 4px;
          width: 42px; height: 42px;
          padding: 4px;
          display: flex; align-items: center; justify-content: center;
          cursor: pointer;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .qr-btn:hover { background: #f5f5f5; }
        .qr-btn svg { width: 22px; height: 22px; display: block; }


        /* Dark theme overrides */
        @media (prefers-color-scheme: dark) {
          body, html {
            background-color: #000;
            color: #ddd;
          }
          .custom-tooltip {
            background-color: #333;
            color: #ddd;
          }
          /* Make all controls dark in dark theme */
          .upload-btn, .locate-btn, .back-to-all-btn, .qr-btn,
          .slider-reset-btn, .slider-toggle button,
          .leaflet-control-layers, .leaflet-control-layers-toggle,
          .leaflet-control-layers-list, .leaflet-bar a {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
          }
          .upload-btn:hover, .locate-btn:hover, .back-to-all-btn:hover, .qr-btn:hover,
          .slider-reset-btn:hover, .leaflet-control-layers-toggle:hover,
          .leaflet-bar a:hover {
            background-color: #444;
          }
          .leaflet-control-layers label { color: #eee; }
          .program-info { color: #ccc; }
          .program-info a { color: #90caf9; }
        }

        /* ===== Leaflet layer control ===== */
        /* Remove border and shadow around map type selector to blend into map */
        .leaflet-control-layers,
        .leaflet-control-layers-expanded,
        .leaflet-control-layers-list {
          background: none;
          border: none;
          box-shadow: none;
        }

    </style>

    <!-- Translation script -->
    <script id="translations-script">
      // Translation object passed from Go
      var translations = JSON.parse('{{ .Translations | toJSON }}');
        var currentLang = '{{ .Lang }}'; // Current language

        // Get translation by key
        function translate(key) {
            if (!translations['en']) {
                console.error('English translations not available!');
                return key;
            }

            if (translations[currentLang] && translations[currentLang][key]) {
                return translations[currentLang][key];
            } else if (translations['en'][key]) {
                return translations['en'][key];
            }
            return key;
        }
    </script>
    <script>
      const defaultCfg = {
        lat:  {{printf "%.6f" .DefaultLat}},
        lon:  {{printf "%.6f" .DefaultLon}},
        zoom: {{.DefaultZoom}},
        layer: {{.DefaultLayer}}
      };
    </script>

  </head>

  <body>

    <!-- Container for upload button -->
    <div class="upload-btn-container leaflet-control">
      <!--
        title/aria-label ‚Üí short hint on hover/focus about formats
        and what happens after upload.
      -->
      <label
        for="fileInput"
        class="upload-btn"
        title="{{translate "upload_button_tooltip"}}"
        aria-label="{{translate "upload_button_tooltip"}}">
        {{translate "upload_button"}}
      </label>

      <input
        type="file"
        id="fileInput"
        style="display: none;"
        multiple
        accept=""
        onchange="uploadFiles()">
    </div>

    <!-- Container for geolocation button -->
    <div class="locate-btn-container leaflet-control">
      <button id="locateButton" class="locate-btn" title="{{translate "locate_button_tooltip"}}">
        <img src="/static/images/marker-icon-2x.png" alt="Locate" style="width:20px;">
      </button>
      <br>
      <!-- Small QR button under geolocate -->
      <button id="qrButton" class="qr-btn" title="{{translate "qr_button_tooltip"}}" aria-label="QR code">
        <svg viewBox="0 0 100 100" role="img" aria-hidden="true">
          <rect x="0" y="0" width="100" height="100" fill="#fff"/>
          <rect x="8" y="8" width="28" height="28" fill="#000"/>
          <rect x="12" y="12" width="20" height="20" fill="#fff"/>
          <rect x="16" y="16" width="12" height="12" fill="#000"/>
          <rect x="64" y="8" width="28" height="28" fill="#000"/>
          <rect x="68" y="12" width="20" height="20" fill="#fff"/>
          <rect x="72" y="16" width="12" height="12" fill="#000"/>
          <rect x="8" y="64" width="28" height="28" fill="#000"/>
          <rect x="12" y="68" width="20" height="20" fill="#fff"/>
          <rect x="16" y="72" width="12" height="12" fill="#000"/>
          <rect x="48" y="12" width="8" height="8" fill="#000"/>
          <rect x="40" y="28" width="8" height="8" fill="#000"/>
          <rect x="56" y="28" width="8" height="8" fill="#000"/>
          <rect x="44" y="44" width="8" height="8" fill="#000"/>
          <rect x="60" y="44" width="8" height="8" fill="#000"/>
          <rect x="44" y="60" width="8" height="8" fill="#000"/>
          <rect x="60" y="60" width="8" height="8" fill="#000"/>
          <rect x="76" y="60" width="8" height="8" fill="#000"/>
          <rect x="28" y="44" width="8" height="8" fill="#000"/>
        </svg>
      </button>
    </div>

    <!-- Container for "Back to all tracks" button -->
    <div class="back-to-all-container leaflet-control" style="display: none;">
      <button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
    </div>

    <!-- File upload overlay -->
    <div id="fileOverlay" style="display: none;">
      <div id="fileProgressContainer">
        <!-- Upload progress entries inserted here dynamically -->
      </div>
    </div>

    <!-- GitHub link and program info -->
    <a href="https://github.com/matveynator/chicha-isotope-map" class="github-link" target="_blank">
      <img src="/static/images/GitHub-Mark.png" alt="GitHub" class="github-icon">
    </a>

    <div class="program-info">
      <a href="https://github.com/matveynator/chicha-isotope-map/releases/tag/latest" target="_blank"><strong>{{translate "description"}}</strong> (version: {{ .Version }})</a>
    </div>

    <!-- Map container -->
    <div id="map"></div>

    <div id="loadingOverlay" class="loading-overlay" style="display:none;">
      <div class="spinner"></div>
    </div>


    <!-- Load Leaflet JavaScript library -->
    <script src="/static/leaflet.js"></script>

    <!-- Slider -->
    <script src="/static/nouislider.min.js"></script>
    <script src="/static/wNumb.min.js"></script>



    <!-- Helper functions -->
    <script>
      // Compute marker color from radiation level
      function getGradientColor(doseRate) {
        if (doseRate <= 0.04) return "#006400"; // Dark green
        else if (doseRate <= 0.08) return interpolateColor([0, 100, 0], [173, 255, 47], (doseRate - 0.04) / (0.08 - 0.04));
        else if (doseRate <= 0.11) return interpolateColor([173, 255, 47], [255, 255, 0], (doseRate - 0.08) / (0.11 - 0.08));
        else if (doseRate <= 0.20) return interpolateColor([255, 255, 0], [255, 165, 0], (doseRate - 0.11) / (0.20 - 0.11));
        else if (doseRate <= 0.30) return interpolateColor([255, 165, 0], [255, 0, 0], (doseRate - 0.20) / (0.30 - 0.20));
        else if (doseRate <= 0.99) return interpolateColor([255, 0, 0], [0, 0, 0], (doseRate - 0.30) / (0.99 - 0.30));
        else return "#000000"; // Black for very high values
      }

// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
  if (factor < 0) factor = 0;
  if (factor > 1) factor = 1;

  const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
  const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
  const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

// Calculate marker radius based on zoom level
function getRadius(doseRate, zoomLevel) {
  // previous formula: Math.pow(2, (zoomLevel-10)/2)
  const k = 1;                               // scale by ~2
  let r   = Math.pow(2, (zoomLevel - 10)/2.5) * k;
  return Math.max(r, 2);                       // prevent tiny circles
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 * In single-track view there is no filtering ‚Äî show everything.
 */
function shouldDisplayBySpeed(speed) {
  /* Key line */
  if (isTrackView) return true;        // filter disabled in track view

  const st = loadSpeedFilterState();   // global mode
  if (speed >= 70 && speed <= 500) return st.plane;  // ‚úàÔ∏è
  if (speed >= 7  && speed <  70)  return st.car;    // üöó
  /* speed < 7 m/s  ‚Üí pedestrian */
  return st.ped;                                      // üö∂
}


// Compute marker fill opacity based on speed
function getFillOpacity(speed) {
  if (speed <= 5) {
    return 0.6;
  } else if (speed >= 20) {
    return 0.1;
  } else {
    var opacityRange = 0.6 - 0.1;
    var speedRange = 20 - 5;
    var opacityDecreasePerMs = opacityRange / speedRange;
    var speedAboveFive = speed - 5;
    var totalOpacityDecrease = speedAboveFive * opacityDecreasePerMs;
    var currentOpacity = 0.6 - totalOpacityDecrease;
    return currentOpacity;
  }
}

// Build tooltip content for a marker
function getTooltipContent(marker) {
  var date = new Date(marker.date * 1000);
  var formattedDate = date.toLocaleString();

  return `
    <div class="custom-tooltip">
    <div class="tooltip-row">
    <strong>${translate('radiation_dose')}:</strong>
    <span>${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)</span>
    </div>
    <div class="tooltip-row">
    <strong>${translate('speed')}:</strong>
    <span>${(marker.speed * 3.6).toFixed(1)} km/h</span>
    </div>
    <div class="tooltip-row">
    <strong>${translate('track_id')}:</strong>
    <span>${marker.trackID}</span>
    </div>
    </div>
    `;
}

// Get current URL params from map state
function getCurrentUrlParams() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  return `?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;
}
    </script>

    <!-- Map initialization and markers -->
    <script>
      var map;
var circleMarkers = {};
var isTrackView = false;
var osmLayer, googleSatellite;
var trackBounds;
var currentTrackID = null;

// New controller to cancel previous request
var markerFetchController = null;


/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return default state
 *   ‚úàÔ∏è off, üöó on, üö∂ on  (as requested).
 */
function loadSpeedFilterState() {
  const def = { plane: false, car: true, ped: true };
  try {
    const raw = sessionStorage.getItem('speedFilterState');
    return raw ? JSON.parse(raw) : def;
  } catch (e) {
    return def;
  }
}

// ---------- helpers for time-range state ------------------------
function loadDateRangeState() {
  try { return JSON.parse(sessionStorage.getItem('dateRangeState')) || null; }
  catch(e){ return null; }
}
function saveDateRangeState(st) {
  sessionStorage.setItem('dateRangeState', JSON.stringify(st));
}

/**
 * Return a "Month YYYY" string in the browser locale.
 * Chrome/Firefox often display "Aug 2025",
 * Safari shows "Aug 2025", etc.
 */
function tsToNiceStr(ts){
  return new Date(ts * 1000)
    .toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}


// absolute month difference between two unix timestamps
function monthsApart(ts0, ts1){
  const d0 = new Date(ts0 * 1000);
  const d1 = new Date(ts1 * 1000);
  return Math.abs((d1.getFullYear() - d0.getFullYear()) * 12 +
    (d1.getMonth()     - d0.getMonth()));
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user‚Äôs choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
  sessionStorage.setItem('speedFilterState', JSON.stringify(state));
}


document.addEventListener('DOMContentLoaded', function () {

  // Initialize trackID from path
  var match = window.location.pathname.match(/^\/trackid\/([a-zA-Z0-9]+)/);
  if (match) {
    currentTrackID = match[1];
    isTrackView = true;
    // NEW: show back button immediately
    var backBox = document.querySelector('.back-to-all-container');
    if (backBox) backBox.style.display = 'block';
  }
  // Initialize layers and auto theme switch
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const osmLight = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const osmDark  = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  // Google tiles always use satellite imagery for consistent look
  const googleSat   = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';

  osmLayer = L.tileLayer(media.matches ? osmDark : osmLight, {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap contributors'
  });

  // Use the same satellite layer regardless of theme
  googleSatellite = L.tileLayer(googleSat, {
    maxZoom: 20,
    attribution: '&copy; Google'
  });

  media.addEventListener('change', e => {
    osmLayer.setUrl(e.matches ? osmDark : osmLight);
    // Google layer remains unchanged to keep satellite imagery
  });

  // right after creating osmLayer and googleSatellite
  const urlParams       = new URLSearchParams(window.location.search);
  const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
  const startLayer      = startLayerName === 'Google Satellite' ? googleSatellite : osmLayer;

  map = L.map('map', {
    center: [defaultCfg.lat, defaultCfg.lon],
    zoom  : defaultCfg.zoom,
    layers: [startLayer],           // only one base layer
  });

  // Layer control
  var baseLayers = {
    "OpenStreetMap": osmLayer,
    "Google Satellite": googleSatellite
  };

  L.control.layers(baseLayers, null, {
    position: 'topleft',
    collapsed: false
  }).addTo(map);

  // Track view initialization
  var initialMarkers = JSON.parse('{{ .Markers | toJSON }}');
  if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
    isTrackView = true;

    // Don't show initialMarkers immediately; load them in parts via get_markers
    map.on('load', debounceUpdateMarkers);

    // Adjust marker size on zoom
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
  } else {
    // Dynamic marker updates in global mode
    map.on('load', debounceUpdateMarkers);
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
    debounceUpdateMarkers;
  }

  // Load map state from URL
  loadMapFromUrl();

  // Update URL on map changes
  map.on('baselayerchange', updateUrl);
  map.on('moveend', updateUrl);
  map.on('zoomend', updateUrl);

  // Initialize UI elements
  initializeUIElements();

  /**
   * Build a Leaflet control with three check-boxes that filter markers
   * by recorded speed. Labels now show speed in km/h instead of m/s.
   * Default state: ‚úàÔ∏è off, üöó on, üö∂ on.
   */
  function createSpeedFilterControls() {

    if (isTrackView) return;   // hidden in track view

    // load previously saved state (or defaults)
    const state = loadSpeedFilterState();

    // custom Leaflet control
    const SpeedCtrl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-control-layers');
        div.style.padding = '6px 10px';

        // helper that returns one <label> line
        const row = (id, emoji, checked) => `
            <label style="white-space:nowrap;display:block;cursor:pointer;">
            <input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
          ${emoji}
            </label>`;

        // order: ‚úàÔ∏è, üöó, üö∂  (top ‚Üí bottom)
        div.innerHTML =
          row('sfPlane', '‚úàÔ∏è',  state.plane) +
          row('sfCar',   'üöó', state.car)   +
          row('sfPed',   'üö∂', state.ped);

        // prevent map drag/zoom while clicking inside the control
        L.DomEvent.disableClickPropagation(div);

        // attach change-handlers
        div.querySelectorAll('input[type=checkbox]').forEach(cb => {
          cb.addEventListener('change', () => {
            state.plane = div.querySelector('#sfPlane').checked;
            state.car   = div.querySelector('#sfCar').checked;
            state.ped   = div.querySelector('#sfPed').checked;
            saveSpeedFilterState(state);   // remember choice
            debounceUpdateMarkers();       // redraw with new filter
          });
        });

        return div;
      }
    });

    new SpeedCtrl({ position: 'topleft' }).addTo(map);
  }






  // Call it
  createSpeedFilterControls();   
  createDateRangeSlider();


});


/**
 * Date-range control with two modes:
 *  - YEAR (single handle): labels show full [minYear..maxYear] when NO user filter is active,
 *    otherwise they show the chosen year.
 *  - MONTH (double handle): classic [from..to] range.
 *
 * Key ideas:
 *  ‚Ä¢ We expose window.__setDateSliderVisibility(show)
 *  ‚Ä¢ We expose window.__initSliderOnce(minTs,maxTs) for first build
 *  ‚Ä¢ We expose window.__syncDateSliders(minTs,maxTs) to keep ranges/labels
 *    in sync with the current map viewport on every pan/zoom IF no custom
 *    time filter is set by the user.
 *
 * No globals except 3 window.* hooks; no vendor APIs beyond noUiSlider.
 */
function createDateRangeSlider(){

  if (isTrackView) return;   // no date control in single-track mode

  let sliderBox, yearSlider, monthSlider;
  let mode  = 'year';                // 'year' | 'month'
  let initY = false, initM = false;  // lazy init flags

  // We store the "full range" of current viewport to detect
  // whether a saved filter is actually "show all".
  let fullRange = null; // [minTs,maxTs]

  const DateCtrl = L.Control.extend({
    onAdd(){
      sliderBox = L.DomUtil.create('div','leaflet-control-layers date-slider-box');
      sliderBox.style.display = 'none'; // hidden until needed
      sliderBox.innerHTML = `
        <div class="slider-toggle">
          <button id="btnYear"  class="active">Y</button>
          <button id="btnMonth">M</button>
        </div>
        <div id="lblMax" class="slider-label"></div>
        <div id="yearSlider"></div>
        <div id="dateSlider"></div>
        <div id="lblMin" class="slider-label"></div>
        <button id="btnReset" class="slider-reset-btn" title="Reset"> ‚ü≤ </button>
      `;
      return sliderBox;
    }
  });
  new DateCtrl({ position:'topleft' }).addTo(map);

  const btnY = sliderBox.querySelector('#btnYear');
  const btnM = sliderBox.querySelector('#btnMonth');
  const btnReset = sliderBox.querySelector('#btnReset');
  const lblMin = () => sliderBox.querySelector('#lblMin');
  const lblMax = () => sliderBox.querySelector('#lblMax');

  btnY.onclick = () => switchMode('year');
  btnM.onclick = () => switchMode('month');

  // Show/hide the whole control (called from updateMarkers())
  window.__setDateSliderVisibility = (show)=>{
    sliderBox.style.display = show ? 'block' : 'none';
    if(!show) sessionStorage.removeItem('dateRangeState');
  };

  // One-time creation of both sliders using initial bounds
  window.__initSliderOnce = (minTs,maxTs)=>{
    if (initY && initM) return;
    fullRange = [minTs,maxTs]; // remember initial "full range"

    // YEAR slider (single handle)
    if(!initY){
      yearSlider = sliderBox.querySelector('#yearSlider');
      const minYear = new Date(minTs*1000).getUTCFullYear();
      const maxYear = new Date(maxTs*1000).getUTCFullYear();

      noUiSlider.create(yearSlider,{
        start      : minYear,                // the handle can sit anywhere; labels decide what to show
        connect    : [true,false],
        orientation: 'vertical',
        direction  : 'rtl',
        step       : 1,
        range      : { min:minYear, max:maxYear },
        format     : wNumb({ decimals:0 })
      });

      // Update labels:
      //  - If NO user filter or filter equals fullRange ‚Üí show full year bounds.
      //  - Else ‚Üí show the chosen year.
      yearSlider.noUiSlider.on('update', ([y])=>{
        if (mode !== 'year') return;
        const saved = loadDateRangeState();
        const fr = fullRange || [minTs,maxTs];
        const isFull = !saved || (saved[0] === fr[0] && saved[1] === fr[1]);
        if (isFull){
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = r.min;
          lblMax().textContent = r.max;
        } else {
          lblMin().textContent = y;
          lblMax().textContent = y;
        }
      });
      yearSlider.noUiSlider.on('change', updateDateFilter);
      initY = true;
    }

    // MONTH slider (double handle)
    if(!initM){
      monthSlider = sliderBox.querySelector('#dateSlider');
      noUiSlider.create(monthSlider,{
        start       : [minTs,maxTs],
        connect     : true,
        orientation : 'vertical',
        direction   : 'rtl',
        step        : 3600, // 1 hour
        range       : { min:minTs, max:maxTs },
        format      : wNumb({ decimals:0 })
      });
      monthSlider.noUiSlider.on('update', ()=>{
        if (mode !== 'month') return;
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      });
      monthSlider.noUiSlider.on('change', updateDateFilter);
      monthSlider.style.display = 'none';
      initM = true;
    }

    // Initial labels = full bounds
    if (mode === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      lblMin().textContent = r.min;
      lblMax().textContent = r.max;
    } else {
      lblMin().textContent = tsToNiceStr(minTs);
      lblMax().textContent = tsToNiceStr(maxTs);
    }
  };

  // Sync ranges and labels to the *current* viewport on every pan/zoom,
  // but ONLY when user has not applied a custom time filter.
  window.__syncDateSliders = (minTs,maxTs)=>{
    if (!initY || !initM) return; // not built yet

    // Detect whether user has a custom time filter (not full range).
    const saved = loadDateRangeState();
    const prevFull = fullRange;
    fullRange = [minTs,maxTs]; // update "full" range to the new viewport

    const hasCustom =
      !!saved && !(saved[0] === prevFull?.[0] && saved[1] === prevFull?.[1]) &&
      !(saved[0] === fullRange[0] && saved[1] === fullRange[1]);

    // Update YEAR slider bounds
    const minYear = new Date(minTs*1000).getUTCFullYear();
    const maxYear = new Date(maxTs*1000).getUTCFullYear();
    yearSlider.noUiSlider.updateOptions({
      range: { min:minYear, max:maxYear }
    }, false);

    // Update MONTH slider bounds
    monthSlider.noUiSlider.updateOptions({
      range: { min:minTs, max:maxTs }
    }, false);

    // If no custom filter ‚Üí force labels to show full bounds and make month slider span all
    if (!hasCustom){
      if (mode === 'year'){
        const r = yearSlider.noUiSlider.options.range;
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        monthSlider.noUiSlider.set([minTs,maxTs]);
        lblMin().textContent = tsToNiceStr(minTs);
        lblMax().textContent = tsToNiceStr(maxTs);
      }
      // persist that "no filter" means full range
      saveDateRangeState([minTs,maxTs]);
    }
  };

  // Reset button ‚Üí drop custom filter and show full bounds of the *current* viewport
  btnReset.onclick = ()=>{
    sessionStorage.removeItem('dateRangeState');
    if (initY && initM){
      const rY = yearSlider.noUiSlider.options.range;
      const rM = monthSlider.noUiSlider.options.range;
      yearSlider.noUiSlider.set(rY.min);      // handle position is cosmetic
      monthSlider.noUiSlider.set([rM.min, rM.max]);

      lblMin().textContent = (mode==='year') ? rY.min : tsToNiceStr(rM.min);
      lblMax().textContent = (mode==='year') ? rY.max : tsToNiceStr(rM.max);

      // remember "no filter" == full range of the viewport
      saveDateRangeState([rM.min, rM.max]);
      debounceUpdateMarkers();
    }
  };

  function switchMode(next){
    if (mode === next) return;

    mode = next;
    btnY.classList.toggle('active', next==='year');
    btnM.classList.toggle('active', next==='month');
    yearSlider.style.display  = next==='year'  ? 'block' : 'none';
    monthSlider.style.display = next==='month' ? 'block' : 'none';

    // Refresh labels on mode switch respecting full/custom state
    const saved = loadDateRangeState();
    const fr = fullRange;
    const isFull = !saved || (fr && saved[0]===fr[0] && saved[1]===fr[1]);

    if (next === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      if (isFull){
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        const y = +yearSlider.noUiSlider.get();
        lblMin().textContent = y;
        lblMax().textContent = y;
      }
    } else {
      const r = monthSlider.noUiSlider.options.range;
      if (isFull){
        monthSlider.noUiSlider.set([r.min, r.max]);
        lblMin().textContent = tsToNiceStr(r.min);
        lblMax().textContent = tsToNiceStr(r.max);
      } else {
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      }
    }

    // Do not change filter on mode flip; user intent remains the same
  }

  function updateDateFilter(){
    // YEAR mode ‚Üí make a full [year..year] month span
    if (mode==='year'){
      const y = +yearSlider.noUiSlider.get();
      const from = Date.UTC(y,0,1)/1000;
      const to   = Date.UTC(y+1,0,1)/1000 - 1;
      saveDateRangeState([from,to]);
    } else {
      saveDateRangeState(monthSlider.noUiSlider.get().map(Number));
    }
    debounceUpdateMarkers();
  }
}



// Function definitions

// ---------- Popup linking to track ----------
function getPopupContent(marker) {
  const dateStr = new Date(marker.date * 1000).toLocaleString();
  return `
    <div class="custom-tooltip">
    <div><strong>${translate('radiation_dose')}:</strong>
  ${(marker.doseRate * 100).toFixed(2)} ¬µR/h (${marker.doseRate.toFixed(2)} ¬µSv/h)
    </div>
    <div><strong>${translate('speed')}:</strong> ${(marker.speed * 3.6).toFixed(1)} km/h</div>
    <div style="margin-top:4px">
    <!-- clicking the link switches to track mode -->
    <a href="javascript:viewTrack('${marker.trackID}')" style="font-weight:bold;">
  ${translate('track_id')}: ${marker.trackID}
    </a>
    </div>
    </div>`;
}


/* Request markers for current bounds/zoom, render them,
 * and keep the date sliders in sync with the viewport.
 */
function updateMarkers(){
  const loadingEl = document.getElementById('loadingOverlay');
  if (loadingEl) loadingEl.style.display='block';

  if (markerFetchController) markerFetchController.abort();
  markerFetchController = new AbortController();

  const zoom   = map.getZoom();
  const bounds = map.getBounds();

  const params = {
    zoom  : zoom,
    minLat: bounds.getSouthWest().lat,
    minLon: bounds.getSouthWest().lng,
    maxLat: bounds.getNorthEast().lat,
    maxLon: bounds.getNorthEast().lng
  };

  // speed filter (global view only)
  if (!isTrackView) {
    const sp = loadSpeedFilterState();
    const speeds = [];
    if (sp.plane) speeds.push('plane');
    if (sp.car)   speeds.push('car');
    if (sp.ped)   speeds.push('ped');
    if (speeds.length && speeds.length !== 3){
      params.speeds = speeds.join(',');
    }
  }

  if (isTrackView && currentTrackID){
    params.trackID = currentTrackID;
  }

  fetch('/get_markers?' + new URLSearchParams(params),
        { signal: markerFetchController.signal })
    .then(r => { if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
    .then(data => {
      if (!Array.isArray(data)) data = [];

      // compute tracks count & time span for this viewport
      const tracks = new Set();
      let minTs = Infinity, maxTs = -Infinity;
      data.forEach(m=>{
        if (m.trackID) tracks.add(m.trackID);
        minTs = Math.min(minTs, m.date);
        maxTs = Math.max(maxTs, m.date);
      });
      const dateSpanMonths = (isFinite(minTs) && isFinite(maxTs))
                              ? monthsApart(minTs, maxTs) : 0;

      const needSlider = !isTrackView && tracks.size > 1 && dateSpanMonths > 1;

      if (window.__setDateSliderVisibility){
        window.__setDateSliderVisibility(needSlider);
      }

      // Build sliders first time
      if (needSlider && window.__initSliderOnce && isFinite(minTs) && isFinite(maxTs)){
        window.__initSliderOnce(minTs, maxTs);
        window.__initSliderOnce = null; // one-shot
      }

      // Always keep sliders‚Äô bounds/labels in sync with viewport
      if (needSlider && window.__syncDateSliders && isFinite(minTs) && isFinite(maxTs)){
        window.__syncDateSliders(minTs, maxTs);
      }

      // Apply time filter ONLY when user selected a custom range
      if (!isTrackView && needSlider){
        const saved = loadDateRangeState();
        // We need full-range of current viewport ‚Üí ask sync to decide;
        // __syncDateSliders saved [minTs,maxTs] as "no filter".
        if (saved && !(saved[0] === minTs && saved[1] === maxTs)){
          data = data.filter(m => m.date >= saved[0] && m.date <= saved[1]);
        }
      }

      // Render markers
      for (const key in circleMarkers) map.removeLayer(circleMarkers[key]);
      circleMarkers = {};

      data.forEach(m=>{
        if (!shouldDisplayBySpeed(m.speed)) return;

        const cm = L.circleMarker([m.lat, m.lon], {
          radius      : getRadius(m.doseRate, zoom),
          fillColor   : getGradientColor(m.doseRate),
          color       : getGradientColor(m.doseRate),
          weight      : 1,
          opacity     : getFillOpacity(m.speed) + 0.1,
          fillOpacity : getFillOpacity(m.speed)
        })
        .addTo(map)
        .bindTooltip(getTooltipContent(m),
            { direction:'top', className:'custom-tooltip', offset:[0,-8] })
        .bindPopup(getPopupContent(m));

        circleMarkers[m.id || m.trackID] = cm;
      });
    })
    .catch(err=>{
      if (err.name !== 'AbortError') console.error('fetch:', err);
    })
    .finally(()=>{
      if (loadingEl) loadingEl.style.display='none';
    });
}




let debounceTimeout;

function debounceUpdateMarkers() {
  clearTimeout(debounceTimeout);
  debounceTimeout = setTimeout(updateMarkers, 300);
}

function adjustMarkerRadius() {
  var zoomLevel = map.getZoom();
  for (let key in circleMarkers) {
    let marker = circleMarkers[key];
    let newRadius = getRadius(marker.doseRate, zoomLevel);
    marker.setRadius(newRadius);
  }
}

/* -----------------------------------------------------------------
 *  viewTrack() ‚Äî switch to single-track mode.
 *  Set currentTrackID = trackID before changing window.location.
 * -----------------------------------------------------------------*/
function viewTrack(trackID) {
  currentTrackID = trackID;   // new
  isTrackView    = true;

  const bounds = map.getBounds();
  const layer  = map.hasLayer(googleSatellite) ? 'Google Satellite'
    : 'OpenStreetMap';
  const zoom   = map.getZoom();

  const trackURL =
    `/trackid/${trackID}` +
    `?minLat=${bounds.getSouthWest().lat}` +
    `&minLon=${bounds.getSouthWest().lng}` +
    `&maxLat=${bounds.getNorthEast().lat}` +
    `&maxLon=${bounds.getNorthEast().lng}` +
    `&zoom=${zoom}` +
    `&layer=${encodeURIComponent(layer)}`;

  window.location.href = trackURL;
}


function setBaseLayer(layerName) {
  if (layerName === 'Google Satellite') {
    if (map.hasLayer(osmLayer))            map.removeLayer(osmLayer);
    if (!map.hasLayer(googleSatellite))    googleSatellite.addTo(map);
  } else {
    if (map.hasLayer(googleSatellite))     map.removeLayer(googleSatellite);
    if (!map.hasLayer(osmLayer))           osmLayer.addTo(map);
  }
}

function loadMapFromUrl() {
  const params = new URLSearchParams(window.location.search);

  /* base layer from URL or default */
  const layer = decodeURIComponent(params.get('layer') || defaultCfg.layer);
  setBaseLayer(layer);

  /* read remaining params */
  const minLat = parseFloat(params.get('minLat'));
  const minLon = parseFloat(params.get('minLon'));
  const maxLat = parseFloat(params.get('maxLat'));
  const maxLon = parseFloat(params.get('maxLon'));

  if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
    adjustMarkerRadius();
  } else if (isTrackView && trackBounds) {
    map.fitBounds(trackBounds);
  } else {
    map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
  }
}

function updateUrl() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  var newUrl = `${window.location.pathname}?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;

  window.history.replaceState({}, '', newUrl);
}

function openServerPoster() {
  if (typeof updateUrl === 'function') { try { updateUrl(); } catch(_){} }
  var full = window.location.href;
  var dst  = '/qrpng?u=' + encodeURIComponent(full);
  window.open(dst, '_blank', 'noopener,noreferrer');
}

function initializeUIElements() {
  var locateButton = document.getElementById('locateButton');
  if (locateButton) {
    locateButton.addEventListener('click', centerMapToLocation);
  }
  var qrButton = document.getElementById('qrButton');
  if (qrButton) {
    qrButton.addEventListener('click', openServerPoster);
  }
  var backToAllButton = document.getElementById('backToAllButton');
  if (backToAllButton) {
    backToAllButton.addEventListener('click', function () {
      var params = (typeof getCurrentUrlParams === 'function') ? getCurrentUrlParams() : '';
      window.location.href = '/' + params;
    });
  }
}

function centerMapToLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function(position) {
        var userLat = position.coords.latitude;
        var userLon = position.coords.longitude;

        map.setView([userLat, userLon], 15);

        L.marker([userLat, userLon]).addTo(map)
          .bindPopup(translate("your_location")).openPopup();
      },
      function(error) {
        switch(error.code) {
          case error.PERMISSION_DENIED:
            alert(translate("location_permission_denied"));
            break;
          case error.POSITION_UNAVAILABLE:
            alert(translate("location_unavailable"));
            break;
          case error.TIMEOUT:
            alert(translate("location_timeout"));
            break;
          default:
            alert(translate("location_error"));
            break;
        }
      }
    );
  } else {
    alert(translate("geolocation_not_supported"));
  }
}
    </script>

    <!-- File upload script -->
    <script>
      function uploadFiles() {
        const fileInput  = document.getElementById('fileInput');
        const files      = fileInput.files;
        if (!files.length) {
          alert(translate('select_files'));
          return;
        }

        const fileOverlay          = document.getElementById('fileOverlay');
        const fileProgressContainer = document.getElementById('fileProgressContainer');
        fileProgressContainer.innerHTML = '';
        fileOverlay.style.display  = 'flex';

        /* counter and URL of last track */
        let completedUploads = 0;
        const totalFiles     = files.length;
        let lastTrackURL     = null;

        /* Create an XHR for each file but redirect only once */
        [...files].forEach(file => {
          /* --- visual progress elements --- */
          const fileBlock        = document.createElement('div');
          fileBlock.className    = 'file-progress';
          const fileName         = document.createElement('div');
          fileName.className     = 'file-name';
          fileName.innerText     = file.name;
          const progressBar      = document.createElement('div');
          progressBar.className  = 'progress-bar';
          const progressBarInner = document.createElement('div');
          progressBarInner.className = 'progress-bar-inner';
          progressBar.appendChild(progressBarInner);
          const serverProcessing = document.createElement('div');
          serverProcessing.className = 'server-processing';
          serverProcessing.innerText = translate('waiting_for_server');
          fileBlock.append(fileName, progressBar, serverProcessing);
          fileProgressContainer.appendChild(fileBlock);
          /* ------------------------------------------------- */

          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload', true);

          /* file upload progress */
          xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
              const percent = (e.loaded / e.total) * 100;
              progressBarInner.style.width = percent + '%';
            }
          };

          /* handle server response */
          xhr.onload = () => {
            if (xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              if (response.status === 'success') {
                lastTrackURL             = response.trackURL;   // remember
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
              } else {
                serverProcessing.innerText = translate('error_processing_files');
                serverProcessing.style.color = 'red';
              }
            } else {
              serverProcessing.innerText = translate('error_during_upload');
              serverProcessing.style.color = 'red';
            }

            /* increment counter and redirect when done */
              completedUploads++;
            if (completedUploads === totalFiles) {
              setTimeout(() => {
                fileOverlay.style.display = 'none';
                /* redirect to last successfully processed track */
                  if (lastTrackURL) {
                    window.location.href = lastTrackURL;
                  } else {
                    location.reload();   // if all uploads failed
                  }
              }, 700);
            }
          };

          /* send file */
            const formData = new FormData();
          formData.append('files[]', file);
          xhr.send(formData);
        });
      }
    </script>

  </body>
</html>
