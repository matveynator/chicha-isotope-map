<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set metadata and link CSS -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{translate "title"}}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/static/leaflet.css">
    <link rel="stylesheet" href="/static/nouislider.min.css">

		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="180x180" href="/static/images/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/images/favicon-16x16.png">
		<link rel="manifest" href="/static/images/site.webmanifest">


    <style>
/* General styles */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden; /* Hide scrollbars */
  background: var(--modal-bg); /* Apply theme background color */
  color: var(--modal-text); /* Ensure text inherits theme color */
  font-family: var(--font-family-base); /* Keep text styling consistent across the UI */
  font-size: var(--font-size-base); /* Align base size so similar widgets match */
  line-height: 1.5; /* Provide comfortable reading in both themes */
}

        /* Color and typography variables adapt to system theme */
        :root {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          color-scheme: light; /* Default to light scheme */
          --font-family-base: "Segoe UI", "Noto Sans", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; /* Shared font stack keeps every control aligned */
          --font-size-base: 12px; /* Main text size for buttons, menus, and labels */
          --font-size-sm: 10px; /* Secondary text such as helper descriptions */
					--font-size-xxs: 6px;
          --font-size-xs: 8px; /* Compact labels and metadata */
          --font-size-lg: 14px; /* Slightly larger controls where extra emphasis helps */
          --font-size-xl: 20px; /* Section headings */
          --font-size-display: 28px; /* Prominent readings inside tooltips */
        }

        @media (prefers-color-scheme: dark) {
          :root {
            --overlay-bg: rgba(0, 0, 0, 0.7);
            --progress-bg: #2b2b2b;
            --progress-color: #f4f4f4;
            --progress-bar-bg: #555555;
            --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            --upload-btn-bg: #4caf50; /* Standard site green for consistency */
            --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
            --control-bg: rgba(51, 51, 51, 0.25);
            --control-bg-hover: rgba(51, 51, 51, 0.35);
            --legend-border: 0px solid #555;
            --modal-bg: #2b2b2b;
            --modal-text: #eee;
            --modal-border: 1px solid #444;
            --link-color: #90caf9;
            --info-card-bg: rgba(43, 43, 43, 0.9);
            --info-card-border: 1px solid rgba(255, 255, 255, 0.08);
            --api-method-bg: rgba(144, 202, 249, 0.2);
            --api-method-text: #90caf9;
            color-scheme: dark; /* Match system dark scheme */
          }
        }

        /* Reuse the same typography across controls so menus, buttons, and overlays match */
        body, html, button, input, select, textarea {
          font-family: var(--font-family-base);
        }

        button,
        .upload-btn,
        .locate-btn,
        .back-to-all-btn,
        .slider-reset-btn,
        .slider-toggle button,
        .qr-btn,
        .live-modal-close {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

        /* Align shared UI chrome sizes while letting specialized components override when needed */
        .slider-label,
        .slider-toggle button,
        .live-popup-meta,
        .live-popup-small-link {
          font-size: var(--font-size-xs);
        }

        .live-tooltip-desc,
        .live-popup-dose-secondary,
        .live-popup-dose-status,
        .live-chart-unit {
          font-size: var(--font-size-sm);
        }

        .leaflet-container,
				.leaflet-container .leaflet-control,
        .leaflet-container .leaflet-popup,
        .leaflet-container .leaflet-tooltip {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

				/* Base style – applies to all phones (old and new) */
				.leaflet-container .leaflet-control-attribution {
					font-family: var(--font-family-base);
					font-size: var(--font-size-xxs);
				}

				/* Increase font size only on screens wider than 768px (tablets, laptops, desktops) */
				@media (min-width: 768px) {
					.leaflet-container .leaflet-control-attribution {
						font-size: var(--font-size-xs);
					}
				}

        /* Manual theme overrides */
        :root[data-theme='light'] {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          color-scheme: light; /* Force light scheme when manually selected */
        }

        :root[data-theme='dark'] {
          --overlay-bg: rgba(0, 0, 0, 0.7);
          --progress-bg: #2b2b2b;
          --progress-color: #f4f4f4;
          --progress-bar-bg: #555555;
          --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(51, 51, 51, 0.25);
          --control-bg-hover: rgba(51, 51, 51, 0.35);
          --legend-border: 0px solid #555;
          --modal-bg: #2b2b2b;
          --modal-text: #eee;
          --modal-border: 1px solid #444;
          --link-color: #90caf9;
          --info-card-bg: rgba(43, 43, 43, 0.9);
          --info-card-border: 1px solid rgba(255, 255, 255, 0.08);
          --api-method-bg: rgba(144, 202, 249, 0.2);
          --api-method-text: #90caf9;
          color-scheme: dark; /* Force dark scheme when manually selected */
        }

        /* Theme toggle switch */
        #themeToggle {
          position: absolute;
          bottom: 140px;
          right: 20px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          padding: 4px 6px;
          z-index: 1000;
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
          display: flex;
          align-items: center;
          gap: 6px;
          color: var(--modal-text);
        }

        /* Small centered pill that surfaces the shareable short link */
        #shortLinkDisplay {
          position: absolute;
          top: 12px;
          left: 50%;
          transform: translateX(-50%);
          background: var(--overlay-bg);
          border: var(--legend-border);
          border-radius: 999px;
          padding: 4px 10px;
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.75;
          z-index: 1200;
          cursor: pointer;
          display: none;
          user-select: none;
          transition: opacity 0.2s ease;
        }

        #shortLinkDisplay:hover,
        #shortLinkDisplay:focus,
        #shortLinkDisplay.copied {
          opacity: 1;
          outline: none;
        }

        #shortLinkDisplay.copied {
          background: var(--control-bg-hover);
        }

        /* Debug overlay hugs the short-link pill so operators can glance at the telemetry without opening devtools. */
        #debugStats {
          position: absolute;
          top: 44px;
          left: 50%;
          transform: translateX(-50%);
          background: var(--overlay-bg);
          border: var(--legend-border);
          border-radius: 8px;
          padding: 6px 10px;
          font-size: var(--font-size-xxs);
          line-height: 1.4;
          color: var(--modal-text);
          z-index: 1180;
          display: none;
          box-shadow: 0 1px 4px rgba(0,0,0,0.2);
          max-width: min(90vw, 520px);
          text-align: left;
          word-break: break-word;
        }

        #debugStats strong {
          font-weight: 600;
        }

        /* API quickstart cards inside the info modal stay theme aware through shared variables. */
        #infoModal .api-heading {
          font-size: var(--font-size-xl);
          margin: 0 0 0.5em;
        }

        #infoModal .api-intro {
          margin: 0 0 0.75em;
        }

        #infoModal .api-note {
          margin: 0 0 1.25em;
          font-size: var(--font-size-sm);
          opacity: 0.75;
        }

        #infoModal .api-grid {
          display: grid;
          gap: 12px;
        }

        @media (min-width: 640px) {
          #infoModal .api-grid {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
          }
        }

        #infoModal .api-card {
          background: var(--info-card-bg);
          border: var(--info-card-border);
          border-radius: 10px;
          padding: 12px 14px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #infoModal .api-card-head {
          display: flex;
          align-items: baseline;
          gap: 8px;
          margin-bottom: 8px;
        }

        #infoModal .api-method {
          display: inline-flex;
          align-items: center;
          padding: 2px 8px;
          border-radius: 999px;
          background: var(--api-method-bg);
          color: var(--api-method-text);
          font-size: var(--font-size-xs);
          font-weight: 700;
          letter-spacing: 0.06em;
        }

        #infoModal .api-path {
          font-family: var(--font-family-base);
          font-size: var(--font-size-sm);
          opacity: 0.8;
        }

        #infoModal .api-card-title {
          margin: 0 0 6px;
          font-size: var(--font-size-lg);
        }

        #infoModal .api-card-desc {
          margin: 0 0 10px;
          font-size: var(--font-size-sm);
        }

        #infoModal .api-card-link {
          display: inline-block;
          margin-bottom: 6px;
          color: var(--link-color);
          font-weight: 600;
          text-decoration: none;
        }

        #infoModal .api-card-link:hover,
        #infoModal .api-card-link:focus {
          text-decoration: underline;
        }

        #infoModal .api-card-note {
          margin: 0;
          font-size: var(--font-size-xs);
          opacity: 0.75;
        }

        #infoModal .api-more {
          margin-top: 16px;
          font-size: var(--font-size-sm);
        }

        .theme-icon {
          font-size: var(--font-size-base);
          line-height: 1;
        }

        .theme-switch {
          position: relative;
          display: inline-block;
          width: 30px;
          height: 16px;
          margin: 0 4px;
        }

        .theme-switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .theme-slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: 0.2s;
          border-radius: 16px;
        }

        .theme-slider:before {
          position: absolute;
          content: "";
          height: 12px;
          width: 12px;
          left: 2px;
          bottom: 2px;
          background-color: #fff;
          transition: 0.2s;
          border-radius: 50%;
        }

        .theme-switch input:checked + .theme-slider {
          background-color: #2196F3;
        }

        .theme-switch input:checked + .theme-slider:before {
          transform: translateX(14px);
        }

        /* Map container */
        #map {
          height: 100vh; /* Map takes full viewport height */
          margin: 0;
          overflow: hidden;
        }

        /* Custom tooltip styles */
        .custom-tooltip {
          /* Match tooltip with current theme */
          background-color: var(--modal-bg);
          border-radius: 5px;
          padding: 10px;
          color: var(--modal-text);
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
        }

        /* Consistent hover/focus hints for interactive controls */
        .control-tooltip {
          position: fixed;
          z-index: 1400;
          pointer-events: none;
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--legend-border);
          border-radius: 8px;
          padding: 10px 12px;
          box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
          font-size: var(--font-size-sm);
          line-height: 1.4;
          max-width: 280px;
          opacity: 0;
          transform: scale(0.96);
          transform-origin: center;
          transition: opacity 120ms ease, transform 120ms ease;
          text-align: left;
        }

        .control-tooltip--visible {
          opacity: 1;
          transform: scale(1);
        }

        .control-tooltip__title {
          font-weight: 600;
          margin-bottom: 4px;
          font-size: var(--font-size-base);
        }

        .control-tooltip__meta {
          font-size: var(--font-size-xs);
          opacity: 0.75;
          margin-top: 6px;
        }

        /* Lightweight list styling keeps multi-line tooltip content readable without extra markup. */
        .control-tooltip__list {
          margin: 6px 0 0;
          padding-left: 16px;
        }

        .control-tooltip__list li {
          margin-bottom: 4px;
        }

        .control-tooltip__list li:last-child {
          margin-bottom: 0;
        }

        /* Link inside popups pointing to full legend */
        .risk-link {
          color: var(--link-color);
          text-decoration: underline;
        }

        /* Larger color squares for legend items */
        .legend-square {
          display: inline-block;
          width: 12px;
          height: 12px;
          margin-right: 6px;
          border: var(--legend-border);
          border-radius: 2px;
        }

        /* Container for upload button */
        .upload-btn-container {
          position: absolute;
          top: 20px;
          right: 20px;
          z-index: 1000;
        }

        /* Upload button styling, theme-aware */
        .upload-btn {
          background-color: var(--upload-btn-bg); /* Use site green for familiarity */
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: #ffffff; /* White text stays readable across themes */
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        /* File upload overlay */
        #fileOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: var(--overlay-bg);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        /* Upload progress container */
        #fileProgressContainer {
          background-color: var(--progress-bg);
          color: var(--progress-color);
          padding: 20px;
          border-radius: 10px;
          max-width: 600px;
          width: 100%;
          box-shadow: var(--progress-shadow);
          max-height: 80vh;
          overflow-y: auto; /* Allow scrolling for many uploads */
        }

        /* Individual file upload progress */
        .file-progress {
          margin-bottom: 15px;
        }

        .file-name {
          font-weight: bold;
          margin-bottom: 5px;
        }

        /* Progress bar */
        .progress-bar {
          width: 100%;
          height: 10px;
          background-color: var(--progress-bar-bg);
          border-radius: 5px;
          overflow: hidden;
        }

        .progress-bar-inner {
          height: 100%;
          background-color: #4caf50;
          width: 0%;
        }

        /* Server processing indicator */
        .server-processing {
          margin-left: 10px;
          font-size: var(--font-size-base);
          color: #ff9800;
        }

        /* Upload button hover effect */
        .upload-btn:hover {
          background-color: var(--upload-btn-bg-hover); /* Darker shade on hover */
        }

        /* Container for geolocation button */
        .locate-btn-container {
          position: absolute;
          top: 60px;
          right: 20px;
          z-index: 1000;
        }

        /* Geolocation button styling, theme-aware */
        .locate-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Geolocation button hover effect */
        .locate-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* GitHub link styling */
        .github-link {
          position: absolute;
          bottom: 20px;
          left: 20px;
          z-index: 1000;
        }

        .github-icon {
          width: 60px;
          height: 60px;
          opacity: 0.7;
        }

        .github-icon:hover {
          opacity: 1;
        }

        /* Program info uses theme text and link colors */
        .program-info {
          position: absolute;
          bottom: 20px;
          left: 70px;
          z-index: 1000;
          color: var(--modal-text);
          font-size: var(--font-size-base);
          opacity: 0.6;
        }

        .program-info a {
          color: var(--link-color);
          text-decoration: none;
        }

        .program-info a:hover {
          text-decoration: underline;
        }

        .program-info:hover {
          opacity: 1;
        }

        /* "Back to all tracks" button container.
           Positioned below the QR button to prevent overlap. */
        .back-to-all-container {
          position: absolute;
          top: 185px; /* place under geolocation+QR stack */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .back-to-all-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        .back-to-all-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* Dedicated download container lives under the back button so
           track view controls remain grouped for quick access. */
        .download-track-container {
          position: absolute;
          top: 225px; /* keep consistent spacing below the back button */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .download-track-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          text-decoration: none;
          display: inline-block;
        }

        .download-track-btn:hover {
          background-color: var(--control-bg-hover);
        }


        /* ─────────–– Slider clean-look patch ─────────── */
        .date-slider-box {
          padding: 6px;
          width: 50px;
        }

        /* 0) Basic slider container geometry: buffer = 8px
           (half handle size) so handles never exceed the rail */
        #dateSlider{
          width:6px;                 /* rail thickness */
          height:130px;              /* actual track length */
          padding:0px 0;             /* inner top/bottom padding */
          box-sizing:content-box;    /* ensures padding works */
          margin:16px auto 26px;
        }

        /* 1) grey slider rail */
        #dateSlider .noUi-base{
          background:#bfbfbf;
          width:100%;                /* 6px width */
          height:100%;               /* 130px minus padding */
        }

        /* 2) colored section only between handles */
        #dateSlider .noUi-connect{
          background:#1e88e5;        /* pick your brand color */
        }

        /* Slider handles respect theme colors */
        .noUi-vertical .noUi-handle{
          width:32px;
          height:20px;
          left:-18px;              /* center on 6px rail */
          border-radius:3px;
          background: var(--control-bg);      /* follow theme */
          border: var(--legend-border);   /* match theme border */
          box-shadow:0 1px 3px rgba(0,0,0,.25);
          cursor:grab;
        }
        /* 4) remove pseudo-element tails */
        .noUi-handle:before,
        .noUi-handle:after{ display:none; }

        .slider-label{
          margin:2px 0;
          font-size: var(--font-size-xs);
          line-height:1.15em;
          white-space:nowrap;
          text-align:center;
        }

        /* ───── Year / Month toggle ───── */
        .slider-toggle{
          display:flex; gap:2px; margin:2px 0 4px;
          font-size: var(--font-size-xs); line-height:1; user-select:none;
        }
        /* Year/Month toggle buttons adapt to theme */
        .slider-toggle button{
          flex:1 1 0; padding:2px 4px;
          border: var(--legend-border); background: var(--control-bg);
          border-radius:3px; cursor:pointer;
          color: var(--modal-text);
        }
        .slider-toggle button.active{
          background:#1e88e5; color:#fff; border-color:#1e88e5;
        }

        /* ─── Year mode: slider height matches month slider ─── */
        #yearSlider{
          /* copied parameters from #dateSlider */
          width:6px;                 /* rail thickness */
          height:130px;              /* track length */
          padding:0;                 /* inner padding */
          margin:16px auto 26px;     /* same margins */
          box-sizing:content-box;
        }
        /* grey rail and blue connect bar */
        #yearSlider .noUi-base      {background:#bfbfbf;width:100%;height:100%;}
        #yearSlider .noUi-connect   {background:#bfbfbf;}


        /* Reset button styled with theme variables */
        .slider-reset-btn{
          display:block;
          width:100%;
          margin-top:4px;
          padding:2px 4px;
          font-size: var(--font-size-xl);
          border: var(--legend-border);
          background: var(--control-bg);
          border-radius:3px;
          cursor:pointer;
          color: var(--modal-text);
        }
        .slider-reset-btn:hover{ background: var(--control-bg-hover); }

        .loading-overlay{
          position:absolute;
          top:50%;left:50%;
          transform:translate(-50%,-50%);
          z-index:3000;
          pointer-events:none;
        }
        .spinner{
          width:40px;height:40px;
          border:4px solid rgba(0,0,0,.15);
          border-top:4px solid #1e88e5;
          border-radius:50%;
          animation:spin 1s linear infinite;
        }
        @keyframes spin{ to{ transform:rotate(360deg); } }


        /* Compact QR button follows theme */
        .qr-btn {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          width: 42px; height: 42px;
          padding: 4px;
          display: flex; align-items: center; justify-content: center;
          cursor: pointer;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .qr-btn:hover { background: var(--control-bg-hover); }
        .qr-btn svg { width: 22px; height: 22px; display: block; }

        /* Leaflet controls use theme variables so colors follow the current theme */
        .leaflet-control-layers,
        .leaflet-control-layers-toggle,
        .leaflet-control-layers-list,
        .leaflet-control-layers-expanded,
        .leaflet-bar a {
          background-color: var(--control-bg);
          border: var(--legend-border);
          color: var(--modal-text);
        }

        .leaflet-control-layers-toggle:hover,
        .leaflet-bar a:hover {
          background-color: var(--control-bg-hover);
        }

        /* Ensure layer labels match theme text color */
        .leaflet-control-layers label { color: var(--modal-text); }

        /* ===== Leaflet layer control ===== */
        /* Remove border and shadow around map type selector to blend into map */
        .leaflet-control-layers,
        .leaflet-control-layers-expanded,
        .leaflet-control-layers-list {
          box-shadow: none;
        }

        /* Removed old collapsible legend styles (legend-control, legend-header, legend-title, legend-toggle, legend-body, legend-row, legend-swatch, legend-label)
           to avoid duplicate legends. Only the compact legend + modal remain. */

        /* Live marker icon now combines the heart logo with the dose value. */
        .live-marker {
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 2px;
          text-align: center;
          font-weight: 600;
          font-family: var(--font-family-base);
          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
          color: #000;
          overflow: hidden;
        }

        .live-marker-heart {
          display: block;
          width: 60%;
          height: auto;
          pointer-events: none;
        }

        .live-marker-value {
          line-height: 1;
          font-size: 0.55em;
          letter-spacing: -0.02em;
        }



				/* ---- Unified tooltip/popup sizing & wrapping ----
					 Keep tooltip (hover) and popup (click) the same width.
					 Leaflet's default popup maxWidth is ~300px, so we reuse that.
					 Adjust --tooltip-max if you want it wider/narrower in one place. */
				:root {
					--tooltip-max: 300px;   /* single source of truth for both tooltip & popup widths */
					--tooltip-min: 220px;   /* prevents collapsing into a thin vertical strip */
				}

				/* Wrapper used inside both tooltip and popup content */
				.live-tooltip {
					max-width: var(--tooltip-max);  /* wider than old 260px */
				}

				/* Leaflet tooltip content (hover). Make it match popup width and wrap nicely. */
				.leaflet-tooltip.custom-tooltip {
					white-space: normal;            /* allow line wrapping */
					max-width: var(--tooltip-max);  /* match popup max width */
					min-inline-size: var(--tooltip-min); /* avoid skinny column */
					overflow-wrap: break-word;      /* break long words/URLs only when needed */
					word-break: break-word;         /* compatibility for older browsers */
					hyphens: auto;                  /* nicer hyphenation when available */
				}

				/* Leaflet popup content (click). Enforce the same max width to match tooltip. */
				.leaflet-popup-content {
					max-width: var(--tooltip-max);  /* unify with tooltip width */
				}

				/* Flex header: allow text to shrink in flex so it doesn't overflow. */
				.live-tooltip-header {
					display: flex;
					gap: 10px;
					align-items: center;
					margin-bottom: 6px;
					min-width: 0;                   /* critical for proper flex text shrinking */
				}

				/* Fixed-size heart icon so it doesn't affect layout */
				.live-tooltip-heart {
					width: 28px;
					height: 28px;
					flex: 0 0 28px;
				}

				/* Title and description: let text wrap and shrink inside flex */
				.live-tooltip-title,
				.live-tooltip-desc {
					margin: 0;
					min-width: 0;                   /* allow shrinking in flex */
					flex: 1 1 auto;                 /* take available space without overflowing */
				}

        .live-tooltip-desc {
          font-size: var(--font-size-sm);
          line-height: 1.4;
        }

        /* Highlight realtime dose with large numerals while keeping context compact. */
        .live-popup-dose {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
          margin: 6px 0;
        }

        .live-popup-dose-primary {
          font-size: var(--font-size-display);
          font-weight: 700;
          line-height: 1;
          letter-spacing: -0.01em;
        }

        .live-popup-dose-unit {
          margin-left: 6px;
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-dose-secondary {
          font-size: var(--font-size-sm);
          opacity: 0.85;
        }

        .live-popup-dose-status {
          padding: 4px 10px;
          border-radius: 6px;
          font-size: var(--font-size-sm);
          font-weight: 600;
        }

        .live-popup-climate {
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-meta {
          font-size: var(--font-size-xs);
          line-height: 1.4;
          opacity: 0.85;
          display: grid;
          gap: 4px;
          margin-top: 6px;
        }

        .live-popup-meta strong {
          font-weight: 600;
        }

        .live-popup-small-link {
          font-size: var(--font-size-xs);
          display: inline-block;
          margin-top: 4px;
        }



        .live-extra-list {
          margin: 4px 0 0 0;
          padding-left: 18px;
        }

        .live-extra-list li {
          margin: 2px 0;
        }

        /* Keep the icons in the speed filter aligned regardless of emoji vs. SVG source. */
        .speed-filter-icon {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 1.5em;
          height: 1.5em;
          margin-left: 6px;
          font-size: 1.2em;
          line-height: 1;
        }

        /* Ensure the SVG heart scales with the surrounding emoji-based icons. */
        .speed-filter-icon img {
          display: block;
          width: 100%;
          height: 100%;
        }

        /* Apply grayscale filter so emoji icons render in monochrome without altering other assets. */
        .speed-filter-icon--mono {
          filter: grayscale(1) brightness(1) contrast(1);
        }

        #liveModal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.6);
          z-index: 2100;
          justify-content: center;
          align-items: center;
        }

        .live-modal-content {
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--modal-border);
          width: min(720px, 92%);
          max-height: 85vh;
          overflow-y: auto;
          padding: 20px;
          border-radius: 12px;
          box-shadow: 0 0 12px rgba(0, 0, 0, 0.45);
          font-family: inherit;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-modal-header {
          display: flex;
          align-items: center;
          gap: 14px;
        }

        .live-modal-heart {
          width: 40px;
          height: 40px;
        }

        .live-modal-title {
          margin: 0;
          font-size: var(--font-size-xl);
        }

        .live-modal-description {
          margin: 4px 0 0 0;
          line-height: 1.6;
        }

        .live-modal-meta {
          display: grid;
          gap: 6px;
          font-size: var(--font-size-base);
        }

        .live-chart-stack {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-chart-block {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 10px;
          padding: 12px;
        }

        .live-chart-title {
          margin: 0 0 8px 0;
          display: flex;
          flex-wrap: wrap;
          gap: 4px 12px;
          align-items: baseline;
        }

        .live-chart-label {
          font-size: var(--font-size-base);
          font-weight: 600;
          flex: 1 1 auto;
        }

        .live-chart-unit {
          font-size: var(--font-size-sm);
          color: var(--modal-text);
          opacity: 0.8;
        }

        .live-chart-window {
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.7;
        }

        .live-chart-canvas {
          display: block;
          width: 100%;
          height: 180px;
          border-radius: 6px;
          background: rgba(0,0,0,0.05);
        }

        .live-chart-empty {
          margin: 0;
          font-size: var(--font-size-sm);
          color: var(--modal-text);
        }

        .live-modal-close {
          align-self: flex-end;
          padding: 6px 14px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 6px;
          cursor: pointer;
          font-family: inherit;
          color: var(--modal-text);
        }

    </style>

    <!-- Translation script -->
    <script id="translations-script">
      // Translation object passed from Go
      // We emit ready-made JS literals to keep html/template from misdetecting
      // the surrounding string context when translations contain quotes.
      var translations = {{ .TranslationsJSON }};
        var currentLang = '{{ .Lang }}'; // Current language

        // Get translation by key
        function translate(key) {
            if (!translations['en']) {
                console.error('English translations not available!');
                return key;
            }

            if (translations[currentLang] && translations[currentLang][key]) {
                return translations[currentLang][key];
            } else if (translations['en'][key]) {
                return translations['en'][key];
            }
            return key;
        }
    </script>
    <script>
      const defaultCfg = {
        lat:  {{printf "%.6f" .DefaultLat}},
        lon:  {{printf "%.6f" .DefaultLon}},
        zoom: {{.DefaultZoom}},
        layer: {{ printf "%q" .DefaultLayer }}
      };
    </script>
    <script>
      // Surface the configured support e-mail so the legal dialog can show a contact when available.
      window.supportEmail = {{if .SupportEmail}}{{printf "%q" .SupportEmail}}{{else}}""{{end}};
    </script>
    <script>
      // Expose the realtime flag so the UI can hide controls when the backend keeps the feature off.
      window.safecastRealtimeEnabled = {{if .RealtimeAvailable}}true{{else}}false{{end}};
    </script>
    <script>
      // Flag whether the caller is on the debug allowlist so diagnostics stay hidden for regular visitors.
      window.__debugEnabled = {{if .DebugEnabled}}true{{else}}false{{end}};
    </script>

  </head>

  <body>

    <!-- Container for upload button -->
    <div class="upload-btn-container leaflet-control">
      <!--
        title/aria-label → short hint on hover/focus about formats
        and what happens after upload.
      -->
      <label
        for="fileInput"
        class="upload-btn"
        aria-label="{{translate "upload_button_tooltip"}}">
        {{translate "upload_button"}}
      </label>

      <input
        type="file"
        id="fileInput"
        style="display: none;"
        multiple
        accept=""
        onchange="uploadFiles()">
    </div>

    <!-- Container for geolocation button -->
    <div class="locate-btn-container leaflet-control">
      <button id="locateButton" class="locate-btn" aria-label="{{translate "locate_button_tooltip"}}">
        <img src="/static/images/marker-icon-2x.png" alt="Locate" style="width:20px;">
      </button>
      <br>
      <!-- Small QR button under geolocate -->
      <button id="qrButton" class="qr-btn" aria-label="{{translate "qr_button_tooltip"}}">
        <svg viewBox="0 0 100 100" role="img" aria-hidden="true">
          <rect x="0" y="0" width="100" height="100" fill="#fff"/>
          <rect x="8" y="8" width="28" height="28" fill="#000"/>
          <rect x="12" y="12" width="20" height="20" fill="#fff"/>
          <rect x="16" y="16" width="12" height="12" fill="#000"/>
          <rect x="64" y="8" width="28" height="28" fill="#000"/>
          <rect x="68" y="12" width="20" height="20" fill="#fff"/>
          <rect x="72" y="16" width="12" height="12" fill="#000"/>
          <rect x="8" y="64" width="28" height="28" fill="#000"/>
          <rect x="12" y="68" width="20" height="20" fill="#fff"/>
          <rect x="16" y="72" width="12" height="12" fill="#000"/>
          <rect x="48" y="12" width="8" height="8" fill="#000"/>
          <rect x="40" y="28" width="8" height="8" fill="#000"/>
          <rect x="56" y="28" width="8" height="8" fill="#000"/>
          <rect x="44" y="44" width="8" height="8" fill="#000"/>
          <rect x="60" y="44" width="8" height="8" fill="#000"/>
          <rect x="44" y="60" width="8" height="8" fill="#000"/>
          <rect x="60" y="60" width="8" height="8" fill="#000"/>
          <rect x="76" y="60" width="8" height="8" fill="#000"/>
          <rect x="28" y="44" width="8" height="8" fill="#000"/>
        </svg>
      </button>
    </div>

    <!-- Container for "Back to all tracks" button -->
    <div class="back-to-all-container leaflet-control" style="display: none;">
      <button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
    </div>

    <!-- Track download button appears only in track view so users can retrieve the original JSON quickly. -->
    <div class="download-track-container leaflet-control" style="display: none;">
      <a id="downloadTrackLink" class="download-track-btn" href="#">{{ translate "download_track_cim" }}</a>
    </div>

    <!-- File upload overlay -->
    <div id="fileOverlay" style="display: none;">
      <div id="fileProgressContainer">
        <!-- Upload progress entries inserted here dynamically -->
      </div>
    </div>

    <!-- GitHub link and program info -->
    <a href="https://github.com/matveynator/chicha-isotope-map" class="github-link" target="_blank" rel="noopener noreferrer" aria-label="{{translate "github_link_tooltip_desc"}}">
      <img src="/static/images/chicha-isotope-map-round-logo.png" alt="{{translate "description"}} (version: {{ .Version }})" class="github-icon">
    </a>

    <!-- Short link pill shows the shareable URL and copies it on click -->
    <div
      id="shortLinkDisplay"
      role="button"
      tabindex="0"
      aria-live="polite"
      aria-label="{{translate "short_link_tooltip"}}"></div>

    <!-- Debug metrics live directly under the short-link so operators see diagnostics without extra clicks. -->
    <div id="debugStats" aria-live="polite" role="status"></div>

    <!-- Map container -->
    <div id="map"></div>

    <div id="loadingOverlay" class="loading-overlay" style="display:none;">
      <div class="spinner"></div>
    </div>

    <!-- Theme toggle -->
    <div id="themeToggle" role="button" tabindex="0" aria-label="{{translate "theme_toggle_tooltip"}}">
      <span class="theme-icon">☀️</span>
      <label class="theme-switch">
        <input type="checkbox" id="themeSwitch">
        <span class="theme-slider"></span>
      </label>
      <span class="theme-icon">🌙</span>
    </div>

<!-- Compact Legend (clickable) -->
<div id="legend" role="button" tabindex="0" aria-label="{{translate "legend_button_tooltip"}}" style="
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: var(--control-bg);
  border: var(--legend-border);
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
  padding: 10px 10px 10px 0;
  font-size: var(--font-size-sm);
  line-height: 1.4em;
  cursor: pointer;
  z-index: 1000;
  font-family: var(--font-family-base);
  display: flex;
  overflow: hidden;">
    <div style="width:16px; margin-left:6px; margin-right:6px; border-radius:4px 4px 4px 4px; overflow:hidden; background:linear-gradient(to top,#008000,#FFD700,#FF8C00,#FF4500,#000); position:relative;">
    <span style="position:absolute; bottom:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size: var(--font-size-xxs);">{{translate "legend_safe"}}</span>
    <span style="position:absolute; top:4px; left:0; right:0; display:flex; align-items:center; justify-content:center; writing-mode:vertical-rl; transform:rotate(180deg); color:#fff; font-size: var(--font-size-xxs);">{{translate "legend_danger"}}</span>
</div>
  <div>
    <strong>{{translate "legend_title"}}</strong><br>
    <div><span style="color:#000000;">■</span> >100 µR/h</div>
    <div><span style="color:#FF4500;">■</span> 30–100 µR/h</div>
  <div><span style="color:#FFD700;">■</span> 11–30 µR/h</div>
   <div><span style="color:#008000;">■</span> 0–11 µR/h</div>
  </div>
</div>
<!--
  Compact 4-bin legend (µR/h) with vertical gradient bar (green→yellow→orange→red→black).
  White labels mark safe at the bottom and danger at the top.
  Clicking the legend opens a modal with full, human-friendly guidance.
-->
<!-- Legend Modal -->
<div id="legendModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">{{translate "legend_title"}}</h3>
    <!-- We inject the localized full text below -->
    <div id="legendText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('legendModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>
<!--
  Modal that displays the full, localized legend text.
  `white-space:pre-wrap` preserves paragraphs and bullets from translations.json.
  Box scrolls when content is long.
-->

<!-- Generic Info Modal for legal notes, data sources, and license -->
<div id="infoModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 id="infoTitle" style="margin-top:0;"></h3>
    <div id="infoText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('infoModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full MIT License directly on the map. -->
<div class="license-modal" data-license="mit" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">MIT License</h3>
    <pre class="license-modal-body" data-license-url="/licenses/mit" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading…</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="mit" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full CC0 1.0 Universal text. -->
<div class="license-modal" data-license="cc0" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">CC0 1.0 Universal</h3>
    <pre class="license-modal-body" data-license-url="/licenses/cc0" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading…</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="cc0" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>

</div>


<!-- Modal with Grafana-style stacked charts for Safecast realtime sensors -->

<div id="liveModal">
  <div class="live-modal-content">
    <div class="live-modal-header">
      <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime sensor" class="live-modal-heart">
      <div>
        <h3 id="liveModalTitle" class="live-modal-title"></h3>
        <p id="liveModalDescription" class="live-modal-description"></p>
      </div>
    </div>
    <div id="liveModalMeta" class="live-modal-meta"></div>
    <div id="liveModalExtra" class="live-modal-meta"></div>
    <div class="live-chart-stack">
      <div class="live-chart-block" data-range="day">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleDay"></span>
          <span class="live-chart-unit">µR/h</span>
          <span class="live-chart-window" data-range="day"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="day"></canvas>
        <p class="live-chart-empty" data-range="day"></p>
      </div>
      <div class="live-chart-block" data-range="month">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleMonth"></span>
          <span class="live-chart-unit">µR/h</span>
          <span class="live-chart-window" data-range="month"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="month"></canvas>
        <p class="live-chart-empty" data-range="month"></p>
      </div>
      <div class="live-chart-block" data-range="all">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitleAll"></span>
          <span class="live-chart-unit">µR/h</span>
          <span class="live-chart-window" data-range="all"></span>
        </h4>
        <canvas class="live-chart-canvas" data-range="all"></canvas>
        <p class="live-chart-empty" data-range="all"></p>
      </div>
    </div>
    <button type="button" class="live-modal-close" id="liveModalClose"></button>
  </div>
</div>

    <!-- Load Leaflet JavaScript library -->
    <script src="/static/leaflet.js"></script>

    <!-- Slider -->
    <script src="/static/nouislider.min.js"></script>
    <script src="/static/wNumb.min.js"></script>



    <!-- Helper functions -->
    <script>
      // Cache typography tokens so dynamic canvases reuse the same styling as CSS.
      let cachedFontTokens;
      function resolveFontTokens() {
        if (cachedFontTokens) return cachedFontTokens;
        const root = document.documentElement;
        const styles = window.getComputedStyle(root);
        const fallbackFamily = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        const familyRaw = (styles.getPropertyValue('--font-family-base') || '').trim();
        const family = familyRaw || fallbackFamily;

        function pickSize(varName, defaultSize) {
          const value = (styles.getPropertyValue(varName) || '').trim();
          return value || defaultSize;
        }

        cachedFontTokens = {
          family: family,
          xs: pickSize('--font-size-xs', '6px'),
          sm: pickSize('--font-size-sm', '10px'),
          base: pickSize('--font-size-base', '12px'),
          lg: pickSize('--font-size-lg', '14px'),
          xl: pickSize('--font-size-xl', '20px'),
          display: pickSize('--font-size-display', '28px'),
        };
        return cachedFontTokens;
      }

      // Compute marker color from radiation level
      function getGradientColor(doseRate) {
        if (doseRate <= 0.04) return '#006400'; // Dark green
        else if (doseRate <= 0.08) return interpolateColor([0, 100, 0], [173, 255, 47], (doseRate - 0.04) / (0.08 - 0.04));
        else if (doseRate <= 0.11) return interpolateColor([173, 255, 47], [255, 255, 0], (doseRate - 0.08) / (0.11 - 0.08));
        else if (doseRate <= 0.20) return interpolateColor([255, 255, 0], [255, 165, 0], (doseRate - 0.11) / (0.20 - 0.11));
        else if (doseRate <= 0.30) return interpolateColor([255, 165, 0], [255, 0, 0], (doseRate - 0.20) / (0.30 - 0.20));
        else if (doseRate <= 0.99) return interpolateColor([255, 0, 0], [0, 0, 0], (doseRate - 0.30) / (0.99 - 0.30));
        else return '#000000'; // Black for very high values
      }

// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
  if (factor < 0) factor = 0;
  if (factor > 1) factor = 1;

  const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
  const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
  const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

// Calculate marker radius based on zoom level
function getRadius(doseRate, zoomLevel) {
  // previous formula: Math.pow(2, (zoomLevel-10)/2)
  const k = 1;                               // scale by ~2
  let r   = Math.pow(2, (zoomLevel - 10)/2.5) * k;
  return Math.max(r, 2);                       // prevent tiny circles
}

// Thresholds for realtime freshness expressed in seconds so both the
// rendering loop and periodic refresh share the same rules.
const LIVE_ACTIVE_WINDOW = 5 * 60;         // 5 minutes keeps "working" sensors bright
const LIVE_RECENT_WINDOW = 24 * 60 * 60;   // 24 hours before removal

// parseColor extracts RGB components from either hex (#rrggbb) or rgb(r,g,b)
// strings.  Keeping this helper local avoids pulling external libraries while
// letting us reuse the logic for alpha blending and contrast checks.
function parseColor(color) {
  if (!color) return null;
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
      };
    }
    if (hex.length === 3) {
      return {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16),
      };
    }
  }
  if (color.startsWith('rgb')) {
    const parts = color.match(/\d+/g);
    if (parts && parts.length >= 3) {
      return {
        r: parseInt(parts[0], 10),
        g: parseInt(parts[1], 10),
        b: parseInt(parts[2], 10),
      };
    }
  }
  return null;
}

// colorWithAlpha returns an rgba() string using the provided alpha.  We reuse
// parseColor so realtime markers can reuse the same gradient palette while
// dimming stale sensors without affecting the text opacity.
function colorWithAlpha(color, alpha) {
  const rgb = parseColor(color);
  if (!rgb) return color;
  const a = Math.min(Math.max(alpha, 0), 1);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
}

// isDarkColor estimates perceived brightness to choose a contrasting text
// color.  A simple luminance formula keeps the implementation lightweight.
function isDarkColor(color) {
  const rgb = parseColor(color);
  if (!rgb) return false;
  const luminance = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
  return luminance < 140;
}

// formatMicroRoentgen converts µSv/h into µR/h text while avoiding excessive
// decimals.  Smaller values keep two decimals; larger ones are rounded to the
// nearest whole number for quick scanning on the map.
function formatMicroRoentgen(doseRate) {
  const micro = doseRate * 100;
  if (micro >= 100) return micro.toFixed(0);
  if (micro >= 10) return micro.toFixed(1);
  if (micro >= 1) return micro.toFixed(2);
  return micro.toFixed(3);
}

// formatMicroRoentgenValue keeps axis labels tidy when the charts already work
// with µR/h values.  Sharing the logic here avoids sprinkling the rounding
// heuristics through the drawing code.
function formatMicroRoentgenValue(value) {
  const abs = Math.abs(value);
  if (abs >= 100) return value.toFixed(0);
  if (abs >= 10) return value.toFixed(1);
  if (abs >= 1) return value.toFixed(2);
  return value.toFixed(3);
}

// escapeHtml protects popups against user-supplied strings like device names.
// We rely on explicit lookup tables instead of quoting " inside the regex so
// Go's html/template parser keeps the surrounding <script> in a neutral state.
const ESCAPE_HTML_RE = /[&<>\u0022\u0027]/g;
const ESCAPE_HTML_LOOKUP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
};
ESCAPE_HTML_LOOKUP['\u0022'] = '&quot;';
ESCAPE_HTML_LOOKUP['\u0027'] = '&#39;';
function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value).replace(ESCAPE_HTML_RE, function(ch) {
    return ESCAPE_HTML_LOOKUP[ch] || ch;
  });
}

const regionNameCache = {};

function formatDateTime(ts) {
  if (!ts) return '—';
  const date = new Date(ts * 1000);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  return date.toLocaleString(lang, { hour12: false });
}

function approximateLocalTime(lat, lon) {
  if (typeof lon !== 'number' || !isFinite(lon)) return null;
  const offsetHours = Math.round(lon / 15);
  const offsetMs = offsetHours * 60 * 60 * 1000;
  const remote = new Date(Date.now() + offsetMs);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const label = offsetHours === 0 ? 'UTC' : (offsetHours > 0 ? `UTC+${offsetHours}` : `UTC${offsetHours}`);
  return { text: remote.toLocaleString(lang, { hour12: false }), zone: label };
}

function transportLabel(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_transport_car');
  if (key.includes('bike')) return translate('live_marker_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_transport_air');
  return translate('live_marker_transport_unknown');
}

function transportSentence(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_desc_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_desc_transport_car');
  if (key.includes('bike')) return translate('live_marker_desc_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_desc_transport_air');
  return translate('live_marker_desc_transport_unknown');
}

function localizeCountry(code) {
  if (!code) return '';
  const normalized = String(code).toUpperCase();
  if (normalized === '??') return normalized;
  const langRaw = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  let locale = langRaw === 'ua' ? 'uk' : langRaw;
  locale = locale.replace('_', '-');
  try {
    if (!regionNameCache[locale]) {
      regionNameCache[locale] = new Intl.DisplayNames([locale], { type: 'region' });
    }
    const label = regionNameCache[locale].of(normalized);
    if (label) return label;
  } catch (err) {
    // Older browsers may not support Intl.DisplayNames; fall back to the code below.
  }
  return normalized;
}

function describeLiveSensor(marker) {
  // We use bracket placeholders (e.g. [[name]]) so the Go template parser leaves
  // them untouched while still allowing readable replacement in the browser.
  const subject = marker.deviceName
    ? translate('live_marker_desc_named').replace('[[name]]', escapeHtml(marker.deviceName))
    : translate('live_marker_desc_generic');
  const placeName = marker.country ? localizeCountry(marker.country) : '';
  const place = placeName
    ? translate('live_marker_desc_location').replace('[[place]]', escapeHtml(placeName))
    : translate('live_marker_desc_location_unknown');
  const transport = transportSentence(marker.transport);
  const sensorName = marker.tube || marker.deviceName || '';
  const tube = sensorName
    ? translate('live_marker_desc_tube').replace('[[tube]]', escapeHtml(sensorName))
    : translate('live_marker_desc_no_tube');
  return [subject, place, transport, tube].join(' ');
}

function labelForExtraKey(key) {
  switch (key) {
    case 'temperature_c':
      return translate('live_marker_temperature');
    case 'temperature_f':
      return translate('live_marker_temperature_f');
    case 'humidity_percent':
      return translate('live_marker_humidity');
    case 'pressure_hpa':
      // Safecast Airnote units expose pressure alongside humidity; handling it
      // here keeps the legend consistent with the live charts.
      return translate('live_marker_pressure');
    default:
      return key.replace(/_/g, ' ').replace(/\b\w/g, function(m){ return m.toUpperCase(); });
  }
}

function formatExtraValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return null;
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1) + (key.endsWith('_f') ? ' °F' : ' °C');
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0) + ' %';
  }
  if (key === 'pressure_hpa') {
    // Pressure varies slowly, so one decimal keeps the tooltip readable.
    return value.toFixed(1) + ' hPa';
  }
  return value.toFixed(2);
}

// Adding pressure keeps environmental series grouped together for clarity.
const EXTRA_SERIES_ORDER = ['temperature_c', 'temperature_f', 'humidity_percent', 'pressure_hpa'];

function extraUnitSuffix(key) {
  if (key === 'temperature_c') return '°C';
  if (key === 'temperature_f') return '°F';
  if (key === 'humidity_percent') return '%';
  if (key === 'pressure_hpa') return 'hPa';
  return '';
}

function formatExtraAxisValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return '';
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1);
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0);
  }
  if (key === 'pressure_hpa') {
    return value.toFixed(1);
  }
  return value.toFixed(2);
}

function colorForExtraKey(key) {
  if (key === 'temperature_c' || key === 'temperature_f') return '#ff7043';
  if (key === 'humidity_percent') return '#26a69a';
  if (key === 'pressure_hpa') {
    // Pressure gets a calming blue to distinguish it from humidity's green.
    return '#5c6bc0';
  }
  return '#ab47bc';
}

function sortExtraKeys(keys) {
  return keys.sort(function(a, b) {
    const ai = EXTRA_SERIES_ORDER.indexOf(a);
    const bi = EXTRA_SERIES_ORDER.indexOf(b);
    const av = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
    const bv = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
    if (av === bv) return a.localeCompare(b);
    return av - bv;
  });
}

function hasExtraSeries(series) {
  if (!series || typeof series !== 'object') return false;
  return Object.keys(series).some(function(key){
    return Array.isArray(series[key]) && series[key].length;
  });
}

function renderLiveExtras(extra) {
  if (!extra || typeof extra !== 'object') return '';
  const items = [];
  Object.keys(extra).sort().forEach(function(key){
    const label = labelForExtraKey(key);
    const val = formatExtraValue(key, extra[key]);
    if (!label || !val) return;
    items.push('<li>' + label + ': ' + val + '</li>');
  });
  if (!items.length) return '';
  return '<div><strong>' + translate('live_marker_extra_intro') + ':</strong><ul class="live-extra-list">' + items.join('') + '</ul></div>';
}

function buildDeviceMeta(marker) {
  const rows = [];
  if (marker.deviceName) {
    rows.push('<div><strong>' + translate('live_marker_device_label') + ':</strong> ' + escapeHtml(marker.deviceName) + '</div>');
  }
  if (marker.deviceID) {
    rows.push('<div><strong>' + translate('live_marker_device_id') + ':</strong> ' + escapeHtml(marker.deviceID) + '</div>');
  }
  if (marker.transport) {
    rows.push('<div><strong>' + translate('live_marker_transport') + ':</strong> ' + transportLabel(marker.transport) + '</div>');
  }
  if (marker.tube) {
    rows.push('<div><strong>' + translate('live_marker_detector') + ':</strong> ' + escapeHtml(marker.tube) + '</div>');
  }
  if (marker.country) {
    const localized = localizeCountry(marker.country);
    const display = localized || marker.country;
    rows.push('<div><strong>' + translate('live_marker_country') + ':</strong> ' + escapeHtml(display) + '</div>');
  }
  return rows.join('');
}

// buildRealtimeIcon returns the HTML markup and sizing data for a realtime
// marker.  It handles the three freshness buckets: active (white ring, opaque),
// recent (grey ring, half opacity), and stale (>24h, hidden).
function buildRealtimeIcon(marker, zoomLevel, nowSec) {
  const lastSeen = marker.date || 0;
  if (!lastSeen) return null;

  const ageSec = nowSec - lastSeen;
  if (ageSec > LIVE_RECENT_WINDOW) {
    return null; // drop sensors that have been silent longer than a day
  }

  const active = ageSec <= LIVE_ACTIVE_WINDOW;
  const baseColor = getGradientColor(marker.doseRate);
  const fill = active ? baseColor : colorWithAlpha(baseColor, 0.5);
  const border = active ? '#ffffff' : '#888888';
  const textColor = isDarkColor(active ? baseColor : fill) ? '#ffffff' : '#000000';

  const radius = getRadius(marker.doseRate, zoomLevel) * 3;
  const size = radius * 2;
  const value = formatMicroRoentgen(marker.doseRate);
  const fontSize = Math.max(Math.round(size * 0.32), 11);
  const heartSize = Math.max(Math.round(size * 0.5), 14);

  const html = `
    <div class="live-marker" style="background:${fill};border:2px solid ${border};color:${textColor};width:${size}px;height:${size}px;font-size:${fontSize}px;">
      <img class="live-marker-heart" src="/static/images/safecast-heart-logo.png" alt="Safecast" style="width:${heartSize}px;"/>
      <div class="live-marker-value">${value}</div>
    </div>`;

  return { html, size, radius };
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 * In single-track view there is no filtering — show everything.
 */
function shouldDisplayBySpeed(speed) {
  /* Key line */
  if (isTrackView) return true;        // filter disabled in track view

  const st = loadSpeedFilterState();   // global mode
  if (speed < 0) {                     // Safecast heart markers use negative speed to signal realtime data
    if (!window.safecastRealtimeEnabled) {
      // Safety net: when realtime is disabled we never show synthetic negative speeds.
      return false;
    }
    return st.live;
  }
  if (speed >= 70 && speed <= 500) return st.plane;  // ✈️
  if (speed >= 7  && speed <  70)  return st.car;    // 🚗
  /* speed < 7 m/s  → pedestrian */
  return st.ped;                                      // 🚶
}


// Compute marker fill opacity based on speed
function getFillOpacity(speed) {
  if (speed <= 5) {
    return 0.6;
  } else if (speed >= 20) {
    return 0.1;
  } else {
    var opacityRange = 0.6 - 0.1;
    var speedRange = 20 - 5;
    var opacityDecreasePerMs = opacityRange / speedRange;
    var speedAboveFive = speed - 5;
    var totalOpacityDecrease = speedAboveFive * opacityDecreasePerMs;
    var currentOpacity = 0.6 - totalOpacityDecrease;
    return currentOpacity;
  }
}

// Decide a translation key for safety based on dose rate (µSv/h).
// Using legend thresholds keeps UI consistent and avoids extra strings.
function doseCategory(doseRate) {
  // Map dose rate to safety words using legend thresholds
  if (doseRate <= 0.11) return 'legend_safe';
  if (doseRate <= 0.30) return 'legend_attention';
  return 'legend_danger';
}



// Get current URL params from map state
function getCurrentUrlParams() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  return `?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;
}
    </script>

    <!-- Map initialization and markers -->
    <script>
      var map;
var circleMarkers = {};
const markerStacks = new Map();
const markerStackIndex = new Map();
const stackMetrics = { totalLayers: 0, visibleLayers: 0 };
var isTrackView = false;
var osmLayer, googleSatellite;
var trackBounds;
var currentTrackID = null;
const shortLinkBox = document.getElementById('shortLinkDisplay');
let shortLinkTimer = null;
let shortLinkAbort = null;
let lastShortLinkFull = '';
let pendingShortLinkFull = '';
let shortLinkCommitPromise = null;

// We keep every tooltip handle in one place so hideMapHints can silence them together.
var mapHintHandles = [];

// -----------------------------------------------------------------------------
// Marker stack management keeps only the strongest readings at each coordinate.
// We follow "Make the zero value useful" by treating missing numbers as 0 so the
// comparison logic stays simple.
function buildCoordinateKey(lat, lon) {
  const safeLat = typeof lat === 'number' && isFinite(lat) ? lat : 0;
  const safeLon = typeof lon === 'number' && isFinite(lon) ? lon : 0;
  return safeLat.toFixed(5) + ',' + safeLon.toFixed(5);
}

// The zoom-dependent cap mirrors how we would scale services in Go: simple rules
// keep behavior predictable for operators. The ranges intentionally overlap, and
// we pick the stricter cap when that happens so the busiest views stay snappy.
function maxLayersForZoom(zoom) {
  if (typeof zoom !== 'number' || !isFinite(zoom)) return 2;
  if (zoom >= 17) return Infinity;
  if (zoom > 10) return 3;
  if (zoom >= 1) return 2;
  return 1;
}

// Provide a monotonic clock similar to Go's time.Since helper so render timing stays stable.
function monotonicNow() {
  if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {
    return performance.now();
  }
  return Date.now();
}

// Higher dose wins; newer timestamps break ties so investigators see the freshest
// report first. This mirrors "Clear is better than clever" by keeping the sort
// well-documented.
function compareMarkerEntries(a, b) {
  const doseA = (a && typeof a.dose === 'number' && isFinite(a.dose)) ? a.dose : -Infinity;
  const doseB = (b && typeof b.dose === 'number' && isFinite(b.dose)) ? b.dose : -Infinity;
  if (doseA !== doseB) return doseB - doseA;
  const tsA = (a && typeof a.date === 'number' && isFinite(a.date)) ? a.date : 0;
  const tsB = (b && typeof b.date === 'number' && isFinite(b.date)) ? b.date : 0;
  if (tsA !== tsB) return tsB - tsA;
  return 0;
}

// We trim stale entries before reshaping stacks so null placeholders never skew counts.
function purgeInvalidStackEntries(stack) {
  if (!stack || !Array.isArray(stack.entries)) {
    return;
  }
  for (let i = stack.entries.length - 1; i >= 0; i -= 1) {
    const entry = stack.entries[i];
    if (!entry || !entry.key) {
      stack.entries.splice(i, 1);
    }
  }
}

// Removing the Leaflet layer without dropping metadata lets us resurrect hidden
// markers instantly when zoom grows while still releasing browser memory.
function dematerialiseEntryMarker(entry) {
  if (!entry || !entry.marker) {
    return;
  }
  if (typeof entry.marker.remove === 'function') {
    entry.marker.remove();
  } else if (map && typeof map.removeLayer === 'function') {
    try {
      map.removeLayer(entry.marker);
    } catch (err) {
      // ignore cleanup errors so the rest of the pipeline keeps flowing
    }
  }
  if (entry.key && circleMarkers[entry.key]) {
    delete circleMarkers[entry.key];
  }
  entry.marker = null;
}

// publishStackMetrics mirrors Go's channel fan-out: a single call updates all
// listeners so debug and instrumentation stay in sync.
function publishStackMetrics() {
  const total = stackMetrics.totalLayers < 0 ? 0 : stackMetrics.totalLayers;
  const visible = stackMetrics.visibleLayers < 0 ? 0 : stackMetrics.visibleLayers;
  const filtered = total - visible > 0 ? (total - visible) : 0;
  if (typeof debugOverlay !== 'undefined' && debugOverlay && typeof debugOverlay.recordStackTotals === 'function') {
    debugOverlay.recordStackTotals(total, filtered, visible);
  }
}

// resetStackMetrics clears aggregate counters whenever we drop all markers.
function resetStackMetrics() {
  stackMetrics.totalLayers = 0;
  stackMetrics.visibleLayers = 0;
  publishStackMetrics();
}

// updateStackMetricsForStack applies the delta from the previous stack snapshot
// so aggregate totals update in constant time.
function updateStackMetricsForStack(stack, prevTotal, prevVisible) {
  if (!stack || !Array.isArray(stack.entries)) {
    stackMetrics.totalLayers -= prevTotal;
    stackMetrics.visibleLayers -= prevVisible;
    publishStackMetrics();
    return;
  }
  const safePrevTotal = Number.isFinite(prevTotal) ? prevTotal : 0;
  const safePrevVisible = Number.isFinite(prevVisible) ? prevVisible : 0;
  const nextTotal = stack.entries.length;
  const nextVisible = Number.isFinite(stack.visibleCount) ? stack.visibleCount : Math.min(nextTotal, safePrevVisible);
  stackMetrics.totalLayers += nextTotal - safePrevTotal;
  stackMetrics.visibleLayers += nextVisible - safePrevVisible;
  stack.totalCount = nextTotal;
  stack.visibleCount = nextVisible;
  publishStackMetrics();
}

// enforceStackVisibility materialises only the top-priority entries while
// keeping the rest dormant so zoomed-in views can resurrect them cheaply.
function enforceStackVisibility(stack, coordKey, layerLimit, zoom) {
  if (!stack || !Array.isArray(stack.entries)) {
    return;
  }

  purgeInvalidStackEntries(stack);
  stack.entries.sort(compareMarkerEntries);

  const total = stack.entries.length;
  if (total === 0) {
    stack.visibleCount = 0;
    return;
  }

  const limit = isFinite(layerLimit) ? Math.max(0, Math.min(layerLimit, total)) : total;
  let visible = 0;
  let index = 0;

  while (index < stack.entries.length) {
    const entry = stack.entries[index];
    if (!entry || !entry.key) {
      stack.entries.splice(index, 1);
      continue;
    }

    markerStackIndex.set(entry.key, coordKey);

    if (index < limit) {
      const marker = ensureEntryMarker(entry, zoom);
      if (marker) {
        visible += 1;
        index += 1;
        continue;
      }
      // If we fail to materialise the marker we drop the entry entirely so the
      // stack never holds invalid placeholders.
      dropMarkerEntry(entry);
      stack.entries.splice(index, 1);
      continue;
    }

    dematerialiseEntryMarker(entry);
    index += 1;
  }

  stack.visibleCount = visible;
}

// Removing stale markers early frees memory so the browser can breathe. We clear
// every reference to respect the user's requirement about releasing resources.
function dropMarkerEntry(entry) {
  if (!entry) return;
  dematerialiseEntryMarker(entry);
  if (entry.key) {
    markerStackIndex.delete(entry.key);
  }
  entry.marker = null;
  entry.dose = null;
  entry.date = null;
  entry.data = null;
  entry.isRealtime = null;
}

// Materialise a marker on demand so we only spend work on entries that survive the cap.
function ensureEntryMarker(entry, zoom) {
  if (!entry || entry.marker) {
    return entry ? entry.marker : null;
  }

  const markerData = entry.data;
  if (!markerData) {
    return null;
  }

  const renderStart = monotonicNow();
  let marker = null;
  let realtimeIcon = null;

  if (entry.isRealtime) {
    const nowSec = Date.now() / 1000;
    const icon = buildRealtimeIcon(markerData, zoom, nowSec);
    if (!icon) {
      debugOverlay.noteFiltered('realtime');
      const stackKey = markerStackIndex.get(entry.key);
      if (stackKey) {
        removeMarkerFromStack(stackKey, entry.key);
      } else {
        dropMarkerEntry(entry);
      }
      return null;
    }
    realtimeIcon = icon;
    marker = L.marker([markerData.lat, markerData.lon], {
      icon: L.divIcon({
        className: '',
        html: icon.html,
        iconSize: [icon.size, icon.size],
        iconAnchor: [icon.radius, icon.radius]
      })
    })
      .addTo(map)
      .bindTooltip(getTooltipContent(markerData), { direction: 'top', className: 'custom-tooltip', offset: [0, -8], interactive: true })
      .bindPopup(getPopupContent(markerData));
  } else {
    marker = L.circleMarker([markerData.lat, markerData.lon], {
      radius: getRadius(markerData.doseRate, zoom),
      fillColor: getGradientColor(markerData.doseRate),
      color: getGradientColor(markerData.doseRate),
      weight: 1,
      opacity: getFillOpacity(markerData.speed) + 0.1,
      fillOpacity: getFillOpacity(markerData.speed)
    })
      .addTo(map)
      .bindTooltip(getTooltipContent(markerData), { direction: 'top', className: 'custom-tooltip', offset: [0, -8], interactive: true })
      .bindPopup(getPopupContent(markerData));
  }

  if (!marker) {
    const stackKey = markerStackIndex.get(entry.key);
    if (stackKey) {
      removeMarkerFromStack(stackKey, entry.key);
    } else {
      dropMarkerEntry(entry);
    }
    return null;
  }

  const renderEnd = monotonicNow();
  let footprint = null;
  try {
    const point = map.latLngToContainerPoint([markerData.lat, markerData.lon]);
    let radiusPx = 0;
    if (entry.isRealtime && realtimeIcon) {
      radiusPx = realtimeIcon.radius;
    } else if (marker && typeof marker.getRadius === 'function') {
      radiusPx = marker.getRadius();
    } else if (marker && marker.options && typeof marker.options.radius === 'number') {
      radiusPx = marker.options.radius;
    }
    if (point && typeof point.x === 'number' && typeof point.y === 'number') {
      footprint = { x: point.x, y: point.y, radius: radiusPx };
    }
  } catch (err) {
    footprint = null;
  }

  marker.doseRate = entry.dose;
  marker.date = entry.date;
  marker.isRealtime = entry.isRealtime;
  circleMarkers[entry.key] = marker;
  entry.marker = marker;

  debugOverlay.noteRendered(markerData, renderEnd - renderStart, footprint);
  return marker;
}

// Allow markers to migrate between stacks when a track reports a new position.
function removeMarkerFromStack(stackKey, markerKey) {
  if (!stackKey || !markerKey) return;
  const stack = markerStacks.get(stackKey);
  if (!stack || !Array.isArray(stack.entries)) return;

  const zoom = map && typeof map.getZoom === 'function' ? map.getZoom() : 0;
  const layerLimit = maxLayersForZoom(zoom);
  const prevTotal = Number.isFinite(stack.totalCount) ? stack.totalCount : stack.entries.length;
  const prevVisible = Number.isFinite(stack.visibleCount)
    ? stack.visibleCount
    : Math.min(prevTotal, isFinite(layerLimit) ? layerLimit : prevTotal);

  let removed = false;
  for (let i = stack.entries.length - 1; i >= 0; i -= 1) {
    const entry = stack.entries[i];
    if (entry && entry.key === markerKey) {
      dropMarkerEntry(entry);
      stack.entries.splice(i, 1);
      removed = true;
      break;
    }
  }

  if (!removed) {
    return;
  }

  purgeInvalidStackEntries(stack);

  if (!stack.entries.length) {
    stack.visibleCount = 0;
    updateStackMetricsForStack(stack, prevTotal, prevVisible);
    markerStacks.delete(stackKey);
    return;
  }

  enforceStackVisibility(stack, stackKey, layerLimit, zoom);
  updateStackMetricsForStack(stack, prevTotal, prevVisible);
}

// Insert a marker into the coordinate stack and enforce the active zoom limit.
function registerMarkerEntry(coordKey, entry, layerLimit, zoom) {
  if (!coordKey || !entry || !entry.key) return { keep: false, visible: false };

  const previousStack = markerStackIndex.get(entry.key);
  if (previousStack && previousStack !== coordKey) {
    removeMarkerFromStack(previousStack, entry.key);
  }

  let stack = markerStacks.get(coordKey);
  if (!stack) {
    stack = { entries: [], visibleCount: 0, totalCount: 0 };
    markerStacks.set(coordKey, stack);
  }

  const prevTotal = Number.isFinite(stack.totalCount) ? stack.totalCount : stack.entries.length;
  const prevVisible = Number.isFinite(stack.visibleCount) ? stack.visibleCount : Math.min(prevTotal, isFinite(layerLimit) ? layerLimit : prevTotal);

  purgeInvalidStackEntries(stack);

  for (let i = stack.entries.length - 1; i >= 0; i -= 1) {
    const existing = stack.entries[i];
    if (existing && existing.key === entry.key) {
      dematerialiseEntryMarker(existing);
      stack.entries.splice(i, 1);
      break;
    }
  }

  stack.entries.push(entry);
  stack.entries.sort(compareMarkerEntries);

  enforceStackVisibility(stack, coordKey, layerLimit, zoom);

  const keepIndex = stack.entries.indexOf(entry);
  const keep = keepIndex !== -1;
  const visible = keep && keepIndex < stack.visibleCount;

  updateStackMetricsForStack(stack, prevTotal, prevVisible);

  if (!keep) {
    markerStackIndex.delete(entry.key);
  }

  if (!stack.entries.length) {
    markerStacks.delete(coordKey);
  }

  return { keep: keep, visible: visible };
}

// After a zoom change we revisit every stack so the map never shows more layers
// than budgeted. This keeps the UI reactive without locking on a single big task.
function applyStackLimitsForZoom(zoom) {
  const layerLimit = maxLayersForZoom(zoom);
  markerStacks.forEach(function (stack, coordKey) {
    if (!stack || !Array.isArray(stack.entries)) {
      markerStacks.delete(coordKey);
      return;
    }
    const prevTotal = Number.isFinite(stack.totalCount) ? stack.totalCount : stack.entries.length;
    const prevVisible = Number.isFinite(stack.visibleCount) ? stack.visibleCount : Math.min(prevTotal, isFinite(layerLimit) ? layerLimit : prevTotal);

    enforceStackVisibility(stack, coordKey, layerLimit, zoom);

    if (!stack.entries.length) {
      stack.visibleCount = 0;
      updateStackMetricsForStack(stack, prevTotal, prevVisible);
      markerStacks.delete(coordKey);
      return;
    }

    updateStackMetricsForStack(stack, prevTotal, prevVisible);
  });
}

// registerMapHintHandle remembers a tooltip/popup handle so later gestures can hide it.
function registerMapHintHandle(handle) {
  if (!handle || typeof handle.hide !== 'function') {
    return;
  }
  if (mapHintHandles.indexOf(handle) === -1) {
    mapHintHandles.push(handle);
  }
}

// unregisterMapHintHandle removes a handle when controls are destroyed to avoid stale refs.
function unregisterMapHintHandle(handle) {
  var idx = mapHintHandles.indexOf(handle);
  if (idx !== -1) {
    mapHintHandles.splice(idx, 1);
  }
}

// hideMapHints clears map popups and custom tooltips as soon as a gesture begins on mobile.
function hideMapHints() {
  if (map && typeof map.closePopup === 'function') {
    map.closePopup();
  }
  if (map && typeof map.closeTooltip === 'function') {
    // Leaflet expects an explicit tooltip instance, so we guard the internal ref before closing.
    var activeTooltip = map._tooltip;
    if (activeTooltip) {
      map.closeTooltip(activeTooltip);
    }
  }
  mapHintHandles.forEach(function (handle) {
    if (handle && typeof handle.hide === 'function') {
      handle.hide();
    }
  });
}

if (typeof window !== 'undefined') {
  // Sharing the handler through window keeps custom controls decoupled yet consistent.
  window.hideMapHints = hideMapHints;
}

/* ---------------------------------------------------------------
 *  refreshDownloadLink() toggles the track download button.
 *  We compute the href lazily so the button is only active when a
 *  track is selected, keeping the default map uncluttered.
 * ---------------------------------------------------------------*/
function refreshDownloadLink() {
  var link = document.getElementById('downloadTrackLink');
  var box  = document.querySelector('.download-track-container');
  if (!link || !box) {
    return;
  }
  if (currentTrackID) {
    link.href = '/api/track/' + currentTrackID + '.cim';
    link.setAttribute('download', currentTrackID + '.cim');
    box.style.display = 'block';
  } else {
    link.href = '#';
    link.removeAttribute('download');
    box.style.display = 'none';
  }
}

// New controller to cancel previous request
var markerStreamSource = null;

// ---------------------------------------------------------------
// Marker streaming queue helpers keep DOM updates responsive.
// ---------------------------------------------------------------
let markerStreamQueue = [];
let markerStreamHead = 0;
let markerStreamFlushHandle = 0;
let markerStreamProcessor = null;
let markerStreamLastDrain = 0; // Track last drain timestamp so we can adapt the budget.
let markerStreamBudgetMs = 8;  // Adaptive budget keeps desktop throughput high without stalling touch devices.

// We prefer requestAnimationFrame because it naturally aligns with painting; fall back to a timeout when unavailable.
const markerFrameScheduler = (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function')
  ? window.requestAnimationFrame.bind(window)
  : function (cb) { return setTimeout(cb, 16); };

// Matching cancel helper ensures timers do not leak when the stream restarts.
const markerFrameCanceller = (typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function')
  ? window.cancelAnimationFrame.bind(window)
  : function (handle) { clearTimeout(handle); };

// clearMarkerStreamQueue aborts any pending flush so a new request cannot process stale markers.
function clearMarkerStreamQueue() {
  if (markerStreamFlushHandle) {
    markerFrameCanceller(markerStreamFlushHandle);
    markerStreamFlushHandle = 0;
  }
  markerStreamQueue.length = 0;
  markerStreamHead = 0;
  markerStreamProcessor = null;
  markerStreamLastDrain = 0;
  markerStreamBudgetMs = 8;
}

// setMarkerStreamProcessor wires the queue to the active handler without reallocating the backing array.
function setMarkerStreamProcessor(fn) {
  markerStreamProcessor = typeof fn === 'function' ? fn : null;
  if (!markerStreamProcessor) {
    markerStreamQueue.length = 0;
    markerStreamHead = 0;
    markerStreamLastDrain = 0;
    markerStreamBudgetMs = 8;
  } else {
    markerStreamLastDrain = 0;
    markerStreamBudgetMs = 8;
  }
}

// enqueueMarkerPayload appends to the queue and schedules a flush if one is not already pending.
function enqueueMarkerPayload(payload) {
  if (!markerStreamProcessor) {
    return;
  }
  markerStreamQueue.push(payload);
  if (!markerStreamFlushHandle) {
    if (markerStreamQueue.length - markerStreamHead <= 16) {
      // Process small bursts immediately so realtime markers appear without extra latency.
      runMarkerStreamQueue();
    } else {
      markerStreamFlushHandle = markerFrameScheduler(runMarkerStreamQueue);
    }
  }
}

// runMarkerStreamQueue drains work in adaptive bursts so user gestures stay responsive and desktops still catch up quickly.
function runMarkerStreamQueue() {
  markerStreamFlushHandle = 0;
  if (!markerStreamProcessor || !markerStreamQueue || markerStreamHead >= markerStreamQueue.length) {
    markerStreamQueue.length = 0;
    markerStreamHead = 0;
    return;
  }

  const nowFn = (typeof performance !== 'undefined' && typeof performance.now === 'function')
    ? function () { return performance.now(); }
    : function () { return Date.now(); };
  const start = nowFn();

  if (markerStreamLastDrain) {
    const delta = start - markerStreamLastDrain;
    if (delta > 40) {
      markerStreamBudgetMs = Math.min(markerStreamBudgetMs + 1, 16);
    } else if (delta < 16) {
      markerStreamBudgetMs = Math.max(markerStreamBudgetMs - 1, 4);
    }
  }
  markerStreamLastDrain = start;

  const deadline = start + markerStreamBudgetMs;
  // We check the clock in batches to reduce the overhead of frequent now() calls when the queue is large.
  const stride = markerStreamQueue.length > 4000 ? 32 : markerStreamQueue.length > 1000 ? 16 : 8;
  let processedSinceCheck = 0;

  while (markerStreamHead < markerStreamQueue.length) {
    const item = markerStreamQueue[markerStreamHead];
    markerStreamQueue[markerStreamHead] = null;
    markerStreamHead++;
    processedSinceCheck++;
    try {
      markerStreamProcessor(item);
    } catch (err) {
      console.error('marker queue error', err);
    }
    if (processedSinceCheck >= stride) {
      processedSinceCheck = 0;
      if (nowFn() >= deadline) {
        break;
      }
    }
  }

  if (markerStreamHead >= markerStreamQueue.length) {
    markerStreamQueue.length = 0;
    markerStreamHead = 0;
    return;
  }

  if (markerStreamHead > 2048 && markerStreamHead > markerStreamQueue.length / 2) {
    // Compact the buffer occasionally so long-lived sessions do not grow arrays indefinitely.
    markerStreamQueue.splice(0, markerStreamHead);
    markerStreamHead = 0;
  }

  markerStreamFlushHandle = markerFrameScheduler(runMarkerStreamQueue);
}

// Debug overlay tracks marker streaming metrics so operators can correlate map
// state with backend behaviour without opening the console.
const debugOverlay = (function () {
  const enabled = window.__debugEnabled === true;
  const panel = enabled ? document.getElementById('debugStats') : null;
  const jsErrors = [];
  let metrics = null;
  let listenersAttached = false;
  let lastPayloadBytes = 0;
  let nextMemorySampleAt = 0;
  let memorySamplePending = false;

  // We request a heap snapshot when available so operators see real memory deltas.
  function sampleMemorySnapshot() {
    try {
      if (performance && typeof performance.measureUserAgentSpecificMemory === 'function') {
        return performance.measureUserAgentSpecificMemory()
          .then(function (result) {
            if (result && typeof result.bytes === 'number') {
              return { used: result.bytes, total: result.bytes };
            }
            return null;
          })
          .catch(function () { return null; });
      }
      if (performance && performance.memory && typeof performance.memory.usedJSHeapSize === 'number') {
        const mem = performance.memory;
        const total = typeof mem.totalJSHeapSize === 'number' ? mem.totalJSHeapSize
          : typeof mem.jsHeapSizeLimit === 'number' ? mem.jsHeapSizeLimit
          : mem.usedJSHeapSize;
        return Promise.resolve({ used: mem.usedJSHeapSize, total: total });
      }
    } catch (err) {
      return Promise.resolve(null);
    }
    return Promise.resolve(null);
  }

  // recordMemorySample keeps both the baseline and the high-water mark so operators
  // see how much memory the request actually consumed even if GC runs later.
  function recordMemorySample(snapshot, role) {
    if (!metrics || !snapshot || typeof snapshot.used !== 'number' || !isFinite(snapshot.used)) {
      return;
    }
    const sample = {
      used: snapshot.used,
      total: typeof snapshot.total === 'number' && isFinite(snapshot.total) ? snapshot.total : snapshot.used,
    };
    if (role === 'before') {
      metrics.memoryBefore = sample;
    }
    if (!metrics.memoryPeak || sample.used > metrics.memoryPeak.used) {
      metrics.memoryPeak = sample;
    }
    if (role === 'after') {
      metrics.memoryAfter = sample;
    }
  }

  // scheduleMemorySample throttles heap probes to avoid stalling rendering while
  // still capturing the peaks that make browsers struggle on large marker sets.
  function scheduleMemorySample() {
    if (!enabled || !metrics || memorySamplePending) {
      return;
    }
    const now = typeof performance !== 'undefined' && performance && typeof performance.now === 'function'
      ? performance.now()
      : Date.now();
    if (now < nextMemorySampleAt) {
      return;
    }
    nextMemorySampleAt = now + 2000;
    memorySamplePending = true;
    const current = metrics;
    sampleMemorySnapshot().then(function (snapshot) {
      memorySamplePending = false;
      if (metrics !== current || !snapshot) {
        return;
      }
      recordMemorySample(snapshot, 'during');
      render();
    });
  }

  // Build per-request coverage bookkeeping so we can spot overlapping footprints quickly.
  function createCoverageState() {
    // We keep a coarse grid so overlap checks only inspect nearby neighbours, mirroring
    // "Don't communicate by sharing memory" by letting each cell act as a message hub.
    return {
      markerInfo: new Map(),
      cellMembers: new Map(),
      cellSize: 32,
    };
  }

  function cellsForFootprint(x, y, radius, cellSize) {
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(radius) || radius <= 0) {
      return [];
    }
    const minX = Math.floor((x - radius) / cellSize);
    const maxX = Math.floor((x + radius) / cellSize);
    const minY = Math.floor((y - radius) / cellSize);
    const maxY = Math.floor((y + radius) / cellSize);
    const cells = [];
    for (let cx = minX; cx <= maxX; cx += 1) {
      for (let cy = minY; cy <= maxY; cy += 1) {
        cells.push(cx + ':' + cy);
      }
    }
    return cells;
  }

  function registerCoverage(footprint) {
    if (!metrics || !metrics.coverage) {
      return;
    }

    const coverage = metrics.coverage;
    const key = 'marker-' + metrics.sequence;
    metrics.sequence += 1;

    const x = footprint && typeof footprint.x === 'number' ? footprint.x : NaN;
    const y = footprint && typeof footprint.y === 'number' ? footprint.y : NaN;
    const radius = footprint && typeof footprint.radius === 'number' && footprint.radius > 0
      ? footprint.radius
      : 0;

    const info = {
      covered: false,
      cells: [],
      x: x,
      y: y,
      radius: radius,
      stack: 1,
    };
    coverage.markerInfo.set(key, info);

    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      if (metrics.maxStack < 1) {
        metrics.maxStack = 1;
      }
      return;
    }

    const cells = cellsForFootprint(x, y, radius, coverage.cellSize);
    info.cells = cells;

    if (!cells.length) {
      if (metrics.maxStack < 1) {
        metrics.maxStack = 1;
      }
      return;
    }

    // We only count true overlaps so dense clusters do not pretend everything is hidden.
    const seen = new Set();
    let overlapCount = 0;

    cells.forEach(function (cellKey) {
      let members = coverage.cellMembers.get(cellKey);
      if (!members) {
        members = new Set();
        coverage.cellMembers.set(cellKey, members);
      }

      members.forEach(function (existingKey) {
        if (seen.has(existingKey)) {
          return;
        }
        seen.add(existingKey);
        const existing = coverage.markerInfo.get(existingKey);
        if (!existing || !Number.isFinite(existing.x) || !Number.isFinite(existing.y)) {
          return;
        }

        const exRadius = typeof existing.radius === 'number' && existing.radius > 0 ? existing.radius : 0;
        const dx = existing.x - x;
        const dy = existing.y - y;
        const maxDistance = exRadius + radius;

        if (maxDistance <= 0) {
          if (dx === 0 && dy === 0) {
            overlapCount += 1;
            existing.covered = true;
          }
          return;
        }

        if ((dx * dx + dy * dy) <= (maxDistance * maxDistance)) {
          overlapCount += 1;
          existing.covered = true;
        }
      });

      members.add(key);
    });

    if (overlapCount > 0) {
      const stackSize = overlapCount + 1;
      info.stack = stackSize;
      seen.forEach(function (existingKey) {
        const existing = coverage.markerInfo.get(existingKey);
        if (existing) {
          const prev = typeof existing.stack === 'number' ? existing.stack : 1;
          if (stackSize > prev) {
            existing.stack = stackSize;
          }
        }
      });
      if (stackSize > metrics.maxStack) {
        metrics.maxStack = stackSize;
      }
    } else if (metrics.maxStack < 1) {
      metrics.maxStack = 1;
    }
  }

  function attachGlobalListeners() {
    if (!enabled || !panel || listenersAttached) {
      return;
    }
    window.addEventListener('error', function (event) {
      if (!enabled) return;
      const message = event && event.message ? event.message : 'JavaScript error';
      pushJSError(message);
    });
    window.addEventListener('unhandledrejection', function (event) {
      if (!enabled) return;
      let message = 'Unhandled rejection';
      if (event && event.reason) {
        if (typeof event.reason === 'string') {
          message = event.reason;
        } else if (event.reason && typeof event.reason.message === 'string') {
          message = event.reason.message;
        } else {
          message = String(event.reason);
        }
      }
      pushJSError(message);
    });
    listenersAttached = true;
  }

  function pushJSError(message) {
    jsErrors.push({ message: message, time: Date.now() });
    if (jsErrors.length > 5) {
      jsErrors.shift();
    }
    render();
  }

  function formatBytes(bytes) {
    if (typeof bytes !== 'number' || !isFinite(bytes)) {
      return 'n/a';
    }
    if (Math.abs(bytes) < 1024) {
      return bytes.toFixed(0) + ' B';
    }
    const mb = bytes / (1024 * 1024);
    return mb.toFixed(1) + ' MB';
  }

  function formatDuration(ms) {
    if (typeof ms !== 'number' || !isFinite(ms) || ms < 0) {
      return 'n/a';
    }
    if (ms < 1000) {
      return ms.toFixed(0) + ' ms';
    }
    return (ms / 1000).toFixed(2) + ' s';
  }

  function initialiseMetrics() {
    metrics = {
      requestStart: performance.now(),
      firstMarkerAt: null,
      lastMarkerAt: null,
      totalMarkers: 0,
      visibleMarkers: 0,
      filteredDate: 0,
      filteredSpeed: 0,
      filteredRealtime: 0,
      maxStack: 0,
      stackTotal: 0,
      stackFiltered: 0,
      stackVisible: 0,
      renderCost: 0,
      doneAt: null,
      memoryBefore: null,
      memoryAfter: null,
      memoryPeak: null,
      payloadBytes: 0,
      freedBytes: lastPayloadBytes,
      backendErrors: [],
      coverage: createCoverageState(),
      sequence: 0,
    };
    nextMemorySampleAt = 0;
    memorySamplePending = false;
    const current = metrics;
    sampleMemorySnapshot().then(function (snapshot) {
      if (metrics !== current) {
        return;
      }
      recordMemorySample(snapshot, 'before');
      render();
    });
  }

  function ensureMetrics() {
    if (!metrics) {
      initialiseMetrics();
    }
    return metrics;
  }

  function render() {
    if (!enabled || !panel || !metrics) {
      if (panel) {
        panel.style.display = 'none';
        panel.textContent = '';
      }
      return;
    }

    const hasData = metrics.totalMarkers > 0 || metrics.visibleMarkers > 0 ||
      metrics.stackTotal > 0 || metrics.stackFiltered > 0 || metrics.stackVisible > 0 ||
      metrics.backendErrors.length > 0 || jsErrors.length > 0 || metrics.doneAt !== null;
    if (!hasData) {
      panel.style.display = 'none';
      panel.textContent = '';
      return;
    }

    let uncovered = 0;
    let covered = 0;
    if (metrics.coverage && metrics.coverage.markerInfo) {
      metrics.coverage.markerInfo.forEach(function (info) {
        if (info && info.covered) {
          covered += 1;
        } else {
          uncovered += 1;
        }
      });
    }
    if (metrics.visibleMarkers > 0 && uncovered === 0 && covered === 0) {
      uncovered = metrics.visibleMarkers;
    }

    const filteredTotal = metrics.filteredDate + metrics.filteredSpeed + metrics.filteredRealtime;
    const expectedTotal = metrics.totalMarkers;
    const requestDuration = metrics.doneAt !== null ? (metrics.doneAt - metrics.requestStart) : null;
    const buildDuration = (metrics.firstMarkerAt !== null && metrics.lastMarkerAt !== null)
      ? (metrics.lastMarkerAt - metrics.firstMarkerAt)
      : null;
    const renderCost = metrics.renderCost;
    const fetchCost = requestDuration !== null ? Math.max(0, requestDuration - renderCost) : null;

    let memoryUsed = 'n/a';
    let memoryFreed = 'n/a';
    if (metrics.memoryBefore && metrics.memoryPeak) {
      const usedDelta = Math.max(0, metrics.memoryPeak.used - metrics.memoryBefore.used);
      memoryUsed = formatBytes(usedDelta);
    } else if (metrics.memoryBefore && metrics.memoryAfter) {
      const usedDelta = metrics.memoryAfter.used - metrics.memoryBefore.used;
      memoryUsed = formatBytes(Math.max(0, usedDelta));
    } else if (metrics.payloadBytes > 0) {
      memoryUsed = '&#8776; ' + formatBytes(metrics.payloadBytes);
    }

    if (metrics.memoryPeak && metrics.memoryAfter) {
      const freedDelta = Math.max(0, metrics.memoryPeak.used - metrics.memoryAfter.used);
      memoryFreed = formatBytes(freedDelta);
    } else if (metrics.memoryBefore && metrics.memoryAfter) {
      const freedDelta = metrics.memoryBefore.used - metrics.memoryAfter.used;
      memoryFreed = formatBytes(Math.max(0, freedDelta));
    } else if (typeof metrics.freedBytes === 'number' && metrics.freedBytes > 0) {
      memoryFreed = '&#8776; ' + formatBytes(metrics.freedBytes);
    }

    const latestJSError = jsErrors.length > 0 ? jsErrors[jsErrors.length - 1].message : 'none';
    const backendErrors = metrics.backendErrors.length > 0 ? metrics.backendErrors.join('; ') : 'none';

    const stackTotal = Number.isFinite(metrics.stackTotal) ? metrics.stackTotal : 0;
    const stackFiltered = Number.isFinite(metrics.stackFiltered) ? metrics.stackFiltered : Math.max(0, stackTotal - metrics.stackVisible);
    const stackVisible = Number.isFinite(metrics.stackVisible) ? metrics.stackVisible : Math.max(0, stackTotal - stackFiltered);

    const lines = [
      `<div><strong>Markers:</strong> ${metrics.visibleMarkers} visible / ${expectedTotal} fetched (filtered ${filteredTotal})</div>`,
      `<div><strong>Coverage:</strong> uncovered ${uncovered}, covered ${covered}, max stack ${metrics.maxStack}</div>`,
      `<div><strong>Stacking:</strong> total ${stackTotal}, filtered ${stackFiltered}, kept ${stackVisible}</div>`,
      `<div><strong>Timing:</strong> fetch ${formatDuration(fetchCost)}, render ${formatDuration(renderCost)}, build ${formatDuration(buildDuration)}</div>`,
      `<div><strong>Request:</strong> total ${formatDuration(requestDuration)}</div>`,
      `<div><strong>Memory:</strong> used ${memoryUsed}, freed ${memoryFreed}</div>`,
      `<div><strong>Expected:</strong> ${expectedTotal} markers</div>`,
      `<div><strong>JS errors:</strong> ${latestJSError}</div>`,
      `<div><strong>Backend errors:</strong> ${backendErrors}</div>`
    ];

    panel.style.display = 'block';
    panel.innerHTML = lines.join('');
  }

  attachGlobalListeners();

  return {
    enabled: enabled,
    startRequest: function () {
      if (!enabled) {
        return;
      }
      attachGlobalListeners();
      initialiseMetrics();
      render();
    },
    noteIncoming: function (payloadLength) {
      if (!enabled) {
        return;
      }
      const current = ensureMetrics();
      current.totalMarkers += 1;
      if (typeof payloadLength === 'number' && payloadLength > 0 && isFinite(payloadLength)) {
        current.payloadBytes += payloadLength;
      }
    },
    recordStackTotals: function (total, filtered, visible) {
      if (!enabled) {
        return;
      }
      const current = ensureMetrics();
      current.stackTotal = Number.isFinite(total) ? Math.max(0, total) : 0;
      current.stackFiltered = Number.isFinite(filtered) ? Math.max(0, filtered) : 0;
      current.stackVisible = Number.isFinite(visible) ? Math.max(0, visible) : 0;
      render();
    },
    noteFiltered: function (reason) {
      if (!enabled || !metrics) {
        return;
      }
      if (reason === 'date') {
        metrics.filteredDate += 1;
      } else if (reason === 'speed') {
        metrics.filteredSpeed += 1;
      } else {
        metrics.filteredRealtime += 1;
      }
      render();
    },
    noteRendered: function (marker, renderDuration, footprint) {
      if (!enabled || !metrics || !marker) {
        return;
      }
      const now = performance.now();
      if (metrics.firstMarkerAt === null) {
        metrics.firstMarkerAt = now;
      }
      metrics.lastMarkerAt = now;
      metrics.visibleMarkers += 1;
      if (typeof renderDuration === 'number' && isFinite(renderDuration)) {
        metrics.renderCost += renderDuration;
      }
      registerCoverage(footprint || null);
      scheduleMemorySample();
      render();
    },
    finishRequest: function () {
      if (!enabled || !metrics) {
        return;
      }
      if (metrics.doneAt === null) {
        metrics.doneAt = performance.now();
        nextMemorySampleAt = 0;
        scheduleMemorySample();
        const current = metrics;
        sampleMemorySnapshot().then(function (snapshot) {
          if (metrics !== current) {
            return;
          }
          recordMemorySample(snapshot, 'after');
          render();
        });
        lastPayloadBytes = metrics.payloadBytes;
      }
      render();
    },
    recordBackendError: function (message) {
      if (!enabled || !metrics) {
        return;
      }
      if (message && message.trim() !== '') {
        metrics.backendErrors.push(message.trim());
        if (metrics.backendErrors.length > 5) {
          metrics.backendErrors = metrics.backendErrors.slice(-5);
        }
      }
      render();
    }
  };
})();

var liveHistoryCache = new Map();


/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return defaults that reflect backend capabilities.
 *   Realtime on:  Safecast heart on, ✈️ off, 🚗 on, 🚶 on  (as requested).
 *   Realtime off: ✈️ off, 🚗 on, 🚶 on  (heart absent).
 */
function loadSpeedFilterState() {
  // We derive defaults from the realtime flag so the UI matches backend capabilities.
  const base = { plane: false, car: true, ped: true };
  if (window.safecastRealtimeEnabled) {
    base.live = true;
  }
  try {
    const raw = sessionStorage.getItem('speedFilterState');
    const st = raw ? JSON.parse(raw) : {};
    const merged = Object.assign({}, base, st);
    if (!window.safecastRealtimeEnabled) {
      delete merged.live;
    }
    return merged;
  } catch (e) {
    return base;
  }
}

// ---------- helpers for time-range state ------------------------
function loadDateRangeState() {
  try { return JSON.parse(sessionStorage.getItem('dateRangeState')) || null; }
  catch(e){ return null; }
}
function saveDateRangeState(st) {
  sessionStorage.setItem('dateRangeState', JSON.stringify(st));
}

/**
 * Return a "Month YYYY" string in the browser locale.
 * Chrome/Firefox often display "Aug 2025",
 * Safari shows "Aug 2025", etc.
 */
function tsToNiceStr(ts){
  return new Date(ts * 1000)
    .toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}


// absolute month difference between two unix timestamps
function monthsApart(ts0, ts1){
  const d0 = new Date(ts0 * 1000);
  const d1 = new Date(ts1 * 1000);
  return Math.abs((d1.getFullYear() - d0.getFullYear()) * 12 +
    (d1.getMonth()     - d0.getMonth()));
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user’s choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
  // Persist only supported options so stale realtime toggles do not leak between sessions.
  const toSave = Object.assign({}, state);
  if (!window.safecastRealtimeEnabled) {
    delete toSave.live;
  }
  sessionStorage.setItem('speedFilterState', JSON.stringify(toSave));
}

/**
 * Attach a lightweight tooltip to a control so every hint shares one theme-aware renderer.
 * We return show/hide/destroy handlers to let callers reuse a single tooltip while controls collapse.
 */
function attachControlTooltip(target, options) {
  if (!target) {
    return {
      hide: function noopHide() {},
      destroy: function noopDestroy() {},
    };
  }

  const opts = Object.assign({
    placement: 'top',
    html: false,
    maxWidth: 280,
  }, options || {});

  let tooltipEl = null;
  let handle = null; // Remember the handle so destroyTooltip can unregister it later.

  function resolveContent() {
    const content = typeof opts.content === 'function' ? opts.content() : opts.content;
    return content || '';
  }

  function positionTooltip() {
    if (!tooltipEl || !target) {
      return;
    }
    const rect = target.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return;
    }
    const tipRect = tooltipEl.getBoundingClientRect();
    const margin = 10;
    let left = rect.left + (rect.width / 2) - (tipRect.width / 2);
    let top = rect.top - tipRect.height - margin;

    switch (opts.placement) {
      case 'bottom':
        top = rect.bottom + margin;
        left = rect.left + (rect.width / 2) - (tipRect.width / 2);
        break;
      case 'left':
        left = rect.left - tipRect.width - margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      case 'right':
        left = rect.right + margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      default:
        // keep default top placement
        break;
    }

    const viewportPadding = 8;
    left = Math.max(viewportPadding, Math.min(left, window.innerWidth - tipRect.width - viewportPadding));
    top = Math.max(viewportPadding, Math.min(top, window.innerHeight - tipRect.height - viewportPadding));
    tooltipEl.style.left = left + 'px';
    tooltipEl.style.top = top + 'px';
  }

  function showTooltip() {
    if (!target || !target.isConnected) {
      return;
    }
    const rects = target.getClientRects();
    if (!rects || rects.length === 0) {
      return;
    }
    const content = resolveContent();
    if (!content) {
      return;
    }
    if (tooltipEl) {
      if (opts.html) {
        tooltipEl.innerHTML = content;
      } else {
        tooltipEl.textContent = content;
      }
      positionTooltip();
      return;
    }
    tooltipEl = document.createElement('div');
    tooltipEl.className = 'control-tooltip';
    tooltipEl.setAttribute('role', 'tooltip');
    const maxWidth = typeof opts.maxWidth === 'number' ? opts.maxWidth + 'px' : opts.maxWidth;
    tooltipEl.style.maxWidth = maxWidth;
    if (opts.html) {
      tooltipEl.innerHTML = content;
    } else {
      tooltipEl.textContent = content;
    }
    document.body.appendChild(tooltipEl);
    positionTooltip();
    window.addEventListener('scroll', positionTooltip, true);
    window.addEventListener('resize', positionTooltip);
    requestAnimationFrame(function () {
      if (tooltipEl) {
        tooltipEl.classList.add('control-tooltip--visible');
      }
    });
  }

  function hideTooltip() {
    if (!tooltipEl) {
      return;
    }
    window.removeEventListener('scroll', positionTooltip, true);
    window.removeEventListener('resize', positionTooltip);
    const el = tooltipEl;
    tooltipEl = null;
    el.classList.remove('control-tooltip--visible');
    setTimeout(function () {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    }, 150);
  }

  function destroyTooltip() {
    hideTooltip();
    target.removeEventListener('mouseenter', showTooltip);
    target.removeEventListener('mouseleave', hideTooltip);
    target.removeEventListener('focus', showTooltip);
    target.removeEventListener('blur', hideTooltip);
    target.removeEventListener('keydown', onKeyDown);
    hideEvents.forEach(function (evt) {
      target.removeEventListener(evt, hideMapHints, false);
    });
    if (handle) {
      unregisterMapHintHandle(handle);
    }
  }

  function onKeyDown(ev) {
    if (ev.key === 'Escape') {
      hideTooltip();
    }
  }

  target.addEventListener('mouseenter', showTooltip);
  target.addEventListener('mouseleave', hideTooltip);
  target.addEventListener('focus', showTooltip);
  target.addEventListener('blur', hideTooltip);
  target.addEventListener('keydown', onKeyDown);

  // hideEvents wires every control interaction into hideMapHints for consistency on touch screens.
  var hideEvents = ['pointerdown', 'touchstart', 'wheel'];
  hideEvents.forEach(function (evt) {
    target.addEventListener(evt, hideMapHints, false);
  });

  handle = {
    show: showTooltip,
    hide: hideTooltip,
    destroy: destroyTooltip,
  };
  registerMapHintHandle(handle);
  return handle;
}


document.addEventListener('DOMContentLoaded', function () {

  // Initialize trackID from path
  var match = window.location.pathname.match(/^\/trackid\/([a-zA-Z0-9]+)/);
  if (match) {
    currentTrackID = match[1];
    isTrackView = true;
    // NEW: show back button immediately
    var backBox = document.querySelector('.back-to-all-container');
    if (backBox) backBox.style.display = 'block';
  }
  refreshDownloadLink();

  // Theme-aware hover hints keep visitors oriented without repeating markup titles.
  var uploadLabel = document.querySelector('.upload-btn');
  attachControlTooltip(uploadLabel, {
    placement: 'left',
    content: function () { return translate('upload_button_tooltip'); },
    maxWidth: 320,
  });

  var locateBtn = document.getElementById('locateButton');
  attachControlTooltip(locateBtn, {
    placement: 'left',
    content: function () { return translate('locate_button_tooltip'); },
  });

  var qrBtn = document.getElementById('qrButton');
  attachControlTooltip(qrBtn, {
    placement: 'left',
    content: function () { return translate('qr_button_tooltip'); },
  });

  var themeToggle = document.getElementById('themeToggle');
  attachControlTooltip(themeToggle, {
    placement: 'left',
    content: function () { return translate('theme_toggle_tooltip'); },
    maxWidth: 260,
  });

  var shortLink = document.getElementById('shortLinkDisplay');
  if (shortLink) {
    var shortLinkHandle = attachControlTooltip(shortLink, {
      placement: 'bottom',
      content: function () { return translate('short_link_tooltip'); },
      maxWidth: 260,
    });
    window.__hideShortLinkHint = shortLinkHandle.hide;
  }

  var legendBox = document.getElementById('legend');
  if (legendBox) {
    var legendHandle = attachControlTooltip(legendBox, {
      placement: 'left',
      content: function () { return translate('legend_button_tooltip'); },
      maxWidth: 300,
    });
    window.__hideLegendHint = legendHandle.hide;
    legendBox.addEventListener('keydown', function (ev) {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        openLegendModal();
      }
    });
  }

  var githubLink = document.querySelector('.github-link');
  if (githubLink) {
    var githubHandle = attachControlTooltip(githubLink, {
      placement: 'top',
      html: true,
      maxWidth: 320,
      content: function () {
        var version = '{{ .Version }}';
        var title = translate('github_link_tooltip_title');
        var desc = translate('github_link_tooltip_desc');
        var versionText = translate('github_link_tooltip_version');
        if (typeof versionText === 'string' && versionText.indexOf('{version}') !== -1) {
          versionText = versionText.replace('{version}', version);
        }
        return '<div class="control-tooltip__title">' + title + '</div>' +
          '<div>' + desc + '</div>' +
          '<div class="control-tooltip__meta">' + versionText + '</div>';
      },
    });
    window.__hideGithubHint = githubHandle.hide;
    githubLink.addEventListener('click', function () {
      githubHandle.hide();
    });
  }

  // Initialize layers and auto theme switch
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const osmLight = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const osmDark  = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  window.osmLight = osmLight; // expose for theme toggle
  window.osmDark  = osmDark;  // expose for theme toggle
  // Google tiles always use satellite imagery for consistent look
  const googleSat   = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';

  osmLayer = L.tileLayer(media.matches ? osmDark : osmLight, {
    maxZoom: 18,
    attribution: '&copy; OSM contributors'
  });

  // Use the same satellite layer regardless of theme
  googleSatellite = L.tileLayer(googleSat, {
    maxZoom: 20,
    attribution: '&copy; Google'
  });

  // right after creating osmLayer and googleSatellite
  const urlParams       = new URLSearchParams(window.location.search);
  const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
  const startLayer      = startLayerName === 'Google Satellite' ? googleSatellite : osmLayer;

  map = L.map('map', {
    center: [defaultCfg.lat, defaultCfg.lon],
    zoom  : defaultCfg.zoom,
    layers: [startLayer],           // only one base layer
  });

  // We listen to every gesture so tooltips disappear as soon as a visitor touches the map.
  var mapGestureEvents = [
    'movestart',
    'move',
    'moveend',
    'zoomstart',
    'zoomend',
    'dragstart',
    'dragend',
    'click',
    'mousedown',
    'touchstart'
  ];
  mapGestureEvents.forEach(function (evt) {
    map.on(evt, hideMapHints);
  });

  var mapContainer = typeof map.getContainer === 'function' ? map.getContainer() : null;
  if (mapContainer && typeof mapContainer.addEventListener === 'function') {
    ['pointerdown', 'touchstart', 'wheel'].forEach(function (evt) {
      mapContainer.addEventListener(evt, hideMapHints, false);
    });
  }

  // Layer control
  var baseLayers = {
    "OpenStreetMap": osmLayer,
    "Google Satellite": googleSatellite
  };

  L.control.layers(baseLayers, null, {
    position: 'topleft',
    collapsed: false
  }).addTo(map);

  // Add custom attribution links that open informative popups
  map.attributionControl.addAttribution(
		'<a href="#" class="attr-link" data-info="api">' + translate('attr_api') + '</a> | ' + 
    '<a href="#" class="attr-link" data-info="legal">' + translate('attr_legal') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="sources">' + translate('attr_sources') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="license">' + translate('attr_license') + '</a>'
  );

  // Track view initialization
  // Inject markers as literal JSON so the first render avoids the template parse error
  // and the frontend can inspect the slice immediately.
  var initialMarkers = {{ .MarkersJSON }};
  if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
    isTrackView = true;

    // Don't show initialMarkers immediately; load them in parts via get_markers
    map.on('load', debounceUpdateMarkers);

    // Adjust marker size on zoom
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
  } else {
    // Dynamic marker updates in global mode
    map.on('load', debounceUpdateMarkers);
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
    debounceUpdateMarkers;
  }

  // Load map state from URL
  loadMapFromUrl();

  // Update URL on map changes
  map.on('baselayerchange', updateUrl);
  map.on('moveend', updateUrl);
  map.on('zoomend', updateUrl);

  // Initialize UI elements
  initializeUIElements();

  // Periodically refresh realtime styling so markers fade without map motion.
  setInterval(adjustMarkerRadius, 60 * 1000);

  /**
   * Build a Leaflet control with three check-boxes that filter markers
   * by recorded speed. Labels now show speed in km/h instead of m/s.
   * Default state (when realtime exists): Safecast heart on, ✈️ off, 🚗 on, 🚶 on.
   */
  function createSpeedFilterControls() {

    if (isTrackView) return;   // hidden in track view

    // load previously saved state (or defaults)
    const state = loadSpeedFilterState();

    // custom Leaflet control
    const SpeedCtrl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-control-layers');
        div.style.padding = '6px 10px';

        // helper that returns one <label> line
        const row = (id, iconMarkup, checked, extraClass = '') => `
            <label style="white-space:nowrap;display:block;cursor:pointer;">
            <input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
            <span class="speed-filter-icon ${extraClass}">${iconMarkup}</span>
            </label>`;

        // Build rows dynamically so the realtime checkbox only appears when supported server-side.
        const pieces = [];
        if (window.safecastRealtimeEnabled) {
          // Use the Safecast heart artwork so the live toggle reflects the new branding.
          const liveIconMarkup = '<img src="/static/images/safecast-heart-logo.png" alt="Realtime measurements from safecast.org" style="width:1em; height:1em; vertical-align:middle;"/>';
          pieces.push(row('sfLive', liveIconMarkup, state.live));
          pieces.push('<div class="leaflet-control-layers-separator"></div>');
        }
        pieces.push(
          row('sfPlane', '✈️', state.plane, 'speed-filter-icon--mono'),
          row('sfCar',   '🚗', state.car,   'speed-filter-icon--mono'),
          row('sfPed',   '🚶', state.ped,   'speed-filter-icon--mono')
        );
        div.innerHTML = pieces.join('');

        // We collect all checkboxes so keyboard focus and pointer use can share a single tooltip instance.
        const checkboxes = Array.from(div.querySelectorAll('input[type=checkbox]'));

        // Attach an explanatory tooltip so visitors understand how each checkbox slices the dataset by speed.
        const speedTooltipHandle = attachControlTooltip(div, {
          placement: 'right',
          html: true,
          maxWidth: 340,
          content: function () {
            const title = translate('speed_filter_tooltip_title');
            const intro = translate('speed_filter_tooltip_intro');
            const accuracy = translate('speed_filter_tooltip_accuracy');
            const lines = [];
            if (window.safecastRealtimeEnabled) {
              lines.push(translate('speed_filter_tooltip_live'));
            }
            lines.push(translate('speed_filter_tooltip_plane'));
            lines.push(translate('speed_filter_tooltip_car'));
            lines.push(translate('speed_filter_tooltip_ped'));
            const listHtml = lines.map(function (line) {
              return '<li>' + line + '</li>';
            }).join('');
            return '<div class="control-tooltip__title">' + title + '</div>' +
              '<div>' + intro + '</div>' +
              '<ul class="control-tooltip__list">' + listHtml + '</ul>' +
              '<div class="control-tooltip__meta">' + accuracy + '</div>';
          },
        });

        // Keyboard users focus the individual checkboxes, so we mirror the combined tooltip when inputs gain focus.
        checkboxes.forEach(cb => {
          cb.addEventListener('focus', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.show === 'function') {
              speedTooltipHandle.show();
            }
          });
          cb.addEventListener('blur', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.hide === 'function') {
              speedTooltipHandle.hide();
            }
          });
        });

        // prevent map drag/zoom while clicking inside the control
        L.DomEvent.disableClickPropagation(div);

        // attach change-handlers
        checkboxes.forEach(cb => {
          cb.addEventListener('change', () => {
            if (window.safecastRealtimeEnabled) {
              state.live = div.querySelector('#sfLive').checked;
            } else {
              delete state.live;
            }
            state.plane = div.querySelector('#sfPlane').checked;
            state.car   = div.querySelector('#sfCar').checked;
            state.ped   = div.querySelector('#sfPed').checked;
            saveSpeedFilterState(state);   // remember choice
            debounceUpdateMarkers();       // redraw with new filter
          });
        });

        return div;
      }
    });

    new SpeedCtrl({ position: 'topleft' }).addTo(map);
  }



  // Call it
  createSpeedFilterControls();   
  createDateRangeSlider();



});


/**
 * Date-range control with two modes:
 *  - YEAR (single handle): labels show full [minYear..maxYear] when NO user filter is active,
 *    otherwise they show the chosen year.
 *  - MONTH (double handle): classic [from..to] range.
 *
 * Key ideas:
 *  • We expose window.__setDateSliderVisibility(show)
 *  • We expose window.__initSliderOnce(minTs,maxTs) for first build
 *  • We expose window.__syncDateSliders(minTs,maxTs) to keep ranges/labels
 *    in sync with the current map viewport on every pan/zoom IF no custom
 *    time filter is set by the user.
 *
 * No globals except 3 window.* hooks; no vendor APIs beyond noUiSlider.
 */
function createDateRangeSlider(){

  if (isTrackView) return;   // no date control in single-track mode

  let sliderBox, yearSlider, monthSlider;
  let mode  = 'year';                // 'year' | 'month'
  let initY = false, initM = false;  // lazy init flags
  let sliderTooltipHandle = null;    // tooltip helper for hover hints

  // We store the "full range" of current viewport to detect
  // whether a saved filter is actually "show all".
  let fullRange = null; // [minTs,maxTs]

  const DateCtrl = L.Control.extend({
    onAdd(){
      sliderBox = L.DomUtil.create('div','leaflet-control-layers date-slider-box');
      sliderBox.style.display = 'none'; // hidden until needed
      sliderBox.innerHTML = `
        <div class="slider-toggle">
          <button id="btnYear"  class="active">Y</button>
          <button id="btnMonth">M</button>
        </div>
        <div id="lblMax" class="slider-label"></div>
        <div id="yearSlider"></div>
        <div id="dateSlider"></div>
        <div id="lblMin" class="slider-label"></div>
        <button id="btnReset" class="slider-reset-btn" title="Reset"> ⟲ </button>
      `;
      sliderBox.setAttribute('role', 'group');
      sliderBox.setAttribute('tabindex', '0');
      sliderBox.setAttribute('aria-label', translate('date_slider_tooltip'));
      sliderTooltipHandle = attachControlTooltip(sliderBox, {
        placement: 'right',
        content: function () { return translate('date_slider_tooltip'); },
        maxWidth: 300,
      });
      return sliderBox;
    }
  });
  new DateCtrl({ position:'topleft' }).addTo(map);

  const btnY = sliderBox.querySelector('#btnYear');
  const btnM = sliderBox.querySelector('#btnMonth');
  const btnReset = sliderBox.querySelector('#btnReset');
  const lblMin = () => sliderBox.querySelector('#lblMin');
  const lblMax = () => sliderBox.querySelector('#lblMax');

  btnY.onclick = () => switchMode('year');
  btnM.onclick = () => switchMode('month');

  // Show/hide the whole control (called from updateMarkers())
  window.__setDateSliderVisibility = (show)=>{
    sliderBox.style.display = show ? 'block' : 'none';
    if(!show) sessionStorage.removeItem('dateRangeState');
    if (!show && sliderTooltipHandle) {
      sliderTooltipHandle.hide();
    }
  };

  // One-time creation of both sliders using initial bounds
  window.__initSliderOnce = (minTs,maxTs)=>{
    if (initY && initM) return;
    fullRange = [minTs,maxTs]; // remember initial "full range"

    // YEAR slider (single handle)
    if(!initY){
      yearSlider = sliderBox.querySelector('#yearSlider');
      const minYear = new Date(minTs*1000).getUTCFullYear();
      const maxYear = new Date(maxTs*1000).getUTCFullYear();

      noUiSlider.create(yearSlider,{
        start      : minYear,                // the handle can sit anywhere; labels decide what to show
        connect    : [true,false],
        orientation: 'vertical',
        direction  : 'rtl',
        step       : 1,
        range      : { min:minYear, max:maxYear },
        format     : wNumb({ decimals:0 })
      });

      // Update labels:
      //  - If NO user filter or filter equals fullRange → show full year bounds.
      //  - Else → show the chosen year.
      yearSlider.noUiSlider.on('update', ([y])=>{
        if (mode !== 'year') return;
        const saved = loadDateRangeState();
        const fr = fullRange || [minTs,maxTs];
        const isFull = !saved || (saved[0] === fr[0] && saved[1] === fr[1]);
        if (isFull){
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = r.min;
          lblMax().textContent = r.max;
        } else {
          lblMin().textContent = y;
          lblMax().textContent = y;
        }
      });
      yearSlider.noUiSlider.on('change', updateDateFilter);
      initY = true;
    }

    // MONTH slider (double handle)
    if(!initM){
      monthSlider = sliderBox.querySelector('#dateSlider');
      noUiSlider.create(monthSlider,{
        start       : [minTs,maxTs],
        connect     : true,
        orientation : 'vertical',
        direction   : 'rtl',
        step        : 3600, // 1 hour
        range       : { min:minTs, max:maxTs },
        format      : wNumb({ decimals:0 })
      });
      monthSlider.noUiSlider.on('update', ()=>{
        if (mode !== 'month') return;
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      });
      monthSlider.noUiSlider.on('change', updateDateFilter);
      monthSlider.style.display = 'none';
      initM = true;
    }

    // Initial labels = full bounds
    if (mode === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      lblMin().textContent = r.min;
      lblMax().textContent = r.max;
    } else {
      lblMin().textContent = tsToNiceStr(minTs);
      lblMax().textContent = tsToNiceStr(maxTs);
    }
  };

  // Sync ranges and labels to the *current* viewport on every pan/zoom,
  // but ONLY when user has not applied a custom time filter.
  window.__syncDateSliders = (minTs,maxTs)=>{
    if (!initY || !initM) return; // not built yet

    // Detect whether user has a custom time filter (not full range).
    const saved = loadDateRangeState();
    const prevFull = fullRange;
    fullRange = [minTs,maxTs]; // update "full" range to the new viewport

    const hasCustom =
      !!saved && !(saved[0] === prevFull?.[0] && saved[1] === prevFull?.[1]) &&
      !(saved[0] === fullRange[0] && saved[1] === fullRange[1]);

    // Update YEAR slider bounds
    const minYear = new Date(minTs*1000).getUTCFullYear();
    const maxYear = new Date(maxTs*1000).getUTCFullYear();
    yearSlider.noUiSlider.updateOptions({
      range: { min:minYear, max:maxYear }
    }, false);

    // Update MONTH slider bounds
    monthSlider.noUiSlider.updateOptions({
      range: { min:minTs, max:maxTs }
    }, false);

    // If no custom filter → force labels to show full bounds and make month slider span all
    if (!hasCustom){
      if (mode === 'year'){
        const r = yearSlider.noUiSlider.options.range;
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        monthSlider.noUiSlider.set([minTs,maxTs]);
        lblMin().textContent = tsToNiceStr(minTs);
        lblMax().textContent = tsToNiceStr(maxTs);
      }
      // persist that "no filter" means full range
      saveDateRangeState([minTs,maxTs]);
    }
  };

  // Reset button → drop custom filter and show full bounds of the *current* viewport
  btnReset.onclick = ()=>{
    sessionStorage.removeItem('dateRangeState');
    if (initY && initM){
      const rY = yearSlider.noUiSlider.options.range;
      const rM = monthSlider.noUiSlider.options.range;
      yearSlider.noUiSlider.set(rY.min);      // handle position is cosmetic
      monthSlider.noUiSlider.set([rM.min, rM.max]);

      lblMin().textContent = (mode==='year') ? rY.min : tsToNiceStr(rM.min);
      lblMax().textContent = (mode==='year') ? rY.max : tsToNiceStr(rM.max);

      // remember "no filter" == full range of the viewport
      saveDateRangeState([rM.min, rM.max]);
      debounceUpdateMarkers();
    }
  };

  function switchMode(next){
    if (mode === next) return;

    mode = next;
    btnY.classList.toggle('active', next==='year');
    btnM.classList.toggle('active', next==='month');
    yearSlider.style.display  = next==='year'  ? 'block' : 'none';
    monthSlider.style.display = next==='month' ? 'block' : 'none';

    // Refresh labels on mode switch respecting full/custom state
    const saved = loadDateRangeState();
    const fr = fullRange;
    const isFull = !saved || (fr && saved[0]===fr[0] && saved[1]===fr[1]);

    if (next === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      if (isFull){
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        const y = +yearSlider.noUiSlider.get();
        lblMin().textContent = y;
        lblMax().textContent = y;
      }
    } else {
      const r = monthSlider.noUiSlider.options.range;
      if (isFull){
        monthSlider.noUiSlider.set([r.min, r.max]);
        lblMin().textContent = tsToNiceStr(r.min);
        lblMax().textContent = tsToNiceStr(r.max);
      } else {
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      }
    }

    // Do not change filter on mode flip; user intent remains the same
  }

  function updateDateFilter(){
    // YEAR mode → make a full [year..year] month span
    if (mode==='year'){
      const y = +yearSlider.noUiSlider.get();
      const from = Date.UTC(y,0,1)/1000;
      const to   = Date.UTC(y+1,0,1)/1000 - 1;
      saveDateRangeState([from,to]);
    } else {
      saveDateRangeState(monthSlider.noUiSlider.get().map(Number));
    }
    debounceUpdateMarkers();
  }
}



// Function definitions

// ---------- Marker popups and tooltips ----------
// Build HTML once so popups and tooltips share identical content.
  function buildLiveMarkerPopup(marker) {
    const doseRate = marker.doseRate || 0;
    const microValue = formatMicroRoentgen(doseRate);
    const doseColor = getGradientColor(doseRate);
    const statusKey = doseCategory(doseRate);
    const statusLabel = translate(statusKey);
    const statusTextColor = isDarkColor(doseColor) ? '#ffffff' : '#000000';
    const milliSievert = `${doseRate.toFixed(3)} µSv/h`;
    const lastSeen = formatDateTime(marker.date);
    const local = approximateLocalTime(marker.lat, marker.lon);
    const extrasRaw = (marker.liveExtra && typeof marker.liveExtra === 'object') ? marker.liveExtra : null;
    const extrasCopy = extrasRaw ? Object.assign({}, extrasRaw) : {};

    const climateParts = [];
    if (extrasRaw) {
      if (typeof extrasRaw.temperature_c === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature'))}: ${escapeHtml(formatExtraValue('temperature_c', extrasRaw.temperature_c))}`);
        delete extrasCopy.temperature_c;
      } else if (typeof extrasRaw.temperature_f === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature_f'))}: ${escapeHtml(formatExtraValue('temperature_f', extrasRaw.temperature_f))}`);
        delete extrasCopy.temperature_f;
      }
      if (typeof extrasRaw.humidity_percent === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_humidity'))}: ${escapeHtml(formatExtraValue('humidity_percent', extrasRaw.humidity_percent))}`);
        delete extrasCopy.humidity_percent;
      }
    }

    const climateHtml = climateParts.length ? `<div class="live-popup-climate">${climateParts.join(' · ')}</div>` : '';
    const extrasBlock = renderLiveExtras(extrasCopy);
    const deviceID = marker.deviceID || (marker.trackID ? marker.trackID.replace(/^live:/, '') : '');
    const attrs = [];
    if (deviceID) attrs.push(`data-device="${escapeHtml(deviceID)}"`);
    if (marker.deviceName) attrs.push(`data-name="${escapeHtml(marker.deviceName)}"`);
    if (marker.transport) attrs.push(`data-transport="${escapeHtml(marker.transport)}"`);
    if (marker.tube) attrs.push(`data-tube="${escapeHtml(marker.tube)}"`);
    if (marker.country) attrs.push(`data-country="${escapeHtml(marker.country)}"`);
    if (typeof marker.lat === 'number') attrs.push(`data-lat="${marker.lat}"`);
    if (typeof marker.lon === 'number') attrs.push(`data-lon="${marker.lon}"`);
    const chartLink = deviceID ? `<div><a href="#" class="live-chart-link live-popup-small-link" ${attrs.join(' ')}>${translate('live_marker_chart_link')}</a></div>` : '';

    const metaBits = [];
    metaBits.push(`<div><strong>${translate('live_marker_last_seen')}:</strong> ${escapeHtml(lastSeen)}</div>`);
    if (local) {
      metaBits.push(`<div><strong>${translate('live_marker_local_time')}:</strong> ${escapeHtml(local.text)} (${escapeHtml(local.zone)})</div>`);
    }
    const deviceMeta = buildDeviceMeta(marker);
    if (deviceMeta) metaBits.push(deviceMeta);
    if (extrasBlock) metaBits.push(extrasBlock);
    if (chartLink) metaBits.push(chartLink);
    const metaHtmlBlock = metaBits.length ? `<div class="live-popup-meta">${metaBits.join('')}</div>` : '';

    return `
      <div class="custom-tooltip live-tooltip">
        <div class="live-tooltip-header">
          <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime" class="live-tooltip-heart">
          <div>
            <div class="live-tooltip-title">${translate('live_marker_title')}</div>
            <p class="live-tooltip-desc">${describeLiveSensor(marker)}</p>
          </div>
        </div>
        <div class="live-popup-dose">
          <div class="live-popup-dose-primary" style="color:${doseColor};">
            ${microValue}<span class="live-popup-dose-unit">µR/h</span>
          </div>
          <div class="live-popup-dose-secondary" style="color:${doseColor};">
            ${milliSievert}
          </div>
          <div class="live-popup-dose-status" style="background:${doseColor};color:${statusTextColor};">
            <a href="#" class="risk-link" style="color:${statusTextColor};">${escapeHtml(statusLabel)}</a>
          </div>
        </div>
        ${climateHtml}
        ${metaHtmlBlock}
      </div>`;
  }

  function buildMarkerContent(marker) {
    if (marker.speed < 0) {
      return buildLiveMarkerPopup(marker);
    }

    const speedText = (typeof marker.speed === 'number' && isFinite(marker.speed))
      ? `${(marker.speed * 3.6).toFixed(1)} km/h`
      : '—';

    return `
      <div class="custom-tooltip">
        <div><strong>${translate('radiation_dose')}:</strong><br>
          ${(marker.doseRate * 100).toFixed(2)} µR/h (${marker.doseRate.toFixed(2)} µSv/h)
          (<a href="#" class="risk-link">
            ${translate(doseCategory(marker.doseRate))}
          </a>)
        </div>
        <div><strong>${translate('speed')}:</strong> ${speedText}</div>
        <div style="margin-top:4px">
          <!-- clicking the link switches to track mode -->
          <a href="#" class="track-link" data-track="${marker.trackID}" style="font-weight:bold;">
            ${translate('track_id')}: ${marker.trackID}
          </a>
        </div>
      </div>`;
  }

// Popup reuses shared builder to stay in sync with tooltips.
function getPopupContent(marker) {
  return buildMarkerContent(marker);
}

// Tooltip uses the same builder for hover previews.
function getTooltipContent(marker) {
  return buildMarkerContent(marker);
}


/* Request markers for current bounds/zoom, render them,
 * and keep the date sliders in sync with the viewport.
 */
function updateMarkers(){
  const loadingEl = document.getElementById('loadingOverlay');
  if (loadingEl) loadingEl.style.display='block';

  debugOverlay.startRequest();

  if (markerStreamSource) markerStreamSource.close();
  clearMarkerStreamQueue(); // Reset pending work so a fresh stream cannot leak old markers.

  const zoom   = map.getZoom();
  const bounds = map.getBounds();
  const layerLimit = maxLayersForZoom(zoom);

  const params = {
    zoom  : zoom,
    minLat: bounds.getSouthWest().lat,
    minLon: bounds.getSouthWest().lng,
    maxLat: bounds.getNorthEast().lat,
    maxLon: bounds.getNorthEast().lng
  };
  if (currentTrackID) params.trackID = currentTrackID; // focus on a single track when set

  const savedRange = loadDateRangeState();
  for (const key in circleMarkers) map.removeLayer(circleMarkers[key]);
  circleMarkers = {};
  markerStacks.clear();
  markerStackIndex.clear();
  resetStackMetrics();

  const tracks = new Set();
  let minTs = Infinity, maxTs = -Infinity;

  function processStreamMarker(m) {
    if (!m || typeof m !== 'object') {
      return;
    }

    const isLive = typeof m.speed === 'number' && m.speed < 0; // negative speed denotes realtime marker

    if (savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) {
      debugOverlay.noteFiltered('date');
      return;
    }
    if (!shouldDisplayBySpeed(m.speed)) {
      debugOverlay.noteFiltered('speed');
      return;
    }

    // Fast-return for stale realtime data keeps the stack clean so we never store entries
    // that cannot render, echoing "Don't just do something, stand there" by staying calm.
    if (isLive) {
      const nowSec = Date.now() / 1000;
      if (!buildRealtimeIcon(m, zoom, nowSec)) {
        debugOverlay.noteFiltered('realtime');
        return;
      }
    }

    // Store dose rate and timestamp on marker for later size updates
    const markerKey = m && typeof m.id !== 'undefined' && m.id !== null
      ? String(m.id)
      : (m && typeof m.trackID !== 'undefined' && m.trackID !== null
        ? String(m.trackID)
        : 'anon-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2));
    const coordKey = buildCoordinateKey(m.lat, m.lon);
    const entry = {
      key  : markerKey,
      dose : (typeof m.doseRate === 'number' && isFinite(m.doseRate)) ? m.doseRate : 0,
      date : (typeof m.date === 'number' && isFinite(m.date)) ? m.date : 0,
      data : m,
      isRealtime: isLive,
      marker: null
    };
    const registration = registerMarkerEntry(coordKey, entry, layerLimit, zoom);
    if (!registration.keep) {
      return;
    }
    if (registration.visible) {
      ensureEntryMarker(entry, zoom);
    }
  }

  setMarkerStreamProcessor(processStreamMarker);

  const es = new EventSource('/stream_markers?' + new URLSearchParams(params));
  markerStreamSource = es;

  es.onmessage = e => {
    debugOverlay.noteIncoming(e && typeof e.data === 'string' ? e.data.length : 0);
    let markerPayload;
    try {
      markerPayload = JSON.parse(e.data);
    } catch (err) {
      return;
    }
    const liveMarker = typeof markerPayload.speed === 'number' && markerPayload.speed < 0;
    if (!liveMarker && markerPayload && markerPayload.trackID) {
      tracks.add(markerPayload.trackID);
    }
    if (markerPayload && typeof markerPayload.date === 'number' && isFinite(markerPayload.date)) {
      if (markerPayload.date < minTs) minTs = markerPayload.date;
      if (markerPayload.date > maxTs) maxTs = markerPayload.date;
    }
    enqueueMarkerPayload(markerPayload);
  };

  es.addEventListener('done', () => {
    const dateSpanMonths = (isFinite(minTs) && isFinite(maxTs))
                            ? monthsApart(minTs, maxTs) : 0;
    const needSlider = !isTrackView && tracks.size > 1 && dateSpanMonths > 1;
    if (window.__setDateSliderVisibility){
      window.__setDateSliderVisibility(needSlider);
    }
    if (needSlider && window.__initSliderOnce && isFinite(minTs) && isFinite(maxTs)){
      window.__initSliderOnce(minTs, maxTs);
      window.__initSliderOnce = null;
    }
    if (needSlider && window.__syncDateSliders && isFinite(minTs) && isFinite(maxTs)){
      window.__syncDateSliders(minTs, maxTs);
    }
    if (loadingEl) loadingEl.style.display='none';
    debugOverlay.finishRequest();
    es.close();
  });

  es.onerror = () => {
    if (loadingEl) loadingEl.style.display='none';
    debugOverlay.recordBackendError('stream error');
    debugOverlay.finishRequest();
    clearMarkerStreamQueue();
    es.close();
  };
}

async function fetchLiveHistory(deviceID) {
  if (!deviceID) throw new Error('device');
  if (liveHistoryCache.has(deviceID)) {
    return liveHistoryCache.get(deviceID);
  }
  const resp = await fetch('/realtime_history?device=' + encodeURIComponent(deviceID));
  if (!resp.ok) {
    throw new Error('history');
  }
  const data = await resp.json();
  liveHistoryCache.set(deviceID, data);
  return data;
}

function chartColors() {
  const theme = document.documentElement.dataset.theme;
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const dark = theme === 'dark' || (!theme && prefersDark);
  if (dark) {
    return { grid: 'rgba(255,255,255,0.2)', line: '#90caf9', text: '#e0e0e0', background: 'rgba(255,255,255,0.08)' };
  }
  return { grid: 'rgba(0,0,0,0.2)', line: '#1e88e5', text: '#333333', background: 'rgba(0,0,0,0.05)' };
}

function radiationLineColor(valueMicroRoentgen) {
  return getGradientColor(valueMicroRoentgen / 100);
}

function niceNumber(range, round) {
  if (!isFinite(range) || range === 0) return 0;
  const exponent = Math.floor(Math.log10(Math.abs(range)));
  const fraction = range / Math.pow(10, exponent);
  let niceFraction;
  if (round) {
    if (fraction < 1.5) niceFraction = 1;
    else if (fraction < 3) niceFraction = 2;
    else if (fraction < 7) niceFraction = 5;
    else niceFraction = 10;
  } else {
    if (fraction <= 1) niceFraction = 1;
    else if (fraction <= 2) niceFraction = 2;
    else if (fraction <= 5) niceFraction = 5;
    else niceFraction = 10;
  }
  return niceFraction * Math.pow(10, exponent);
}

function niceTicks(min, max, count) {
  if (!isFinite(min) || !isFinite(max) || count <= 0) return [];
  if (min === max) return [min];
  const range = niceNumber(max - min, false);
  if (range === 0) return [];
  const spacing = niceNumber(range / (count - 1), true);
  if (!isFinite(spacing) || spacing === 0) return [];
  const niceMin = Math.floor(min / spacing) * spacing;
  const niceMax = Math.ceil(max / spacing) * spacing;
  const ticks = [];
  for (let v = niceMin; v <= niceMax + spacing / 2; v += spacing) {
    ticks.push(v);
  }
  return ticks;
}

const TIME_TICK_STEPS = [
  60,
  120,
  300,
  600,
  900,
  1800,
  3600,
  7200,
  14400,
  21600,
  43200,
  86400,
  172800,
  604800,
  1209600,
  2592000,
  7776000,
  15552000,
  31536000,
];

function selectTimeStep(spanSeconds, bucketSeconds) {
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return bucketSeconds || 60;
  }
  let minStep = spanSeconds / 6;
  if (bucketSeconds && bucketSeconds > minStep) {
    minStep = bucketSeconds;
  } else if (bucketSeconds) {
    minStep = Math.max(bucketSeconds, minStep / 2);
  }
  for (let i = 0; i < TIME_TICK_STEPS.length; i++) {
    if (TIME_TICK_STEPS[i] >= minStep) {
      return TIME_TICK_STEPS[i];
    }
  }
  return Math.max(bucketSeconds || TIME_TICK_STEPS[TIME_TICK_STEPS.length - 1], Math.round(minStep));
}

function buildTimeTicks(start, end, bucketSeconds) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  const span = end - start;
  const step = selectTimeStep(span, bucketSeconds);
  if (!isFinite(step) || step <= 0) return [];
  const ticks = [];
  const first = Math.ceil(start / step) * step;
  for (let ts = first; ts <= end; ts += step) {
    ticks.push(ts);
  }
  return ticks;
}

function secondsForUnit(unit) {
  switch (unit) {
    case 'hour':
      return 3600;
    case 'day':
      return 86400;
    default:
      return 0;
  }
}

// buildSegmentTicks divides the range into evenly spaced segments without relying
// on heuristics so the canvas grid can honour strict hour/day/month splits.
function buildSegmentTicks(start, end, segments, unit) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  if (!segments || segments <= 0) return [];
  if (unit === 'month') {
    const ticks = [];
    let cursor = new Date(start * 1000);
    cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth(), 1, 0, 0, 0, 0));
    for (let i = 1; i < segments; i++) {
      cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1, 0, 0, 0, 0));
      const ts = Math.floor(cursor.getTime() / 1000);
      if (ts <= start || ts >= end) {
        continue;
      }
      ticks.push(ts);
    }
    return ticks;
  }
  const step = secondsForUnit(unit);
  if (!step) return [];
  const ticks = [];
  for (let i = 1; i < segments; i++) {
    const ts = start + step * i;
    if (ts <= start || ts >= end) continue;
    ticks.push(ts);
  }
  return ticks;
}

function formatTimeTickLabel(ts, spanSeconds, lang) {
  if (!isFinite(ts)) return '';
  const date = new Date(ts * 1000);
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 48 * 3600) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 90 * 86400) {
    return date.toLocaleString(lang, { month: 'short', day: 'numeric', hour: '2-digit' });
  }
  if (spanSeconds <= 400 * 86400) {
    return date.toLocaleDateString(lang, { month: 'short', day: 'numeric' });
  }
  if (spanSeconds <= 5 * 365 * 86400) {
    return date.toLocaleDateString(lang, { year: 'numeric', month: 'short' });
  }
  return date.toLocaleDateString(lang, { year: 'numeric' });
}

function formatAveragingWindow(seconds) {
  if (!seconds || !isFinite(seconds)) return '';
  const abs = Math.abs(seconds);
  const units = [
    { limit: 3600, key: 'duration_minutes', divisor: 60 },
    { limit: 48 * 3600, key: 'duration_hours', divisor: 3600 },
    { limit: 14 * 86400, key: 'duration_days', divisor: 86400 },
    { limit: 90 * 86400, key: 'duration_weeks', divisor: 604800 },
    { limit: Infinity, key: 'duration_months', divisor: 2592000 },
  ];
  let chosen = units[units.length - 1];
  for (let i = 0; i < units.length; i++) {
    if (abs < units[i].limit) {
      chosen = units[i];
      break;
    }
  }
  const template = translate(chosen.key);
  if (!template) return '';
  const count = Math.max(1, Math.round(abs / chosen.divisor));
  return template.replace('[[count]]', count);
}

function describeRangeLabel(range) {
  if (!range || typeof range.start !== 'number' || typeof range.end !== 'number') return '';
  if (range.end <= range.start) return '';
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const span = range.end - range.start;
  let startOpts;
  let endOpts;
  if (span <= 48 * 3600) {
    startOpts = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    endOpts = startOpts;
  } else if (span <= 120 * 86400) {
    startOpts = { month: 'short', day: 'numeric' };
    endOpts = { month: 'short', day: 'numeric' };
  } else if (span <= 720 * 86400) {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  } else {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  }
  const startText = new Date(range.start * 1000).toLocaleString(lang, startOpts);
  const endText = new Date(range.end * 1000).toLocaleString(lang, endOpts);
  if (!startText || !endText) return '';
  return startText + ' → ' + endText;
}

function drawLiveChart(canvas, radiationPoints, extrasByKey, options) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (width === 0 || height === 0) return;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const colors = chartColors();
  canvas.style.background = colors.background;

  const fontTokens = resolveFontTokens(); // Use CSS-driven sizes so canvas labels match the rest of the UI.
  const fonts = {
    axisY: fontTokens.sm + ' ' + fontTokens.family,
    axisX: fontTokens.xs + ' ' + fontTokens.family,
    extras: fontTokens.sm + ' ' + fontTokens.family,
    legend: fontTokens.base + ' ' + fontTokens.family,
  };

  const extras = {};
  if (extrasByKey && typeof extrasByKey === 'object') {
    Object.keys(extrasByKey).forEach(function(key) {
      const series = extrasByKey[key];
      if (Array.isArray(series) && series.length) {
        extras[key] = series;
      }
    });
  }
  const extraKeys = sortExtraKeys(Object.keys(extras));
  const hasRadiation = Array.isArray(radiationPoints) && radiationPoints.length > 0;
  if (!hasRadiation && extraKeys.length === 0) {
    return;
  }

  const baseSeries = hasRadiation ? radiationPoints : extras[extraKeys[0]];
  if (!baseSeries || !baseSeries.length) {
    return;
  }

  const opts = options || {};
  let minX = baseSeries[0].timestamp;
  let maxX = baseSeries[baseSeries.length - 1].timestamp || (minX + 1);
  if (typeof opts.start === 'number' && typeof opts.end === 'number' && opts.end > opts.start) {
    minX = opts.start;
    maxX = opts.end;
  }
  if (!(maxX > minX)) {
    maxX = minX + 1;
  }
  const bucketSeconds = typeof opts.bucketSeconds === 'number' ? opts.bucketSeconds : 0;

  let minY;
  let maxY;
  if (hasRadiation) {
    minY = radiationPoints[0].value;
    maxY = radiationPoints[0].value;
    radiationPoints.forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  } else {
    const key = extraKeys[0];
    minY = extras[key][0].value;
    maxY = extras[key][0].value;
    extras[key].forEach(function(point) {
      if (point.value < minY) minY = point.value;
      if (point.value > maxY) maxY = point.value;
    });
  }
  if (minY === maxY) {
    const delta = minY === 0 ? 0.5 : Math.abs(minY) * 0.2;
    minY -= delta;
    maxY += delta;
  }

  const extraRanges = {};
  extraKeys.forEach(function(key) {
    const series = extras[key];
    let minVal = series[0].value;
    let maxVal = series[0].value;
    series.forEach(function(point) {
      if (point.value < minVal) minVal = point.value;
      if (point.value > maxVal) maxVal = point.value;
    });
    if (minVal === maxVal) {
      const delta = minVal === 0 ? 0.5 : Math.abs(minVal) * 0.2;
      minVal -= delta;
      maxVal += delta;
    }
    extraRanges[key] = { min: minVal, max: maxVal };
  });

  const extraColumnWidth = 72;
  const rightPad = extraKeys.length ? extraColumnWidth * extraKeys.length + 20 : 20;
  const leftPad = hasRadiation ? 70 : 50;
  const topPad = 64;
  const bottomPad = 44;

  const plotLeft = leftPad;
  const plotRight = width - rightPad;
  const plotTop = topPad;
  const plotBottom = height - bottomPad;
  const plotW = Math.max(plotRight - plotLeft, 10);
  const plotH = Math.max(plotBottom - plotTop, 10);

  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const spanSeconds = maxX - minX;

  const rangeX = (maxX - minX) || 1;
  const rangeY = hasRadiation ? ((maxY - minY) || 1) : 1;

  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotLeft, plotTop);
  ctx.lineTo(plotLeft, plotBottom);
  ctx.lineTo(plotRight, plotBottom);
  if (extraKeys.length) {
    ctx.moveTo(plotRight, plotTop);
    ctx.lineTo(plotRight, plotBottom);
  }
  ctx.stroke();

  const ticksY = niceTicks(minY, maxY, 5);
  ctx.font = fonts.axisY;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ticksY.forEach(function(value) {
    if (!isFinite(value)) return;
    const y = plotBottom - ((value - minY) / rangeY) * plotH;
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.5);
    ctx.beginPath();
    ctx.moveTo(plotLeft, y);
    ctx.lineTo(plotRight, y);
    ctx.stroke();
    const label = formatMicroRoentgenValue(value);
    ctx.fillStyle = colors.text;
    ctx.fillText(label, plotLeft - 8, y);
  });

  const tickUnit = opts.tickUnit || null;
  const tickSegments = opts.tickSegments || 0;
  const forcedTicks = (tickUnit && tickSegments > 0) ? buildSegmentTicks(minX, maxX, tickSegments, tickUnit) : null;
  const ticksX = forcedTicks && forcedTicks.length ? forcedTicks : buildTimeTicks(minX, maxX, bucketSeconds);
  const approxStep = (tickUnit && tickSegments > 0)
    ? (tickUnit === 'month' ? (maxX - minX) / tickSegments : secondsForUnit(tickUnit))
    : (bucketSeconds || 0);
  const axisLabelY = height - 12;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = fonts.axisX;
  ctx.strokeStyle = colorWithAlpha(colors.grid, 0.35);
  ticksX.forEach(function(ts) {
    if (!isFinite(ts)) return;
    const x = plotLeft + ((ts - minX) / rangeX) * plotW;
    ctx.beginPath();
    ctx.moveTo(x, plotTop);
    ctx.lineTo(x, plotBottom);
    ctx.stroke();
    const label = formatTimeTickLabel(ts, spanSeconds, lang);
    if (!label) return;
    ctx.fillStyle = colors.text;
    ctx.fillText(label, x, axisLabelY);
  });

  const tolerance = Math.max(60, approxStep || 0);
  const showStart = !ticksX.some(function(ts) { return Math.abs(ts - minX) < tolerance; });
  const showEnd = !ticksX.some(function(ts) { return Math.abs(ts - maxX) < tolerance; });
  ctx.fillStyle = colors.text;
  const startLabel = formatTimeTickLabel(minX, spanSeconds, lang);
  if (showStart && startLabel) {
    ctx.fillText(startLabel, plotLeft, axisLabelY);
  }
  ctx.textAlign = 'right';
  const endLabel = formatTimeTickLabel(maxX, spanSeconds, lang);
  if (showEnd && endLabel) {
    ctx.fillText(endLabel, plotRight, axisLabelY);
  }

  if (hasRadiation) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    for (let i = 1; i < radiationPoints.length; i++) {
      const prev = radiationPoints[i - 1];
      const curr = radiationPoints[i];
      const x1 = plotLeft + ((prev.timestamp - minX) / rangeX) * plotW;
      const y1 = plotBottom - ((prev.value - minY) / rangeY) * plotH;
      const x2 = plotLeft + ((curr.timestamp - minX) / rangeX) * plotW;
      const y2 = plotBottom - ((curr.value - minY) / rangeY) * plotH;
      // Applying a per-segment gradient keeps falling values flowing back to green
      // and rising values blending toward the warmer colors.
      const startColor = radiationLineColor(prev.value);
      const endColor = radiationLineColor(curr.value);
      const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
      gradient.addColorStop(0, startColor);
      gradient.addColorStop(1, endColor);
      ctx.strokeStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    if (radiationPoints.length === 1) {
      const lone = radiationPoints[0];
      const x = plotLeft + ((lone.timestamp - minX) / rangeX) * plotW;
      const y = plotBottom - ((lone.value - minY) / rangeY) * plotH;
      ctx.fillStyle = radiationLineColor(lone.value);
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  extraKeys.forEach(function(key, idx) {
    const series = extras[key];
    const range = extraRanges[key];
    const denom = (range.max - range.min) || 1;
    const color = colorForExtraKey(key);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    series.forEach(function(point, i) {
      const x = plotLeft + ((point.timestamp - minX) / rangeX) * plotW;
      const y = plotBottom - ((point.value - range.min) / denom) * plotH;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);

    const xBase = plotRight + 8 + idx * extraColumnWidth;
    const suffix = extraUnitSuffix(key);
    const maxLabel = formatExtraAxisValue(key, range.max);
    const minLabel = formatExtraAxisValue(key, range.min);
    ctx.font = fonts.extras;
    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    if (maxLabel) {
      ctx.fillText(maxLabel + (suffix ? ' ' + suffix : ''), xBase, plotTop + 12);
    }
    if (minLabel) {
      ctx.fillText(minLabel + (suffix ? ' ' + suffix : ''), xBase, plotBottom - 4);
    }
  });

  ctx.font = fonts.legend;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'left';
  const legendY = topPad - 20;
  let legendX = plotLeft;
  const legendEntries = [];
  if (hasRadiation) {
    // The legend reuses a gradient so the key matches the multi-hued line.
    const legendGradient = ctx.createLinearGradient(legendX, legendY, legendX + 18, legendY);
    legendGradient.addColorStop(0, radiationLineColor(minY));
    legendGradient.addColorStop(1, radiationLineColor(maxY));
    legendEntries.push({ label: translate('radiation_dose') + ' (µR/h)', color: legendGradient, solid: true });
  }
  extraKeys.forEach(function(key) {
    const suffix = extraUnitSuffix(key);
    const label = labelForExtraKey(key) + (suffix ? ' (' + suffix + ')' : '');
    legendEntries.push({ label: label, color: colorForExtraKey(key), solid: false });
  });
  legendEntries.forEach(function(entry) {
    ctx.strokeStyle = entry.color;
    ctx.lineWidth = entry.solid ? 3 : 1.5;
    ctx.setLineDash(entry.solid ? [] : [5, 3]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 18, legendY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = colors.text;
    ctx.fillText(entry.label, legendX + 24, legendY + 4);
    legendX += ctx.measureText(entry.label).width + 64;
  });
}


function updateChartHeading(element, key, ranges) {
  if (!element) return;
  const base = translate('live_chart_' + key);
  const range = ranges && ranges[key];
  const desc = describeRangeLabel(range);
  element.textContent = desc ? base + ' · ' + desc : base;
}

function updateChartWindowLabel(rangeKey, ranges) {
  const el = document.querySelector(`.live-chart-window[data-range="${rangeKey}"]`);
  if (!el) return;
  const range = ranges && ranges[rangeKey];
  if (!range || !range.bucketSeconds) {
    el.textContent = '';
    return;
  }
  const windowText = formatAveragingWindow(range.bucketSeconds);
  if (!windowText) {
    el.textContent = '';
    return;
  }
  const template = translate('live_chart_averaged');
  el.textContent = template ? template.replace('[[window]]', windowText) : windowText;
}

function hideLiveModal() {
  const modal = document.getElementById('liveModal');
  if (modal) modal.style.display = 'none';
}

async function openLiveModal(deviceID, fallback) {
  const modal = document.getElementById('liveModal');
  if (!modal) return;
  modal.style.display = 'flex';

  const titleEl = document.getElementById('liveModalTitle');
  const descEl = document.getElementById('liveModalDescription');
  const metaEl = document.getElementById('liveModalMeta');
  const extraEl = document.getElementById('liveModalExtra');

  const dayTitle = document.getElementById('liveChartTitleDay');
  const monthTitle = document.getElementById('liveChartTitleMonth');
  const allTitle = document.getElementById('liveChartTitleAll');
  updateChartHeading(dayTitle, 'day');
  updateChartHeading(monthTitle, 'month');
  updateChartHeading(allTitle, 'all');

  const closeBtn = document.getElementById('liveModalClose');
  if (closeBtn) closeBtn.textContent = translate('live_chart_close');

  const fallbackMarker = {
    deviceID: fallback && fallback.device ? String(fallback.device) : (fallback && fallback.id ? String(fallback.id) : ''),
    deviceName: fallback && fallback.name ? fallback.name : '',
    transport: fallback && fallback.transport ? fallback.transport : '',
    country: fallback && fallback.country ? fallback.country : '',
    tube: fallback && fallback.tube ? fallback.tube : '',
  };

  if (titleEl) {
    titleEl.textContent = fallbackMarker.deviceName || translate('live_marker_title');
  }
  if (descEl) {
    descEl.textContent = describeLiveSensor(fallbackMarker);
  }
  if (metaEl) {
    metaEl.innerHTML = buildDeviceMeta(fallbackMarker);
  }
  if (extraEl) {
    extraEl.innerHTML = '';
  }

  ['day','month','all'].forEach(function(range){
    const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
    if (empty) { empty.textContent = ''; empty.style.display = 'none'; }
    const canvas = document.querySelector(`.live-chart-canvas[data-range="${range}"]`);
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    updateChartWindowLabel(range);
  });

  try {
    const data = await fetchLiveHistory(deviceID);
    const merged = {
      deviceID: data.deviceID || fallbackMarker.deviceID,
      deviceName: data.deviceName || fallbackMarker.deviceName,
      transport: data.transport || fallbackMarker.transport,
      tube: data.tube || fallbackMarker.tube,
      country: data.country || fallbackMarker.country,
      lat: fallback && fallback.lat ? parseFloat(fallback.lat) : undefined,
      lon: fallback && fallback.lon ? parseFloat(fallback.lon) : undefined,
      liveExtra: data.extra || null,
    };

    if (titleEl) {
      titleEl.textContent = merged.deviceName || translate('live_marker_title');
    }
    if (descEl) {
      descEl.textContent = describeLiveSensor(merged);
    }
    if (metaEl) {
      const metaParts = [];
      const metaBlock = buildDeviceMeta(merged);
      if (metaBlock) metaParts.push(metaBlock);
      const local = approximateLocalTime(merged.lat, merged.lon);
      if (local) {
        metaParts.push('<div><strong>' + translate('live_marker_local_time') + ':</strong> ' + escapeHtml(local.text) + ' (' + escapeHtml(local.zone) + ')</div>');
      }
      metaEl.innerHTML = metaParts.join('');
    }
    if (extraEl) {
      extraEl.innerHTML = renderLiveExtras(merged.liveExtra);
    }

    const ranges = (data && data.ranges && typeof data.ranges === 'object') ? data.ranges : {};
    // Range metadata keeps headings and averaging labels aligned with backend aggregation.

    updateChartHeading(dayTitle, 'day', ranges);
    updateChartHeading(monthTitle, 'month', ranges);
    updateChartHeading(allTitle, 'all', ranges);
    updateChartWindowLabel('day', ranges);
    updateChartWindowLabel('month', ranges);
    updateChartWindowLabel('all', ranges);

    ['day','month','all'].forEach(function(range){
      const canvas = document.querySelector(`.live-chart-canvas[data-range="${range}"]`);
      const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
      const series = data.series && data.series[range] ? data.series[range] : [];
      const extras = data.extraSeries && data.extraSeries[range] ? data.extraSeries[range] : null;
      const hasSeries = (series && series.length) || hasExtraSeries(extras);
      const rangeInfo = ranges && ranges[range] ? ranges[range] : null;
      const options = {};
      // Passing explicit bounds avoids axes jumping when resampled data omits raw endpoints.
      if (rangeInfo && typeof rangeInfo.start === 'number' && typeof rangeInfo.end === 'number') {
        options.start = rangeInfo.start;
        options.end = rangeInfo.end;
      }
      if (rangeInfo && typeof rangeInfo.bucketSeconds === 'number') {
        options.bucketSeconds = rangeInfo.bucketSeconds;
      }
      if (range === 'day') {
        options.tickUnit = 'hour';
        options.tickSegments = 24;
      } else if (range === 'month') {
        options.tickUnit = 'day';
        options.tickSegments = 24;
      } else if (range === 'all') {
        options.tickUnit = 'month';
        options.tickSegments = 24;
      }
      if (canvas && hasSeries) {
        if (empty) empty.style.display = 'none';
        drawLiveChart(canvas, series, extras, options);
      } else if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
    });
  } catch (err) {
    if (descEl) {
      descEl.textContent = translate('live_marker_history_error');
    }
    ['day','month','all'].forEach(function(range){
      const empty = document.querySelector(`.live-chart-empty[data-range="${range}"]`);
      if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
      updateChartWindowLabel(range);
    });
  }
}




let debounceTimeout;

function debounceUpdateMarkers() {
  clearTimeout(debounceTimeout);
  debounceTimeout = setTimeout(updateMarkers, 300);
}

function adjustMarkerRadius() {
  var zoomLevel = map.getZoom();
  applyStackLimitsForZoom(zoomLevel);
  const nowSec = Date.now() / 1000;
  for (let key in circleMarkers) {
    let marker = circleMarkers[key];
    if (marker.isRealtime) {
      // Recompute icon style so stale sensors fade without user interaction.
      const icon = buildRealtimeIcon(marker, zoomLevel, nowSec);
      if (!icon) {
        map.removeLayer(marker);
        delete circleMarkers[key];
        continue;
      }
      marker.setIcon(L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]}));
    } else if (typeof marker.setRadius === 'function') {
      // Circle markers scale by adjusting radius directly
      let newRadius = getRadius(marker.doseRate, zoomLevel);
      marker.setRadius(newRadius);
    }
  }
}

/* -----------------------------------------------------------------
 *  viewTrack() — switch to single-track mode.
 *  Set currentTrackID = trackID before changing window.location.
 * -----------------------------------------------------------------*/
function viewTrack(trackID) {
  currentTrackID = trackID;   // new
  isTrackView    = true;

  const bounds = map.getBounds();
  const layer  = map.hasLayer(googleSatellite) ? 'Google Satellite'
    : 'OpenStreetMap';
  const zoom   = map.getZoom();

  const trackURL =
    `/trackid/${trackID}` +
    `?minLat=${bounds.getSouthWest().lat}` +
    `&minLon=${bounds.getSouthWest().lng}` +
    `&maxLat=${bounds.getNorthEast().lat}` +
    `&maxLon=${bounds.getNorthEast().lng}` +
    `&zoom=${zoom}` +
    `&layer=${encodeURIComponent(layer)}`;

  window.location.href = trackURL;
}


function setBaseLayer(layerName) {
  if (layerName === 'Google Satellite') {
    if (map.hasLayer(osmLayer))            map.removeLayer(osmLayer);
    if (!map.hasLayer(googleSatellite))    googleSatellite.addTo(map);
  } else {
    if (map.hasLayer(googleSatellite))     map.removeLayer(googleSatellite);
    if (!map.hasLayer(osmLayer))           osmLayer.addTo(map);
  }
}

function scheduleShortLinkRefresh() {
  if (!shortLinkBox) return;
  if (shortLinkTimer) {
    clearTimeout(shortLinkTimer);
  }
  shortLinkTimer = setTimeout(() => {
    shortLinkTimer = null;
    const full = window.location.href;
    if (!full || full === lastShortLinkFull) {
      return;
    }
    requestShortLink(full);
  }, 500);
}

function requestShortLink(fullURL) {
  if (!shortLinkBox) return;
  pendingShortLinkFull = fullURL;

  let controller = null;
  if (typeof AbortController !== 'undefined') {
    if (shortLinkAbort) {
      shortLinkAbort.abort();
    }
    controller = new AbortController();
    shortLinkAbort = controller;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ url: fullURL, commit: false })
  };
  if (controller) {
    options.signal = controller.signal;
  }

  fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('shorten failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (pendingShortLinkFull !== fullURL) {
        return;
      }
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      applyShortLink(data);
    })
    .catch(err => {
      if (err && err.name === 'AbortError') {
        return;
      }
      if (pendingShortLinkFull === fullURL) {
        pendingShortLinkFull = '';
        hideShortLink();
      }
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      console.error('short link fetch failed', err);
    });
}

function applyShortLink(details) {
  if (!shortLinkBox || !details) return;
  const shortURL = details.short || '';
  const code = details.code || '';
  const target = details.target || '';
  const stored = details.stored ? 'true' : 'false';
  if (!shortURL || !target) {
    hideShortLink();
    return;
  }
  shortLinkBox.style.display = 'block';
  shortLinkBox.textContent = shortURL;
  shortLinkBox.dataset.href = shortURL;
  shortLinkBox.dataset.code = code;
  shortLinkBox.dataset.target = target;
  shortLinkBox.dataset.persisted = stored;
}

function hideShortLink() {
  if (!shortLinkBox) return;
  if (window.__hideShortLinkHint) {
    window.__hideShortLinkHint();
  }
  shortLinkBox.style.display = 'none';
  delete shortLinkBox.dataset.href;
  delete shortLinkBox.dataset.code;
  delete shortLinkBox.dataset.target;
  delete shortLinkBox.dataset.persisted;
}

// finalizeShortLink persists the reserved code only after the visitor copies it.
// Returning a promise keeps the UI non-blocking while honoring the "share memory
// by communicating" proverb — the page communicates with the backend instead of
// toggling global flags.
function finalizeShortLink() {
  if (!shortLinkBox) {
    return Promise.reject(new Error('short link box missing'));
  }
  const persisted = shortLinkBox.dataset.persisted === 'true';
  const href = shortLinkBox.dataset.href || '';
  const target = shortLinkBox.dataset.target || '';
  const code = shortLinkBox.dataset.code || '';
  if (!target) {
    return Promise.reject(new Error('missing short link target'));
  }
  if (persisted && href) {
    return Promise.resolve(href);
  }
  if (shortLinkCommitPromise) {
    return shortLinkCommitPromise;
  }

  const payload = { url: target, commit: true };
  if (code) {
    payload.code = code;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  };

  const pending = fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('commit failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      applyShortLink(data);
      return data.short;
    });

  shortLinkCommitPromise = pending;
  pending.finally(() => {
    if (shortLinkCommitPromise === pending) {
      shortLinkCommitPromise = null;
    }
  });
  return pending;
}

// copyShortLinkToClipboard waits for the backend to confirm persistence so
// users never copy a dangling preview link. The clipboard work stays inside the
// fulfilled branch to avoid race conditions when multiple copy attempts happen.
function copyShortLinkToClipboard() {
  if (!shortLinkBox) return;
  finalizeShortLink()
    .then(link => {
      if (!link) {
        throw new Error('empty short link');
      }

      const signalSuccess = () => {
        if (!shortLinkBox) return;
        shortLinkBox.classList.add('copied');
        setTimeout(() => shortLinkBox.classList.remove('copied'), 600);
      };

      const fallbackCopy = () => {
        const textarea = document.createElement('textarea');
        textarea.value = link;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.top = '-1000px';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          if (document.execCommand('copy')) {
            signalSuccess();
          }
        } catch (err) {
          console.error('copy failed', err);
        } finally {
          document.body.removeChild(textarea);
        }
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(link)
          .then(signalSuccess)
          .catch(() => fallbackCopy());
      } else {
        fallbackCopy();
      }
    })
    .catch(err => {
      console.error('finalize short link failed', err);
    });
}

function loadMapFromUrl() {
  const params = new URLSearchParams(window.location.search);

  /* base layer from URL or default */
  const layer = decodeURIComponent(params.get('layer') || defaultCfg.layer);
  setBaseLayer(layer);

  /* read remaining params */
  const minLat = parseFloat(params.get('minLat'));
  const minLon = parseFloat(params.get('minLon'));
  const maxLat = parseFloat(params.get('maxLat'));
  const maxLon = parseFloat(params.get('maxLon'));

  if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
    adjustMarkerRadius();
  } else if (isTrackView && trackBounds) {
    map.fitBounds(trackBounds);
  } else {
    map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
  }
}

function updateUrl() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  var newUrl = `${window.location.pathname}?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;

  window.history.replaceState({}, '', newUrl);
  scheduleShortLinkRefresh();
}

function openServerPoster() {
  if (typeof updateUrl === 'function') { try { updateUrl(); } catch(_){} }
  var full = window.location.href;
  var dst  = '/qrpng?u=' + encodeURIComponent(full);
  window.open(dst, '_blank', 'noopener,noreferrer');
}

function initializeUIElements() {
  var locateButton = document.getElementById('locateButton');
  if (locateButton) {
    locateButton.addEventListener('click', centerMapToLocation);
  }
  var qrButton = document.getElementById('qrButton');
  if (qrButton) {
    qrButton.addEventListener('click', openServerPoster);
  }
  var backToAllButton = document.getElementById('backToAllButton');
  if (backToAllButton) {
    backToAllButton.addEventListener('click', function () {
      var params = (typeof getCurrentUrlParams === 'function') ? getCurrentUrlParams() : '';
      window.location.href = '/' + params;
    });
  }

  // Keep the download button aligned with the current track state even if
  // the DOM was injected before listeners finished binding.
  refreshDownloadLink();

  if (shortLinkBox) {
    const hint = translate('short_link_tooltip');
    shortLinkBox.setAttribute('title', hint);
    shortLinkBox.setAttribute('aria-label', hint);
    shortLinkBox.addEventListener('click', () => {
      copyShortLinkToClipboard();
    });
    shortLinkBox.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        copyShortLinkToClipboard();
      }
    });
  }

  scheduleShortLinkRefresh();
}

function centerMapToLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function(position) {
        var userLat = position.coords.latitude;
        var userLon = position.coords.longitude;

        map.setView([userLat, userLon], 15);

        L.marker([userLat, userLon]).addTo(map)
          .bindPopup(translate("your_location")).openPopup();
      },
      function(error) {
        switch(error.code) {
          case error.PERMISSION_DENIED:
            alert(translate("location_permission_denied"));
            break;
          case error.POSITION_UNAVAILABLE:
            alert(translate("location_unavailable"));
            break;
          case error.TIMEOUT:
            alert(translate("location_timeout"));
            break;
          default:
            alert(translate("location_error"));
            break;
        }
      }
    );
  } else {
    alert(translate("geolocation_not_supported"));
  }
}
    </script>

    <!-- File upload script -->
    <script>
      function uploadFiles() {
        const fileInput  = document.getElementById('fileInput');
        const files      = fileInput.files;
        if (!files.length) {
          alert(translate('select_files'));
          return;
        }

        const fileOverlay          = document.getElementById('fileOverlay');
        const fileProgressContainer = document.getElementById('fileProgressContainer');
        fileProgressContainer.innerHTML = '';
        fileOverlay.style.display  = 'flex';

        /* counter and URL of last track */
        let completedUploads = 0;
        const totalFiles     = files.length;
        let lastTrackURL     = null;

        /* Create an XHR for each file but redirect only once */
        [...files].forEach(file => {
          /* --- visual progress elements --- */
          const fileBlock        = document.createElement('div');
          fileBlock.className    = 'file-progress';
          const fileName         = document.createElement('div');
          fileName.className     = 'file-name';
          fileName.innerText     = file.name;
          const progressBar      = document.createElement('div');
          progressBar.className  = 'progress-bar';
          const progressBarInner = document.createElement('div');
          progressBarInner.className = 'progress-bar-inner';
          progressBar.appendChild(progressBarInner);
          const serverProcessing = document.createElement('div');
          serverProcessing.className = 'server-processing';
          serverProcessing.innerText = translate('waiting_for_server');
          fileBlock.append(fileName, progressBar, serverProcessing);
          fileProgressContainer.appendChild(fileBlock);
          /* ------------------------------------------------- */

          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload', true);

          /* file upload progress */
          xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
              const percent = (e.loaded / e.total) * 100;
              progressBarInner.style.width = percent + '%';
            }
          };

          /* handle server response */
          xhr.onload = () => {
            if (xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              if (response.status === 'success') {
                lastTrackURL             = response.trackURL;   // remember
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
              } else {
                serverProcessing.innerText = translate('error_processing_files');
                serverProcessing.style.color = 'red';
              }
            } else {
              serverProcessing.innerText = translate('error_during_upload');
              serverProcessing.style.color = 'red';
            }

            /* increment counter and redirect when done */
              completedUploads++;
            if (completedUploads === totalFiles) {
              setTimeout(() => {
                fileOverlay.style.display = 'none';
                /* redirect to last successfully processed track */
                  if (lastTrackURL) {
                    window.location.href = lastTrackURL;
                  } else {
                    location.reload();   // if all uploads failed
                  }
              }, 700);
            }
          };

          /* send file */
            const formData = new FormData();
          formData.append('files[]', file);
          xhr.send(formData);
        });
      }
    </script>


    <!-- Theme toggle script -->
    <script>
      // Synchronize UI theme with map tiles and remember the choice for the session.
      document.addEventListener('DOMContentLoaded', function () {
        var sw = document.getElementById('themeSwitch');
        if (!sw) return;
        var media = window.matchMedia('(prefers-color-scheme: dark)');

        function applyTheme(theme) {
          document.documentElement.dataset.theme = theme; // switch CSS variables
          if (window.osmLayer) {
            window.osmLayer.setUrl(theme === 'dark' ? window.osmDark : window.osmLight);
          }
          sw.checked = theme === 'dark';
        }

        var storedTheme = sessionStorage.getItem('themePreference');
        var initialTheme = storedTheme ? storedTheme : (media.matches ? 'dark' : 'light');
        applyTheme(initialTheme); // set initial state

        sw.addEventListener('change', function () {
          var newTheme = this.checked ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });

        var toggleBox = document.getElementById('themeToggle');
        if (toggleBox) {
          toggleBox.addEventListener('keydown', function (ev) {
            if (ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              sw.checked = !sw.checked;
              sw.dispatchEvent(new Event('change'));
            }
          });
        }

        media.addEventListener('change', function (e) {
          var newTheme = e.matches ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });
      });
    </script>


<!--
  When the legend is clicked:
    • Fetch language-specific full text.
    • Split into paragraphs and decorate range lines with color squares.
    • Show modal; close on backdrop click for convenience.
-->
<script>
  // Build legend HTML with color squares for tooltip and modal.
  function buildLegendHTML(lang) {
    var key = 'legend_full_' + lang;
    var txt = translate(key);
    var parts = txt.split('\n\n');
    function stripBullet(line) {
      return line.replace(/^■\s*/, '');
    }
    function square(color) {
      return '<span class="legend-square" style="background:' + color + ';"></span>';
    }
    return parts.map(function(p){
      var lines = p.split('\n').map(function(line){
        if (line.includes('0–11')) return square('#008000') + stripBullet(line);
        if (line.includes('11–30')) return square('#FFD700') + stripBullet(line);
        if (line.includes('30–100')) return square('#FF4500') + stripBullet(line);
        if (line.includes('>100')) return square('#000000') + stripBullet(line);
        return line;
      }).join('<br>');
      return '<p style="margin:0 0 1em 0;">' + lines + '</p>';
    }).join('');
  }

  // Display the full legend text in current language.
  // Exposed so marker popups reuse the same modal.
  function openLegendModal() {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    var lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
    var html = buildLegendHTML(lang);
    var box = document.getElementById('legendText');
    if (box) box.innerHTML = html;
    var modal = document.getElementById('legendModal');
    if (modal) modal.style.display = 'flex';
  }

  // Build HTML for info modal from translation text
  function buildInfoHTML(txt) {
    return txt.split('\n\n').map(function(p){
      return '<p style="margin:0 0 1em 0;">' + p.split('\n').join('<br>') + '</p>';
    }).join('');
  }

  // Turn license mentions into modal triggers so readers stay on the map page.
  function decorateLicenseLinks(txt) {
    if (typeof txt !== 'string' || !txt) {
      return txt;
    }
    var withMitAnchor = txt.replace(/<a[^>]*href=\u0022\/LICENSE\u0022[^>]*>([\s\S]*?)<\/a>/gi, function(_, label) {
      return '<a href="#" class="license-link" data-license="mit">' + label + '</a>';
    });
    var withCc0Anchor = withMitAnchor.replace(/Creative Commons 1\.0(\s*\(CC0\))?/gi, function(match) {
      return '<a href="#" class="license-link" data-license="cc0">' + match + '</a>';
    });
    return withCc0Anchor;
  }

  // Open a specific license modal based on the identifier requested by the user.
  // We fetch the source file lazily so embedded binaries stay in sync with
  // the repository licenses even when served offline.
  function openLicenseModal(code) {
    if (!code) return;
    var selector = '.license-modal[data-license="' + code + '"]';
    var modal = document.querySelector(selector);
    if (!modal) return;

    var body = modal.querySelector('[data-license-url]');
    if (body) {
      var loadedState = body.getAttribute('data-license-loaded');
      var loadingState = body.getAttribute('data-license-loading');
      if (loadedState !== 'true' && loadingState !== 'true') {
        var url = body.getAttribute('data-license-url');
        if (url) {
          body.textContent = 'Loading…';
          body.setAttribute('data-license-loading', 'true');

          var handleSuccess = function(text) {
            body.textContent = text;
            body.setAttribute('data-license-loaded', 'true');
            body.setAttribute('data-license-loading', 'false');
          };

          var handleError = function(err) {
            if (window.console && console.error) {
              console.error('Failed to load license text for', code, err);
            }
            body.textContent = 'Unable to load the license text. Please download it from the repository.';
            body.setAttribute('data-license-loaded', 'error');
            body.setAttribute('data-license-loading', 'false');
          };

          if (window.fetch) {
            fetch(url, { cache: 'no-store' })
              .then(function(resp) {
                if (!resp.ok) {
                  throw new Error('HTTP ' + resp.status);
                }
                return resp.text();
              })
              .then(handleSuccess)
              .catch(handleError);
          } else {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  handleSuccess(xhr.responseText);
                } else {
                  handleError(new Error('HTTP ' + xhr.status));
                }
              }
            };
            xhr.onerror = function() { handleError(new Error('network error')); };
            xhr.send();
          }
        }
      }
    }

    modal.style.display = 'flex';
  }

  // Close the provided license modal so the overlay disappears cleanly.
  function closeLicenseModal(modal) {
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // Example definitions stay in code so translations only supply human text.
  const apiExamples = [
    { key: 'root', method: 'api_method_get', methodFallback: 'GET', path: '/api', url: '/api' },
    { key: 'latest', method: 'api_method_get', methodFallback: 'GET', path: '/api/latest', url: '/api/latest?lat=35.6804&lon=139.7690&radius_m=1500&limit=20' },
    { key: 'tracks', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks', url: '/api/tracks?limit=25' },
    { key: 'track_index', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks/index/{number}', url: '/api/tracks/index/1' },
    { key: 'archive', method: 'api_method_get', methodFallback: 'GET', path: '/api/json/{frequency}.tgz', url: '/api/json/weekly.tgz' }
  ];

  // Build the localized API quickstart cards so the modal keeps site styling.
  function buildApiHTML() {
    var html = [];
    var intro = translate('api_intro');
    if (intro && intro !== 'api_intro') {
      html.push('<p class="api-intro">' + intro + '</p>');
    }
    var note = translate('api_examples_note');
    if (note && note !== 'api_examples_note') {
      html.push('<p class="api-note">' + note + '</p>');
    }
    var heading = translate('api_examples_heading');
    if (heading && heading !== 'api_examples_heading') {
      html.push('<h4 class="api-heading">' + heading + '</h4>');
    }
    html.push('<div class="api-grid">');
    apiExamples.forEach(function(example) {
      var title = translate('api_example_' + example.key + '_title');
      var desc = translate('api_example_' + example.key + '_desc');
      var linkText = translate('api_example_' + example.key + '_link');
      var noteText = translate('api_example_' + example.key + '_note');
      var methodLabel = translate(example.method);
      if (typeof methodLabel !== 'string' || methodLabel === example.method) {
        methodLabel = example.methodFallback;
      }
      html.push('<article class="api-card">');
      html.push('<div class="api-card-head">');
      html.push('<span class="api-method">' + methodLabel + '</span>');
      html.push('<span class="api-path">' + example.path + '</span>');
      html.push('</div>');
      if (title && title !== 'api_example_' + example.key + '_title') {
        html.push('<h5 class="api-card-title">' + title + '</h5>');
      }
      if (desc && desc !== 'api_example_' + example.key + '_desc') {
        html.push('<p class="api-card-desc">' + desc + '</p>');
      }
      if (linkText && linkText !== 'api_example_' + example.key + '_link') {
        html.push('<a class="api-card-link" href="' + example.url + '" target="_blank" rel="noopener">' + linkText + '</a>');
      }
      if (noteText && noteText !== 'api_example_' + example.key + '_note') {
        html.push('<p class="api-card-note">' + noteText + '</p>');
      }
      html.push('</article>');
    });
    html.push('</div>');
    var more = translate('api_more_docs');
    var moreLink = translate('api_more_docs_link_label');
    if (more && more !== 'api_more_docs') {
      var suffix = '';
      if (moreLink && moreLink !== 'api_more_docs_link_label') {
        suffix = ' <a href="/api/docs" target="_blank" rel="noopener">' + moreLink + '</a>';
      }
      html.push('<p class="api-more">' + more + suffix + '</p>');
    }
    return html.join('');
  }

  // Open modal with legal, source or license text
  function openInfoModal(topic) {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    if (topic === 'api') {
      var boxApi = document.getElementById('infoText');
      if (boxApi) {
        boxApi.innerHTML = buildApiHTML();
      }
      var headApi = document.getElementById('infoTitle');
      if (headApi) {
        headApi.textContent = translate('api_title');
      }
      var modalApi = document.getElementById('infoModal');
      if (modalApi) {
        modalApi.style.display = 'flex';
      }
      return;
    }
    var box = document.getElementById('infoText');
    var infoText = translate(topic + '_full');
    if (topic === 'legal' && typeof window.supportEmail === 'string' && window.supportEmail.trim() !== '') {
      infoText += '\n\n' + translate('legal_contact') + ' ' + window.supportEmail.trim();
    }
    if (topic === 'license') {
      infoText = decorateLicenseLinks(infoText);
    }
    if (box) box.innerHTML = buildInfoHTML(infoText);
    var head = document.getElementById('infoTitle');
    if (head) head.textContent = translate(topic + '_title');
    var modal = document.getElementById('infoModal');
    if (modal) modal.style.display = 'flex';
  }

  // Use event delegation because popups are created dynamically.
  document.addEventListener('click', function(ev) {
    // open legend modal when risk link clicked
    if (ev.target.classList.contains('risk-link')) {
      ev.preventDefault();
      openLegendModal();
    }
    if (ev.target.classList.contains('live-chart-link')) {
      ev.preventDefault();
      const dataset = ev.target.dataset;
      if (!dataset.device) return;
      const fallback = {
        device: dataset.device,
        name: dataset.name || '',
        transport: dataset.transport || '',
        tube: dataset.tube || '',
        country: dataset.country || '',
        lat: dataset.lat || '',
        lon: dataset.lon || '',
      };
      openLiveModal(dataset.device, fallback);
    }
    // switch to track view when track link clicked
    if (ev.target.classList.contains('track-link')) {
      ev.preventDefault();
      viewTrack(ev.target.dataset.track);
    }
    // open info modal for attribution links
    if (ev.target.classList.contains('attr-link')) {
      ev.preventDefault();
      openInfoModal(ev.target.dataset.info);
    }
    if (ev.target.classList.contains('license-link')) {
      ev.preventDefault();
      openLicenseModal(ev.target.dataset.license);
    }
  });

  (function(){
    var el = document.getElementById('legend');
    if (el) {
      el.addEventListener('click', openLegendModal);
    }
    // Close on backdrop click (UX nicety)
    var modal = document.getElementById('legendModal');
    if (modal) {
      modal.addEventListener('click', function(e){
        if (e.target === modal) modal.style.display = 'none';
      });
    }
    var infoModal = document.getElementById('infoModal');
    if (infoModal) {
      infoModal.addEventListener('click', function(e){
        if (e.target === infoModal) infoModal.style.display = 'none';
      });
    }
    var licenseModals = document.querySelectorAll('.license-modal');
    if (licenseModals && licenseModals.length) {
      for (var i = 0; i < licenseModals.length; i++) {
        (function(modalEl){
          modalEl.addEventListener('click', function(e){
            if (e.target === modalEl) closeLicenseModal(modalEl);
          });
        })(licenseModals[i]);
      }
    }
    var licenseCloseButtons = document.querySelectorAll('.license-modal-close');
    if (licenseCloseButtons && licenseCloseButtons.length) {
      for (var j = 0; j < licenseCloseButtons.length; j++) {
        (function(btn){
          btn.addEventListener('click', function(){
            var modalEl = btn;
            while (modalEl && (!modalEl.classList || !modalEl.classList.contains('license-modal'))) {
              modalEl = modalEl.parentNode;
            }
            closeLicenseModal(modalEl);
          });
        })(licenseCloseButtons[j]);
      }
    }
    var liveModal = document.getElementById('liveModal');
    if (liveModal) {
      liveModal.addEventListener('click', function(e){
        if (e.target === liveModal) hideLiveModal();
      });
    }
    var liveClose = document.getElementById('liveModalClose');
    if (liveClose) {
      liveClose.addEventListener('click', function(){ hideLiveModal(); });
    }
  })();
</script>
  </body>
</html>
